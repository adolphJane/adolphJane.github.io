<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Xmake教程 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Xmake教程</h1>
     
        <div class="read-more clearfix">
          <span class="date">2023/05/08</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='C++.html'>C++</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>没想到经过这么多年的发展，C/C++ 程序的构建过程还是这么繁琐。</p>
<p>如果我们不借助 IDE 工具，很难快速地构建一个新的 C/C++ 程序。如果想要跨平台构建，那就更加麻烦了。MakeFile和Cmake工具用起来又比较繁琐，跨平台构建不够灵活，比较繁琐。</p>
<span id="more"></span><!-- more -->
<p>这个时候，发现了Xmake工具，能方便构建C++程序。</p>
<p><a href="https://xmake.io/#/">官网</a><br />
<a href="https://github.com/xmake-io/xmake">GitHub</a></p>
<h2><a id="xmake%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xmake 的基础概念</h2>
<p>Xmake 是一个<strong>基于 Lua 的轻量级跨平台 C/C++ 构建工具</strong>，使用 xmake.lua 维护项目构建。</p>
<p>相比 makefile/CMakeLists.txt，配置语法更加简洁直观，对新手非常友好，短时间内就能快速入门，让用户把更多的精力集中在实际的项目开发上。</p>
<p>虽然简单易用是 xmake 的一大特色，但 xmake 的功能也非常强大。</p>
<p>既能够像 make/ninja 那样直接编译项目，也可以像 cmake/meson 那样生成工程文件，还有内置的包管理系统帮助用户解决 C/C++ 依赖库的集成使用问题。</p>
<p>我们也可以把Xmake理解为</p>
<pre><code class="language-plain_text">Xmake = Build backend + Project Generator + Package Manager
</code></pre>
<h2><a id="xmake%E5%AE%89%E8%A3%85%E5%92%8C%E6%9B%B4%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xmake 安装和更新</h2>
<h3><a id="%E5%AE%89%E8%A3%85master%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Master版本</h3>
<p>通常情况下我们只需要通过一键安装脚本即可完成安装。</p>
<h4><a id="%E4%BD%BF%E7%94%A8curl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用curl</h4>
<pre><code class="language-plain_text">bash &lt;(curl -fsSL https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh)
</code></pre>
<h4><a id="%E4%BD%BF%E7%94%A8wget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用wget</h4>
<pre><code class="language-plain_text">bash &lt;(wget https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh -O -)
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8powershell" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用powershell</h3>
<pre><code class="language-plain_text">Invoke-Expression (Invoke-Webrequest 'https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.ps1' -UseBasicParsing).Content
</code></pre>
<blockquote>
<p>注：如果ps脚本执行提示失败，可以尝试在管理员模式下执行</p>
</blockquote>
<h3><a id="%E5%AE%89%E8%A3%85windows%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Windows版本</h3>
<h4><a id="%E4%BD%BF%E7%94%A8%E5%AE%89%E8%A3%85%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用安装包</h4>
<p>windows下提供了预制的nsis安装包，我们可直接从github的Releases下载页面下载后，运行安装包即可。</p>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载windows安装包</li>
<li>运行安装程序 xmake-[version].exe</li>
</ol>
<h4><a id="%E4%BD%BF%E7%94%A8scoop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用scoop</h4>
<pre><code class="language-plain_text">scoop install xmake
</code></pre>
<h3><a id="macos" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MacOS</h3>
<h4><a id="%E4%BD%BF%E7%94%A8homebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Homebrew</h4>
<pre><code class="language-plain_text">brew install xmake
</code></pre>
<h4><a id="%E4%BD%BF%E7%94%A8%E5%AE%89%E8%A3%85%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用安装包</h4>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载pkg安装包</li>
<li>双击运行</li>
</ol>
<h4><a id="%E5%AE%89%E8%A3%85master%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装master版本</h4>
<pre><code class="language-plain_text"># 使用homebrew安装master版本
$ brew install xmake --HEAD

# 或者直接调用shell下载安装
$ bash &lt;(curl -fsSL https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh)
</code></pre>
<h3><a id="linux" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux</h3>
<h4><a id="archlinux%E4%B8%8A%E5%AE%89%E8%A3%85%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>archlinux上安装：</h4>
<pre><code class="language-plain_text">$ yaourt xmake
</code></pre>
<h4><a id="%E4%B8%8B%E8%BD%BDdeb%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下载deb包</h4>
<ol>
<li>从 <a href="https://github.com/xmake-io/xmake/releases">Releases</a> 上下载deb安装包</li>
<li>运行: <code>dpkg -i xmake-xxxx.deb</code></li>
</ol>
<h3><a id="%E6%9B%B4%E6%96%B0%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更新升级</h3>
<p>从v2.2.3版本开始，新增了<code>xmake update</code>命令，来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个版本：</p>
<pre><code class="language-plain_text">$ xmake update 2.2.4
</code></pre>
<p>也可以指定更新到master/dev分支版本：</p>
<pre><code class="language-plain_text">$ xmake update master
$ xmake update dev
</code></pre>
<p>从指定git源更新</p>
<pre><code class="language-plain_text">$ xmake update github:xmake-io/xmake#master
$ xmake update gitee:tboox/xmake#dev # gitee镜像
</code></pre>
<h3><a id="%E5%8D%B8%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>卸载</h3>
<pre><code class="language-plain_text">xmake update --uninstall
</code></pre>
<h2><a id="%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BC%96%E8%AF%91%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建和编译工程</h2>
<h3><a id="%E5%88%9B%E5%BB%BA%E7%A9%BA%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建空工程</h3>
<p>xmake提供了<code>xmake create</code>命令，可以很方便的快速创建基于c/c++, swift, objc等各种语言的空工程项目，比如：</p>
<pre><code class="language-plain_text">$ xmake create test
create test ...
  [+]: xmake.lua
  [+]: src/main.cpp
  [+]: .gitignore
create ok!
</code></pre>
<p>默认会创建一个c++的hello world工程，根目录下会生成一个xmake.lua用于描述项目的构建规则。</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)
target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.cpp&quot;) 
</code></pre>
<p>这是一个非常简单的xmake.lua描述，<code>target(&quot;test&quot;)</code>定义了一个子工程模块test，每个target会生成一个对应的目标文件，此处的binary类型，指定创建一个最基础的可执行文件。<br />
而最上面的<code>mode.debug</code>和<code>mode.release</code>规则设置，是可选设置，但是通常我们都会建议加上，这样默认就可以生效两种常用的构建模式：debug和release</p>
<h3><a id="%E6%89%A7%E8%A1%8C%E7%BC%96%E8%AF%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行编译</h3>
<p>通常我们如果只是编译<strong>当前主机环境</strong>的可执行文件，只需要执行<code>xmake</code>这个命令就可以了：</p>
<pre><code class="language-plain_text">$ xmake
checking for the Xcode directory ... /Applications/Xcode.app
checking for the SDK version of Xcode ... 10.15
[  0%]: ccache compiling.release src/main.cpp
[100%]: linking.release test
</code></pre>
<p>xmake默认会检测当前环境已存在的构建环境，比如笔者当前的xcode环境，然后<strong>默认采用release模式</strong>编译，如果设置了<code>mode.release</code>规则，那么就会生效。</p>
<h3><a id="%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译模式切换</h3>
<p>如果我们要切到<code>mode.debug</code>编译，只需要：</p>
<pre><code class="language-plain_text">$ xmake f -m debug
$ xmake
</code></pre>
<p>其中，<code>xmake f</code>是<code>xmake config</code>命令的简写，用来快速的切换配置，如果上手之后，通常采用简写会更加方便，更多命令的简写，都可执行<code>xmake --help</code>查看。</p>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%85%B6%E4%BB%96%E6%A8%A1%E6%9D%BF%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建其他模板工程</h3>
<p><code>xmake create</code>还可以用来创建各种其他类型的工程项目，我们可以敲<code>xmake create --help</code>看下：</p>
<pre><code class="language-plain_text">$ xmake create --help
Usage: $xmake create [options] [target]

Create a new project.

Options: 
                                           
    -l LANGUAGE, --language=LANGUAGE       The project language (default: c++)
                                               - c++
                                               - go
                                               - dlang
                                               - cuda
                                               - rust
                                               - swift
                                               - objc
                                               - c
                                               - objc++
    -t TEMPLATE, --template=TEMPLATE       Select the project template id or name of the given language. 
                                           (default: console)
                                               - console: c++, go, dlang, cuda, rust, swift, objc, c, objc++
                                               - qt.console: c++
                                               - qt.quickapp: c++
                                               - qt.quickapp_static: c++
                                               - qt.shared: c++
                                               - qt.static: c++
                                               - qt.widgetapp: c++
                                               - qt.widgetapp_static: c++
                                               - shared: c++, dlang, cuda, c
                                               - static: c++, go, dlang, cuda, rust, c
                                               - tbox.console: c++, c
                                               - tbox.shared: c++, c
                                               - tbox.static: c++, c
                                           
    target                                 Create the given target.
                                           Uses the project name as target if not exists.
</code></pre>
<p>可以通过<code>-l</code>/<code>--language</code>来指定工程语言，而<code>-t</code>/<code>--template</code>用来指定闯将的工程模板类型。</p>
<p>比如，我们创建一个基于c的静态库项目：</p>
<pre><code class="language-plain_text">$ xmake create -l c -t static test
create test ...
  [+]: xmake.lua
  [+]: src/interface.c
  [+]: src/interface.h
  [+]: src/test.c
  [+]: src/main.cpp
  [+]: .gitignore
create ok!
</code></pre>
<h2><a id="%E8%BF%90%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行和调试目标程序</h2>
<h3><a id="%E8%BF%90%E8%A1%8C%E7%94%9F%E6%88%90%E7%9B%AE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行生成目标</h3>
<p>xmake也提供了run命令，直接运行生成后的可执行文件，用于方便快速的进行测试，例如：</p>
<pre><code class="language-plain_text">$ xmake run
hello xmake!
</code></pre>
<h3><a id="%E6%B7%BB%E5%8A%A0%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加运行环境变量</h3>
<p>我们也可以在xmake.lua中通过<code>add_runenvs</code>接口来添加设置默认运行target程序的环境变量。</p>
<p>所以，对于PATH这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有path sep的多值env。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_runenvs(&quot;PATH&quot;, &quot;/tmp/bin&quot;, &quot;xxx/bin&quot;)
    add_runenvs(&quot;LD_LIBRARY_PATH&quot;, &quot;/tmp/lib&quot;, &quot;xxx/lib&quot;)
</code></pre>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义运行逻辑</h3>
<p>如果单纯的环境设置，以及默认的加载运行规则不满足需求，我们可以通过定制化on_run脚本，实现更加复杂的运行逻辑：</p>
<p>例如，运行安装好的apk程序：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    -- ...
    -- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息
    on_run(function (target) 
        os.run(&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;)
        os.run(&quot;adb logcat&quot;)
    end)
</code></pre>
<h3><a id="%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试程序</h3>
<h4><a id="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令行调试</h4>
<p>我们也可以传递<code>-d</code>参数，调用gdb/lldb等调试器程序，加载目标文件进行调试：</p>
<pre><code class="language-plain_text">$ xmake run -d  
</code></pre>
<p>xmake将会使用系统自带的调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。</p>
<h4><a id="%E4%BD%BF%E7%94%A8vscode%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用vscode进行断点调试</h4>
<p>我们还可以通过xmake-vscode插件配合vscode来实现对c/c++项目的断点调试支持。<br />
另外我们还需要依赖vscode的C++插件才能进行调试支持，不过由于开发c/c++程序，这个插件几乎是必需，所以并没有太大问题。<br />
就算没有安装此插件，xmake-vscode也会加载lldb/gdb/vsjitdebugger等系统调试器，直接加载调试。</p>
<h2><a id="%E5%B8%B8%E7%94%A8cc%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用C/C++项目描述设置详解</h2>
<p>一行描述即可编译src目录下所有c源文件，然后生成一个名为demo的可执行文件。</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;, {kind = &quot;binary&quot;, files = &quot;src/*.c&quot;})
</code></pre>
<p>上面的写法是精简写法，通常我们更推荐使用下面展开式写法：</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<p>这两者完全等价，如果配置很简短，可以完全精简成一行，而拆分成多行更加方便灵活配置。</p>
<h3><a id="%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置项目目标类型</h3>
<p>通常的C/C++项目生成的目标文件猪油三大类：<strong>可执行程序</strong>，<strong>静态库</strong>，<strong>动态库</strong>。</p>
<p>我们可以通过<code>set_kind()</code>配置来设置，分别对应：<code>binary</code>, <code>static</code>, <code>shared</code></p>
<p>例如，我们想要编译动态库，只需要修改kind：</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<h3><a id="%E6%B7%BB%E5%8A%A0%E5%AE%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加宏定义</h3>
<p>编译宏的设置，大多数c/c++项目都会用到，一般如果我们设置编译flags传给gcc/clang，都是要配置：<code>-DXXX</code></p>
<p>而在xmake里面，提供了<code>add_defines()</code>内置接口来配置：</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;XXX&quot;)
</code></pre>
<h3><a id="%E6%9D%A1%E4%BB%B6%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>条件配置</h3>
<p>那如果我们想在不同编译平台，分别设置不同的宏开关呢？我们可以利用lua内置的if语句很方便的实现：</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;XXX&quot;)
    if is_plat(&quot;linux&quot;, &quot;macosx&quot;) then
        add_defines(&quot;YYY&quot;)
    end
</code></pre>
<p>我们通过<code>is_plat()</code>判断，如果当前编译目标平台是<code>linux</code>或者<code>macosx</code>，那么target会额外增加-DYYY宏定义。</p>
<h3><a id="%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局配置</h3>
<p>我们在<code>target(&quot;demo&quot;)</code>下面的所有配置，都属于demo这个target子域，并不是全局的，所以你会看到通常配置上都加了缩进，就是为了凸显作用域的影响范围。</p>
<p>通常如果多个target连续定义，下一个target定义就会自动结束上个target的作用域，每个target的配置完全独立，互不干扰：</p>
<pre><code class="language-plain_text">target(&quot;test1&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST1&quot;)

target(&quot;test2&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST2&quot;)
</code></pre>
<p>例如，上面的配置两个target，各自拥有自己独立的宏定义：<code>TEST1</code>和<code>TEST2</code>。</p>
<p>那么，我们要对这两个target，设置共用的宏定义，应该如何配置呢？</p>
<p>每个target下面都配置一遍<code>add_defines(&quot;TEST&quot;)</code>? 当然可以，不过这样就有点冗余了，配置多了就会很难维护，其实我们只需要放置到全局根作用域就行了：</p>
<pre><code class="language-plain_text">-- 全局设置
add_defines(&quot;TEST&quot;)
if is_arch(&quot;arm64&quot;, &quot;armv7&quot;) then
    add_defines(&quot;ARM&quot;)
end

target(&quot;test1&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST1&quot;)

target(&quot;test2&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST2&quot;)
</code></pre>
<p>在<code>target</code>的外层的所有配置都属于全局配置，我们也可以调用<code>target_end()</code>强制结束<code>target</code>子域，切回全局作用域：</p>
<pre><code class="language-plain_text">target(&quot;test1&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST1&quot;)
target_end()

-- 全局设置
add_defines(&quot;TEST&quot;)
if is_arch(&quot;arm64&quot;, &quot;armv7&quot;) then
    add_defines(&quot;ARM&quot;)
end

target(&quot;test2&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;TEST2&quot;)
target_end()
</code></pre>
<h3><a id="%E6%B7%BB%E5%8A%A0%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加编译选项</h3>
<p>如果有些编译选项，xmake没有提供内置api设置，那么我们可以退化到<code>add_cflags</code>, <code>add_cxflags</code>, <code>add_cxxflags</code>来设置， 不过这就需要用户自己去判断编译平台了，因为并不是所有编译flags每个平台都支持。</p>
<p>比如：</p>
<pre><code class="language-plain_text">add_cflags(&quot;-g&quot;, &quot;-O2&quot;, &quot;-DDEBUG&quot;)
if is_plat(&quot;windows&quot;) then
    add_cflags(&quot;/MT&quot;)
end
</code></pre>
<p>所有选项值都基于gcc的定义为标准，如果其他编译器不兼容（例如：vc），xmake会自动内部将其转换成对应编译器支持的选项值。</p>
<p>用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么xmake会自动忽略器设置。<br />
我们也可以通过force参数来强制禁用flags的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p>
<pre><code class="language-plain_text">add_cflags(&quot;-g&quot;, &quot;-O2&quot;, {force = true})
</code></pre>
<p>那如何知道，哪些flags检测失败给忽略了呢，带-v编译就可以看到，比如：</p>
<pre><code class="language-plain_text">$ xmake -v
checking for the /usr/bin/xcrun -sdk macosx clang ... ok
checking for the flags (-Oz) ... ok
checking for the flags (-Wno-error=deprecated-declarations) ... ok
checking for the flags (-fno-strict-aliasing) ... ok
checking for the flags (-Wno-error=expansion-to-defined) ... no
</code></pre>
<p>最后备注下这三个api的区别：</p>
<ul>
<li><code>add_cflags</code>：仅添加C代码相关编译flags</li>
<li><code>add_cxflags</code>：添加C/C++代码相关编译flags</li>
<li><code>add_cxxflags</code>：仅添加C++代码相关编译flags</li>
</ul>
<h3><a id="%E6%B7%BB%E5%8A%A0%E5%BA%93%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加库相关设置</h3>
<p>一个C/C++库的集成使用，通常需要设置头文件搜索目录，链接库名，库搜索目录，比如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_links(&quot;pthread&quot;)
    add_includedirs(&quot;/usr/local/include&quot;)
    add_linkdirs(&quot;/usr/local/lib&quot;)
</code></pre>
<p>通常，为了保证链接库的依赖顺序，系统库链接通常都会比较靠后，我们通过add_syslinks()来专门设置系统库链接，而add_links()通常用于非系统库链接：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_links(&quot;A&quot;, &quot;B&quot;)
    add_syslinks(&quot;pthread&quot;)
</code></pre>
<p>上面的配置，我们添加了两个第三方链接库：A, B，以及系统库pthread，整个完整的链接顺序是：<code>-lA</code> <code>-lB</code> <code>-lpthread</code>，syslinks会放在最后面。</p>
<p>如果你不确定实际的链接顺序，我们可以执行<code>xmake -v</code>编译，查看完整的链接参数命令行。</p>
<h3><a id="%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置语言标准</h3>
<p>c标准和c++标准可同时进行设置，例如：</p>
<pre><code class="language-plain_text">-- 设置c代码标准：c99， c++代码标准：c++11
set_languages(&quot;c99&quot;, &quot;c++11&quot;)
</code></pre>
<p>注：并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是xmake会尽最大可能的去适配当前编译工具的支持标准。</p>
<p>例如：windows下vs的编译器并不支持按c99的标准来编译c代码，只能支持到c89，但是xmake为了尽可能的支持它，所以在设置c99的标准后，xmake会强制按c++代码模式去编译c代码，从一定程度上解决了windows下编译c99的c代码问题。</p>
<h3><a id="%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置编译优化</h3>
<p>xmake提供了几种内置的编译优化配置：<code>none</code>, <code>fast</code>, <code>faster</code>, <code>fastest</code>, <code>smallest</code>, <code>aggressive</code>，来实现各种级别的编译优化。</p>
<pre><code class="language-plain_text">set_optimize(&quot;fastest&quot;)
</code></pre>
<p>如果用户通过flags来设置，还需额外考虑不同编译器的不同编译选项，xmake对其进行了内部映射处理，极大程度方便用户提供跨平台性。</p>
<p>如果想查看详细的映射规则，可以到xmake的官方文档进行查看：<a href="https://xmake.io/#/zh-cn/manual/project_target?id=targetset_optimize">编译优化设置</a></p>
<h3><a id="%E8%B0%83%E8%AF%95%E5%92%8C%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试和发布模式</h3>
<p>即使xmake提供了<code>set_optimize</code>简化了不同编译器的复杂配置，但是对于不同的编译模式: debug/release，还是要自己做一些繁琐的判断和配置：</p>
<pre><code class="language-plain_text">if is_mode(&quot;debug&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;none&quot;)
end
if is_mode(&quot;release&quot;) then
    set_symbols(&quot;hidden&quot;)
    set_strip(&quot;all&quot;)
    if is_plat(&quot;iphoneos&quot;, &quot;android&quot;) then
        set_optimize(&quot;smallest&quot;)
    else
        set_optimize(&quot;fastest&quot;)
    end
end
</code></pre>
<p>这些看似常用的设置，如果每个项目都来一遍，那也很繁琐了，导致xmake.lua不够精简可读，因此xmake提供了一些常用内置规则来简化设置：</p>
<p>只需这一行即可，效果是完全一致，用户还可以基于此在做一些额外的定制化配置来改写：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.release&quot;, &quot;mode.debug&quot;)
if is_mode(&quot;release&quot;) then
    set_optimize(&quot;fastest&quot;)
end
</code></pre>
<p>比如我想在release模式下，强制启用fastest编译优化，既然有了模式配置，那我们怎么切换到debug模式编译呢？（默认是release编译）</p>
<pre><code class="language-plain_text">xmake f -m debug;
xmake
</code></pre>
<h3><a id="%E6%B7%BB%E5%8A%A0%E6%BA%90%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加源文件</h3>
<p>最后，我们在介绍下xmake最常用，也最为强大的设置之一，也就是对编译源文件的配置管理：<code>add_files()</code>。</p>
<p>我们可以用这个接口，添加各类xmake支持的源文件，比如：c/c++, asm, objc, swift, go, dlang等源文件，甚至是：<code>.obj</code>, <code>.a/.lib</code>等二进制对象和库文件。</p>
<p>例如：</p>
<pre><code class="language-plain_text">add_files(&quot;src/test_*.c&quot;)
add_files(&quot;src/xxx/**.cpp&quot;)
add_files(&quot;src/asm/*.S&quot;, &quot;src/objc/**/hello.m&quot;)
</code></pre>
<p>其中通配符<code>*</code>表示匹配当前目录下文件，而<code>**</code>则匹配多级目录下的文件。</p>
<p><code>add_files</code>的使用其实是相当灵活方便的，其匹配模式借鉴了premake的风格，但是又对其进行了改善和增强。</p>
<p>使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。</p>
<pre><code class="language-plain_text">-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件
add_files(&quot;src/**.c|impl/*.c&quot;)

-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件
add_files(&quot;src/*.cpp|test.cpp|hello.cpp|xx_*.cpp&quot;)
</code></pre>
<p>其中分隔符<code>|</code>之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用<code>|</code>分割就行了。</p>
<p>添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。<br />
注：为了使得描述上更加的精简，|之后的过滤描述都是基于起一个模式：<code>src/*.cpp</code> 中 <code>*</code> 之前的目录为基础的。</p>
<p>所以上面的例子后面过滤的都是在src下的文件，这个是要注意的。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    add_defines(&quot;TEST1&quot;)
    add_files(&quot;src/*.c&quot;)
    add_files(&quot;test/*.c&quot;, &quot;test2/test2.c&quot;, {defines = &quot;TEST2&quot;, languages = &quot;c99&quot;, includedirs = &quot;.&quot;, cflags = &quot;-O0&quot;})
</code></pre>
<p>可以在<code>add_files</code>的最后一个参数，传入一个配置<code>table</code>，去控制指定<code>files</code>的编译选项，里面的配置参数跟target的一致，并且这些文件还会继承target的通用配置<code>-DTEST1</code>。</p>
<p>支持添加未知的代码文件，通过设置rule自定义规则，实现这些文件的自定义构建</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    -- ...
    add_files(&quot;src/test/*.md&quot;, {rule = &quot;markdown&quot;})
</code></pre>
<p>可以通过force参数来强制禁用cxflags,cflags等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p>
<pre><code class="language-plain_text">add_files(&quot;src/*.c&quot;, {force = {cxflags = &quot;-DTEST&quot;, mflags = &quot;-framework xxx&quot;}})
</code></pre>
<h3><a id="%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%BA%90%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除指定源文件</h3>
<p>既然讲到了添加源文件，那么如何删除，我们也顺带着讲下吧，我们只需要通过<code>del_files()</code>接口，就可以从前面<code>add_files</code>接口添加的文件列表中，删除指定的文件，例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    add_files(&quot;src/*.c&quot;)
    del_files(&quot;src/test.c&quot;)
</code></pre>
<p>上面的例子，可以<strong>从src目录下添加除test.c以外的所有文件</strong>，当然这个也可以通过<code>add_files(&quot;src/*.c|test.c&quot;)</code>来达到相同的目的，但是这种方式更加灵活。</p>
<p>例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持<code>add_files</code>的匹配模式，过滤模式，进行批量移除。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    add_files(&quot;src/**.c&quot;)
    del_files(&quot;src/test*.c&quot;)
    del_files(&quot;src/subdir/*.c|xxx.c&quot;)
    if is_plat(&quot;iphoneos&quot;) then
        add_files(&quot;xxx.m&quot;)
    end
</code></pre>
<p>通过上面的例子，我们可以看出<code>add_files</code>和<code>del_files</code>是根据调用顺序，进行顺序添加和删除的，并且通过<code>del_files(&quot;src/subdir/*.c|xxx.c&quot;)</code>删除一批文件，<br />
并且排除<code>src/subdir/xxx.c</code>（就是说，不删除这个文件）。</p>
<h2><a id="android%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android平台编译详解</h2>
<h3><a id="%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>准备工作</h3>
<p>首先，我们需要先准备好编译android native库必须的ndk工具链，如果还没有可以从官网下载解压即可：<a href="https://developer.android.com/ndk?hl=zh-cn">Android NDK</a></p>
<p>如果是为了获取更好的向下兼容性，可以选择r16版本，因为这个是最后一个支持armeabi的版本，如果没什么特别需求，可以直接下载最新版。</p>
<h3><a id="ndk%E9%9B%86%E6%88%90%E5%92%8C%E7%BC%96%E8%AF%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NDK集成和编译</h3>
<h4><a id="%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEndk" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动配置NDK</h4>
<p>我们只需要将解压后ndk目录路径传递给xmake完成配置，可以直接编译了，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p android --ndk=~/downloads/android-ndk-r19c
$ xmake
</code></pre>
<p>其中，<code>-p android</code> 用于切换到android平台，因为如果不指定平台，默认会编译当前主机平台的target程序。<br />
通常，如果没特殊需求，上面的配置就可以完成<code>android native</code>程序的编译，目前xmake内置支持：<code>binary</code>, <code>static</code>, <code>shared</code>这三种基础<code>target</code>类型文件的生成，分别对应<strong>可执行程序</strong>，<strong>.a静态库</strong>，<strong>.so动态库</strong>。</p>
<h4><a id="ndk%E8%B7%AF%E5%BE%84%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NDK路径的全局配置</h4>
<p><code>xmake f/config</code>命令仅仅是针对当前项目的配置，如果经常跨平台编译和配置切换都要重新设置一遍ndk路径，那么还是稍显繁琐。</p>
<p>我们可以通过<code>xmake g/global</code>全局配置命令来设置它，确保永久生效。</p>
<pre><code class="language-plain_text">$ xmake g --ndk=~/xxx/android-ndk-r19c
</code></pre>
<p>我们也可以通过设置<code>ANDROID_NDK_HOME</code>全局环境变量来确保永久生效，这跟上述命令配置的效果是差不多的。</p>
<h4><a id="ndk%E8%B7%AF%E5%BE%84%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8E%A2%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NDK路径的自动探测</h4>
<p>通常情况下即使没有配置ndk路径，xmake还是会尝试默认检测一些常用路径，比如在macos下会自动探测是否存在以下路径：</p>
<pre><code class="language-plain_text">~/Library/Android/sdk/ndk-bundle
</code></pre>
<p>这是mac下装完android studio自动创建的sdk目录，以及ndk的常用放置路径。</p>
<p>或者尝试从<code>ANDROID_NDK_HOME</code>这种环境变量中探测，如果存在的话。</p>
<p>如果能探测到，也就没必要再额外手动配置了。</p>
<h3><a id="c-stl%E5%BA%93%E9%85%8D%E7%BD%AE%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C++ STL库配置切换</h3>
<p>首先，我们先来介绍下，ndk提供的三种stl库版本</p>
<ul>
<li><strong>stlport</strong>：早期ndk内置的stl库，现在基本已废弃</li>
<li><strong>gnustl：ndk</strong> r16b之前主要使用的stl库，但是自从r16b之后，也已经被google去掉了</li>
<li><strong>llvm-c++</strong>：r16b之后较新的ndk内置的stl库</li>
</ul>
<p>因此，我们在编译android库的时候，需要根据自己的需求，选用stl，以及选用合适的ndk版本，而xmake通常会尽可能默认使用llvm-c++库，如果发现当前ndk版本比较老，会尝试退化到gnustl上去。<br />
用户也可以手动修改stl库的版本，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p android --ndk=xxxx --ndk_cxxstl=gnustl_shared
</code></pre>
<p>具体，关于ndk_cxxstl选项的配置值，可以敲help查看，<code>xmake f --help</code>，主要就是：</p>
<ul>
<li>llvmstl_static</li>
<li>llvmstl_shared</li>
<li>gnustl_static</li>
<li>gnustl_shared</li>
<li>stlport_static</li>
<li>stlport_shared</li>
</ul>
<h3><a id="api%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API版本设置</h3>
<p>如果在编译过程中，报出一些libc库符号找不到，通常有可能是api版本没设置对，因为有些libc函数，只有在高版本api下才存在。</p>
<p>这个时候，我们可以通过尝试手动修改api版本来解决：</p>
<pre><code class="language-plain_text">$ xmake f -p android --ndk=xxx --ndk_sdkver=16
</code></pre>
<h3><a id="arch%E7%9A%84%E7%BC%96%E8%AF%91%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>arch的编译切换</h3>
<p>目前xmake提供 <code>armv7-a</code>, <code>arm64-v8a</code>, <code>armv5te</code>, <code>mips</code>, <code>mips64</code>, <code>i386</code>,<code>x86_64</code>这些架构的配置编译，如果没有指定arch，那么默认会使用armv7架构。</p>
<p>手动修改arch方式如下：</p>
<pre><code class="language-plain_text">$ xmake f -p android --ndk=xxx -a arm64-v8a
</code></pre>
<h3><a id="android%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android相关配置设置</h3>
<p>如果项目中需要配置一些只有android平台才有的编译设置，比如添加特定宏开关，链接库等，可以在xmake.lua中，通过<code>is_plat(&quot;android&quot;)</code>来判断处理。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;src/*.c&quot;)
    if is_plat(&quot;android&quot;) then
        add_defines(&quot;ANDROID&quot;)
        add_syslinks(&quot;log&quot;)
    end
</code></pre>
<h2><a id="%E5%88%87%E6%8D%A2%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切换编译模式</h2>
<h3><a id="%E8%B0%83%E8%AF%95%E5%92%8C%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试和发布模式</h3>
<p>通常，如果我们是通过<code>xmake create</code>命令创建的项目，会在xmake.lua里面自动添加一行编译规则的配置，如下：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.release&quot;, &quot;mode.debug&quot;)
target(&quot;hello&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
</code></pre>
<p>通过<code>add_rules</code>接口，我们默认添加了<code>release</code>和<code>debug</code>两个常用的内置规则，它们会在编译的时候附带上对应模式相关的一些编译<code>flags</code>，来开启优化用于发布或者调试编译。</p>
<p>如果仅仅执行了<code>xmake</code>命令，没有额外的配置，那么默认就会是<code>release</code>编译，等价于：</p>
<pre><code class="language-plain_text">$ xmake f -m release
$ xmake
[  0%]: ccache compiling.release src/main.cpp
[100%]: linking.release test
build ok!
</code></pre>
<p>如果我们要切换到debug编译模式，只需要：</p>
<pre><code class="language-plain_text">$ xmake f -m debug
$ xmake
[  0%]: ccache compiling.debug src/main.cpp
[100%]: linking.debug test
build ok!
</code></pre>
<p>上面的<code>-m</code>/<code>--mode=</code>参数就是用来设置编译模式，会跟<code>mode.release</code>和<code>mode.debug</code>这两个规则做关联。</p>
<p>那么，他们是如何关联上的呢？我们可以先来看下这两个规则的内部实现：</p>
<pre><code class="language-plain_text">rule(&quot;mode.debug&quot;)
    after_load(function (target)
        if is_mode(&quot;debug&quot;) then
            if not target:get(&quot;symbols&quot;) then
                target:set(&quot;symbols&quot;, &quot;debug&quot;)
            end
            if not target:get(&quot;optimize&quot;) then
                target:set(&quot;optimize&quot;, &quot;none&quot;)
            end
        end
    end)

rule(&quot;mode.release&quot;)
    after_load(function (target)
        if is_mode(&quot;release&quot;) then
            if not target:get(&quot;symbols&quot;) and target:targetkind() ~= &quot;shared&quot; then
                target:set(&quot;symbols&quot;, &quot;hidden&quot;)
            end
            if not target:get(&quot;optimize&quot;) then
                if is_plat(&quot;android&quot;, &quot;iphoneos&quot;) then
                    target:set(&quot;optimize&quot;, &quot;smallest&quot;)
                else
                    target:set(&quot;optimize&quot;, &quot;fastest&quot;)
                end
            end
            if not target:get(&quot;strip&quot;) then
                target:set(&quot;strip&quot;, &quot;all&quot;)
            end
        end
    end)
</code></pre>
<p>可以看到，在target被加载阶段，xmake会去判断用户对<code>xmake f --mode=xxx</code>的参数配置，如果通过<code>is_mode()</code>接口获取到是debug模式，那么会禁用相关优化并且启用符号输出。</p>
<p>而如果是<code>release</code>模式，那么会开启编译优化并且strip掉所有调试符号。</p>
<h3><a id="%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定制化的模式配置</h3>
<p>当然，内置的这两规则默认设置的这些编译配置，只能满足大部分场景的常规需求，如果用户想要在不同的编译模式下定制化一些个人的编译配置，那么需要自己在xmake.lua做判断。</p>
<p>例如，我们想在release下也启用调试符号，那么只需要：</p>
<pre><code class="language-plain_text">if is_mode(&quot;release&quot;) then
    set_symbols(&quot;debug&quot;)
end
</code></pre>
<p>或者额外增加一些编译flags：</p>
<pre><code class="language-plain_text">if is_mode(&quot;release&quot;) then
    add_cflags(&quot;-fomit-frame-pointer&quot;)
end
</code></pre>
<p>注：如果用户自己的配置和<code>mode.release</code>内置的配置冲突，会优先使用用户的设置。</p>
<p>当然，我们也可以完全不去通过<code>add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)</code>添加默认的配置规则，让用户完全自己控制模式配置：</p>
<pre><code class="language-plain_text">-- 如果当前编译模式是debug
if is_mode(&quot;debug&quot;) then

    -- 添加DEBUG编译宏
    add_defines(&quot;DEBUG&quot;)

    -- 启用调试符号
    set_symbols(&quot;debug&quot;)

    -- 禁用优化
    set_optimize(&quot;none&quot;)
end

-- 如果是release或者profile模式
if is_mode(&quot;release&quot;, &quot;profile&quot;) then

    -- 如果是release模式
    if is_mode(&quot;release&quot;) then

        -- 隐藏符号
        set_symbols(&quot;hidden&quot;)

        -- strip所有符号
        set_strip(&quot;all&quot;)

        -- 忽略帧指针
        add_cxflags(&quot;-fomit-frame-pointer&quot;)
        add_mxflags(&quot;-fomit-frame-pointer&quot;)

    -- 如果是profile模式
    else
        -- 启用调试符号
        set_symbols(&quot;debug&quot;)
    end

    -- 添加扩展指令集
    add_vectorexts(&quot;sse2&quot;, &quot;sse3&quot;, &quot;ssse3&quot;, &quot;mmx&quot;)
end
</code></pre>
<h3><a id="%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AE%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他内置模式规则</h3>
<p>通过上文的例子，我们看到除了debug/release模式，还加了个profile模式的配置判断，其实xmake也提供了对应的内置模式，还有哪些，我们具体来看下：</p>
<h4><a id="mode-debug" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mode.debug</h4>
<p>为当前工程xmake.lua添加debug编译模式的配置规则，例如：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.debug&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="language-plain_text">if is_mode(&quot;debug&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;none&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m debug</code>来切换到此编译模式。</p>
<h4><a id="mode-release" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mode.release</h4>
<p>为当前工程<code>xmake.lua</code>添加<code>release</code>编译模式的配置规则，例如：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.release&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="language-plain_text">if is_mode(&quot;release&quot;) then
    set_symbols(&quot;hidden&quot;)
    set_optimize(&quot;fastest&quot;)
    set_strip(&quot;all&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m release</code>来切换到此编译模式。</p>
<h4><a id="mode-check" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mode.check</h4>
<p>为当前工程xmake.lua添加check编译模式的配置规则，一般用于内存检测，例如：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.check&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="language-plain_text">if is_mode(&quot;check&quot;) then
    set_symbols(&quot;debug&quot;)
    set_optimize(&quot;none&quot;)
    add_cxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_mxflags(&quot;-fsanitize=address&quot;, &quot;-ftrapv&quot;)
    add_ldflags(&quot;-fsanitize=address&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m check</code>来切换到此编译模式。</p>
<h4><a id="mode-profile" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mode.profile</h4>
<p>为当前工程xmake.lua添加profile编译模式的配置规则，一般用于性能分析，例如：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.profile&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="language-plain_text">if is_mode(&quot;profile&quot;) then
    set_symbols(&quot;debug&quot;)
    add_cxflags(&quot;-pg&quot;)
    add_ldflags(&quot;-pg&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m profile</code>来切换到此编译模式。</p>
<h4><a id="mode-coverage" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mode.coverage</h4>
<p>为当前工程xmake.lua添加coverage编译模式的配置规则，一般用于覆盖分析，例如：</p>
<pre><code class="language-plain_text">add_rules(&quot;mode.coverage&quot;)
</code></pre>
<p>相当于：</p>
<pre><code class="language-plain_text">if is_mode(&quot;coverage&quot;) then
    add_cxflags(&quot;--coverage&quot;)
    add_mxflags(&quot;--coverage&quot;)
    add_ldflags(&quot;--coverage&quot;)
end
</code></pre>
<p>我们可以通过：<code>xmake f -m coverage</code>来切换到此编译模式。</p>
<p>注：生成的gcno文件一般都是个obj所在目录对应的哦，因此需要从build目录下去找。</p>
<h3><a id="%E6%89%A9%E5%B1%95%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展自己的编译模式</h3>
<p>xmake的模式配置，并没有固定值，用户可以随意传入和配置，只要<code>xmake f -m/--mode=xxx</code>传入的模式值和<code>xmake.lua</code>里面的<code>is_mode(&quot;xxx&quot;)</code>能对应上就行。<br />
比如，我们设置了一个自己独有的编译模式my_mode，可以直接在命令行配置切换；</p>
<pre><code class="language-plain_text">$ xmake f -m my_mode
$ xmake
[  0%]: ccache compiling.my_mode src/main.cpp
[100%]: linking.my_mode test
build ok!
</code></pre>
<p>然后xmake.lua里面对相应的值进行判断即可：</p>
<pre><code class="language-plain_text">if is_mode(&quot;my_mode&quot;) then
    add_defines(&quot;ENABLE_MY_MODE&quot;)
end
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用模式变量</h3>
<p>我们也可以直接在配置值中传递模式变量<code>$(mode)</code>，比如根据不同模式选择链接不同的库：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_links(&quot;xxx_$(mode)&quot;)
</code></pre>
<p>上面的配置，如果是调试模式编译就会选择链接：<code>libxxx_debug.a</code>库，而release下就会链接<code>libxxx_release.a</code>，当然，我们也可以设置到库搜索路径中，根据目录来选择对应的库。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_linkdirs(&quot;lib/$(mode)&quot;)
    add_links(&quot;xxx&quot;)
</code></pre>
<p>另外，我们可以通过<code>get_config(&quot;mode&quot;)</code>直接获取到传入的模式配置值，并且这几种获取方式，在自定义脚本也是同样有效的哦，例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_load(function (target)
        if is_mode(&quot;release&quot;) then
            print(get_config(&quot;mode&quot;), &quot;$(mode)&quot;)
        end
    end)
</code></pre>
<h2><a id="%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交叉编译详解</h2>
<h3><a id="%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交叉编译工具链简介</h3>
<p>通常，如果我们需要在当前pc环境编译生成其他设备上才能运行的目标文件时候，就需要通过对应的交叉编译工具链来编译生成它们，比如在win/macos上编译linux的程序，或者在linux上编译其他嵌入式设备的目标文件等。</p>
<p>通常的交叉编译工具链都是基于gcc/clang的，大都具有类似如下的结构：</p>
<pre><code class="language-plain_text">/home/toolchains_sdkdir
   - bin
       - arm-linux-armeabi-gcc
       - arm-linux-armeabi-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
</code></pre>
<p>每个工具链都有对应的include/lib目录，用于放置一些系统库和头文件，例如libc, stdc++等，而bin目录下放置的就是编译工具链一系列工具。例如：</p>
<pre><code class="language-plain_text">arm-linux-armeabi-ar
arm-linux-armeabi-as
arm-linux-armeabi-c++
arm-linux-armeabi-cpp
arm-linux-armeabi-g++
arm-linux-armeabi-gcc
arm-linux-armeabi-ld
arm-linux-armeabi-nm
arm-linux-armeabi-strip
</code></pre>
<p>其中<code>arm-linux-armeabi-</code>前缀就是cross，通过用来标示目标平台和架构，主要用于跟主机自身的gcc/clang进行区分。</p>
<p>里面的gcc/g++就是c/c++的编译器，通常也可以作为链接器使用，链接的时候内部会去调用ld来链接，并且自动追加一些c++库。</p>
<p><strong>cpp</strong>是预处理器，<strong>as</strong>是汇编器，<strong>ar</strong>用于生成静态库，<strong>strip</strong>用于裁剪掉一些符号信息，使得目标程序会更加的小。<strong>nm</strong>用于查看导出符号列表。</p>
<h3><a id="%E8%87%AA%E5%8A%A8%E6%8E%A2%E6%B5%8B%E5%92%8C%E7%BC%96%E8%AF%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动探测和编译</h3>
<p>如果我们的交叉编译工具链是上文的结构，xmake会自动检测识别这个sdk的结构，提取里面的cross，以及include/lib路径位置，用户通常不需要做额外的参数设置，只需要配置好sdk根目录就可以编译了，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p cross --sdk=/home/toolchains_sdkdir
$ xmake
</code></pre>
<p>其中，<code>-p cross</code>用于指定当前的平台是交叉编译平台，<code>--sdk=</code>用于指定交叉工具链的根目录。</p>
<p>注：我们也可以指定<code>-p linux</code>平台来配置交叉编译，效果是一样的，唯一的区别是额外标识了linux平台名，方便xmake.lua里面通过<code>is_plat(&quot;linux&quot;)</code>来判断平台。</p>
<p>这个时候，xmake会去自动探测gcc等编译器的前缀名<code>cross：arm-linux-armeabi-</code>，并且编译的时候，也会自动加上链接库和头文件的搜索选项，例如：</p>
<pre><code class="language-plain_text">-I/home/toolchains_sdkdir/include 
-L/home/toolchains_sdkdir/lib
</code></pre>
<p>这些都是xmake自动处理的，不需要手动配置他们。</p>
<h3><a id="%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动配置编译</h3>
<p>如果上面的自动检测对某些工具链，还无法完全通过编译，就需要用户自己手动设置一些交叉编译相关的配置参数，来调整适应这些特殊的工具链了，下面我会逐一讲解如何配置。</p>
<h4><a id="%E8%AE%BE%E7%BD%AE%E5%B7%A5%E5%85%B7%E9%93%BEbin%E7%9B%AE%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置工具链bin目录</h4>
<p>对于不规则工具链目录结构，靠单纯地<code>--sdk</code>选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的bin目录位置。</p>
<p>例如：一些特殊的交叉工具链的，编译器bin目录，并不在  <code>/home/toolchains_sdkdir/bin</code>  这个位置，而是独立到了  <code>/usr/opt/bin</code></p>
<p>这个时候，我们可以在设置了sdk参数的基础上追加bin目录的参数设置，来调整工具链的bin目录。</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/home/toolchains_sdkdir --bin=/usr/opt/bin
$ xmake
</code></pre>
<h4><a id="%E8%AE%BE%E7%BD%AE%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE%E5%B7%A5%E5%85%B7%E5%89%8D%E7%BC%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置交叉工具链工具前缀</h4>
<p>像aarch64-linux-android-这种，通常如果你配置了--sdk或者--bin的情况下，xmake会去自动检测的，不需要自己手动设置。</p>
<p>但是对于一些极特殊的工具链，一个目录下同时有多个cross前缀的工具bin混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个bin。</p>
<p>例如，toolchains的bin目录下同时存在两个不同的编译器：</p>
<pre><code class="language-plain_text">/opt/bin
  - armv7-linux-gcc 
  - aarch64-linux-gcc
</code></pre>
<p>我们现在想要选用armv7的版本，那么我们可以追加<code>--cross=</code>配置编译工具前缀名，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/usr/toolsdk --bin=/opt/bin --cross=armv7-linux-
</code></pre>
<h4><a id="%E8%AE%BE%E7%BD%AEcc%E7%BC%96%E8%AF%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置c/c++编译器</h4>
<p>如果还要继续细分选择编译器，则继续追加相关编译器选项，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/user/toolsdk --cc=armv7-linux-clang --cxx=armv7-linux-clang++
</code></pre>
<p>当然，我们也可以指定编译器全路径。</p>
<p><code>--cc</code>用于指定c编译器名，<code>--cxx</code>用于指定c++编译器名。</p>
<p>注：如果存在CC/CXX环境变量的话，会优先使用当前环境变量中指定的值。</p>
<p>如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么编译器工具检测就会失败。</p>
<p>这个时候我们可以通过：</p>
<pre><code class="language-plain_text">xmake f --cxx=clang++@/home/xxx/c++mips.exe
</code></pre>
<p>复制代码设置c++mips.exe编译器作为类clang++的使用方式来编译。</p>
<p>也就是说，在指定编译器为c++mips.exe的同时，告诉xmake，它跟clang++用法和参数选项基本相同。</p>
<h4><a id="%E8%AE%BE%E7%BD%AEcc%E8%BF%9E%E6%8E%A5%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置c/c++连接器</h4>
<p>如果还要继续细分选择链接器，则继续追加相关链接器选项，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/user/toolsdk --ld=armv7-linux-clang++ --sh=armv7-linux-clang++ --ar=armv7-linux-ar
</code></pre>
<p><strong>ld</strong>指定可执行程序链接器，<strong>sh</strong>指定共享库程序链接器，<strong>ar</strong>指定生成静态库的归档器。<br />
注：如果存在LD/SH/AR环境变量的话，会优先使用当前环境变量中指定的值。</p>
<h4><a id="%E8%AE%BE%E7%BD%AE%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%BA%93%E6%90%9C%E7%B4%A2%E7%9B%AE%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置头文件和库搜索目录</h4>
<p>如果sdk里面还有额外的其他include/lib目录不在标准的结构中，导致交叉编译找不到库和头文件，那么我们可以通过<code>--includedirs</code>和<code>--linkdirs</code>来追加搜索路径，然后通过<code>--links</code>添加额外的链接库。</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/usr/toolsdk --includedirs=/usr/toolsdk/xxx/include --linkdirs=/usr/toolsdk/xxx/lib --links=pthread
</code></pre>
<blockquote>
<p>注：如果要指定多个搜索目录，可以通过<code>:</code>或者<code>;</code>来分割，也就是不同主机平台的路径分隔符，linux/macos下用:，win下用;。</p>
</blockquote>
<h4><a id="%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置编译和链接选项</h4>
<p>我们也可以根据实际情况通过<code>--cflags</code>, <code>--cxxflags</code>，<code>--ldflags</code>，<code>--shflags</code>和 <code>--arflags</code>额外配置一些编译和链接选项。</p>
<ul>
<li>cflags: 指定c编译参数</li>
<li>cxxflags：指定c++编译参数</li>
<li>cxflags: 指定c/c++编译参数</li>
<li>asflags: 指定汇编器编译参数</li>
<li>ldflags: 指定可执行程序链接参数</li>
<li>shflags: 指定动态库程序链接参数</li>
<li>arflags: 指定静态库的生成参数</li>
</ul>
<p>例如：</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/usr/toolsdk --cflags=&quot;-DTEST -I/xxx/xxx&quot; --ldflags=&quot;-lpthread&quot;
</code></pre>
<h3><a id="mingw%E5%B7%A5%E5%85%B7%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mingw工具链</h3>
<p>使用mingw工具链编译，其实也是交叉编译，但是由于这个比较常用，xmake专门增加了一个mingw的平台来快速处理使用mingw工具链的编译。</p>
<p>因此，xmake对mingw的工具链检测会更加完善，在macos下，基本上连sdk路径都不需要配置，也能直接检测到，只需要切到mingw平台编译即可。</p>
<pre><code class="language-plain_text">$ xmake f -p mingw
$ xmake -v
configure
{
    ld = /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++
    ndk_stdcxx = true
    plat = mingw
    mingw = /usr/local/opt/mingw-w64
    buildir = build
    arch = x86_64
    xcode = /Applications/Xcode.app
    mode = release
    cxx = /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc
    cross = x86_64-w64-mingw32-
    theme = default
    kind = static
    ccache = true
    host = macosx
    clean = true
    bin = /usr/local/opt/mingw-w64/bin
}
[  0%]: ccache compiling.release src/main.cpp
/usr/local/bin/ccache /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc -c -fvisibility=hidden -O3 -m64 -o build/.objs/test/mingw/x86_64/release/src/main.cpp.obj src/main.cpp
[100%]: linking.release test.exe
/usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++ -o build/mingw/x86_64/release/test.exe build/.objs/test/mingw/x86_64/release/src/main.cpp.obj -s -fvisibility=hidden -m64
build ok!
</code></pre>
<p>这里我们追加了<code>-v</code>参数，看了下详细的编译命令和检测到的mingw工具链配置值，其中cross被自动检测为：<code>x86_64-w64-mingw32-</code>，bin目录也被自动检测到了，还有编译器和链接器也是。</p>
<p>尽管在linux/win上还没法自动检测到sdk路径，我们也可以手动指定sdk路径，需要注意的是，xmake为mingw专门提供了一个<code>--mingw=</code>参数用来指定mingw的工具链根目录，其效果跟<code>--sdk=</code>是一样的，但是它可以作为全局配置被设置。</p>
<pre><code class="language-plain_text">$ xmake g --mingw=/home/mingwsdk
$ xmake f -p mingw
$ xmake
</code></pre>
<p>我们通过<code>xmake g/global</code>命令设置<code>--mingw</code>根目录到全局配置后，之后每次编译和切换编译平台，就不用额外指定mingw工具链路径了，方便使用。<br />
另外，其他的工具链配置参数用法，跟上文描述的没什么区别，像<code>--cross</code>, <code>--bin=</code>等都可以根据实际的环境需要，自己控制是否需要额外追加配置来适配自己的mingw工具链。</p>
<h3><a id="%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目描述设置</h3>
<h4><a id="set-toolchain" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>set_toolchain</h4>
<p>如果觉得每次通过命令行配置比较繁琐，有些配置可以通过在xmake.lua预先配置好，来简化命令配置，比如编译器的指定，就可以通过<code>set_toolchain</code>来对每个target单独设置。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    set_toolchain(&quot;cxx&quot;, &quot;clang&quot;)
    set_toolchain(&quot;ld&quot;, &quot;clang++&quot;)
</code></pre>
<p>强制test目标的编译器和链接器使用clang编译器，或者指定交叉编译工具链中的编译器名或者路径。</p>
<h4><a id="set-config" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>set_config</h4>
<p>我们也可以通过<code>set_config</code>来设置在<code>xmake f/config</code>命令中的每个配置参数的默认值，这是个全局api，对每个target都会生效。</p>
<pre><code class="language-plain_text">set_config(&quot;cflags&quot;, &quot;-DTEST&quot;)
set_config(&quot;sdk&quot;, &quot;/home/xxx/tooksdk&quot;)
set_config(&quot;cc&quot;, &quot;gcc&quot;)
set_config(&quot;ld&quot;, &quot;g++&quot;)
</code></pre>
<p>不过，我们还是可以通过<code>xmake f --name=value</code>的方式，去修改xmake.lua中的默认配置。</p>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编译平台</h3>
<p>如果某个交叉工具链编译后目标程序有对应的平台需要指定，并且需要在xmake.lua里面根据不同的交叉编译平台，还需要配置一些额外的编译参数，那么上文的<code>-p cross</code>设置就不能满足需求了。</p>
<p>其实，<code>-p/--plat=</code>参数也可以设置为其他自定义的值，只需要跟<code>is_plat</code>保持对应关系就可以，所有非内置平台名，都会默认采用交叉编译模式，例如：</p>
<pre><code class="language-plain_text">$ xmake f -p myplat --sdk=/usr/local/arm-xxx-gcc/
$ xmake
</code></pre>
<p>我们传入了myplat自定义平台名，作为当前交叉工具链的编译平台，然后xmake.lua里面我们对这个平台，配置下对应的设置：</p>
<pre><code class="language-plain_text">if is_plat(&quot;myplat&quot;) then
    add_defines(&quot;TEST&quot;)
end
</code></pre>
<p>通过这种方式，xmake就可以很方便的扩展处理各种编译平台，用户可以自己扩展支持freebsd, netbsd, sunos等其他各种平台的交叉编译。</p>
<p>我摘录一段之前移植libuv写的交叉编译的配置，直观感受下：</p>
<pre><code class="language-plain_text">-- for gragonfly/freebsd/netbsd/openbsd platform
if is_plat(&quot;gragonfly&quot;, &quot;freebsd&quot;, &quot;netbsd&quot;, &quot;openbsd&quot;) then
    add_files(&quot;src/unix/bsd-ifaddrs.c&quot;)
    add_files(&quot;src/unix/freebsd.c&quot;)
    add_files(&quot;src/unix/kqueue.c&quot;)
    add_files(&quot;src/unix/posix-hrtime.c&quot;)
    add_headerfiles(&quot;(include/uv-bsd.h)&quot;)
end 

-- for sunos platform
if is_plat(&quot;sunos&quot;) then
     add_files(&quot;src/unix/no-proctitle.c&quot;)
    add_files(&quot;src/unix/sunos.c&quot;)
    add_defines(&quot;__EXTENSIONS_&quot;, &quot;_XOPEN_SOURCE=600&quot;)
    add_headerfiles(&quot;(include/uv-sunos.h)&quot;)
end
</code></pre>
<p>然后，我们就可以切换这些平台来编译：</p>
<pre><code class="language-plain_text">$ xmake f -p [gragonfly|freebsd|netbsd|openbsd|sunos] --sdk=/home/arm-xxx-gcc/
$ xmake
</code></pre>
<p>另外，内置的linux平台也是支持交叉编译的哦，如果不想配置其他平台名，统一作为linux平台来交叉编译，也是可以的。</p>
<pre><code class="language-plain_text">$ xmake f -p linux --sdk=/usr/local/arm-xxx-gcc/
$ xmake
</code></pre>
<p>只要设置了<code>--sdk=</code>等参数，就会启用linux平台的交叉编译模式。</p>
<h2><a id="%E5%A4%9A%E4%B8%AA%E5%AD%90%E5%B7%A5%E7%A8%8B%E7%9B%AE%E6%A0%87%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多个子工程目标的依赖配置</h2>
<h3><a id="target%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target到底是什么？</h3>
<p>xmake的概念定义里，一个独立的项目工程可能会有多个子工程组织在一起，每个子工程对应只能生成一个唯一的目标文件，例如：可执行程序，静态库或者动态库等。</p>
<p>而这里所说的每个子工程就是xmake里面所说的target，字面意思就是目标子工程。</p>
<p>因此每个子工程，我们都可以通过新增一个target在xmake.lua里面维护，例如：</p>
<pre><code class="language-plain_text">target(&quot;test1&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/test1/*.c&quot;)
    
target(&quot;test2&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/test2/*.c&quot;)    
</code></pre>
<p>上面我们就定义了两个独立的子工程目标，编译时候会生成两个互不依赖的可执行文件。</p>
<h3><a id="%E4%BB%8E%E6%A0%B9%E5%9F%9F%E7%BB%A7%E6%89%BF%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从根域继承全局设置</h3>
<p>暂时先不谈target间的依赖问题，如果我们有许多通用设置，每个target下都得设置一遍，那会非常冗余，也不好维护。</p>
<p>因此，我们可以把这些配置移到target域的外面，也就是根作用域中去设置，这样对当前xmake.lua以及所有子xmake.lua中的target都会生效，例如：</p>
<pre><code class="language-plain_text">add_links(&quot;tbox&quot;)
add_linkdirs(&quot;lib&quot;)
add_includedirs(&quot;include&quot;)

target(&quot;test1&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/test1/*.c&quot;)
    
target(&quot;test2&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/test2/*.c&quot;)    
</code></pre>
<p>比如这两target都需要链接tbox库，放置在外层根域设置，test1和test2都能加上对应links。</p>
<h3><a id="%E7%9B%AE%E6%A0%87%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>目标间的依赖设置</h3>
<p>那如果某个target需要用到另外一个tatget生成的静态库，应该怎么配置呢？</p>
<p>一种方式就是通过<code>add_linkdirs</code>和<code>add_links</code>手动指定对应target最后生成的目录库所在目录，然后把链接加上。</p>
<pre><code class="language-plain_text">target(&quot;foo&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;foo/*.c&quot;)
    add_defines(&quot;FOO&quot;)

target(&quot;test1&quot;)
    set_kind(&quot;binary&quot;)
    add_includedirs(&quot;foo/inc&quot;)
    add_links(&quot;foo&quot;)
    add_linkdirs(&quot;$(buildir)&quot;)
    add_files(&quot;test1/*.c&quot;)
    add_defines(&quot;FOO&quot;)
    
target(&quot;test2&quot;)
    set_kind(&quot;binary&quot;)
    add_includedirs(&quot;foo/inc&quot;)
    add_links(&quot;foo&quot;)
    add_linkdirs(&quot;$(buildir)&quot;)
    add_files(&quot;test2/*.c&quot;)
    add_defines(&quot;FOO&quot;)
</code></pre>
<p>上述配置中，test1和test2都会用到libfoo库，并且需要获取到libfoo库的头文件路径，库路径和链接，并且在使用过程中还需要额外设置-DFOO宏定义开关才行。</p>
<p>看上去没啥，其实这么写有两个问题：</p>
<p>test目标和另外两个库目标之间是有编译顺序依赖的，如果test先编译就会提示链接库找不到<br />
配置太过繁琐不好维护，test1和test2有很多冗余配置</p>
<p>那有没有更加简单可靠的配置方式呢，其实我们只需要add_deps来对target间配置上依赖关系即可。</p>
<pre><code class="language-plain_text">target(&quot;foo&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;*.c&quot;)
    add_defines(&quot;FOO&quot;, {public = true})
    add_includedirs(&quot;foo/inc&quot;, {public = true})

target(&quot;test1&quot;)
    set_kind(&quot;binary&quot;)
    add_deps(&quot;foo&quot;)
    add_files(&quot;test1/*.c&quot;)
    
target(&quot;test2&quot;)
    set_kind(&quot;binary&quot;)
    add_deps(&quot;foo&quot;)
    add_files(&quot;test2/*.c&quot;)
</code></pre>
<p>对比下，test1和test2的配置，是不是精简了好多？仅仅通过add_deps(&quot;foo&quot;)就继承了libfoo的所有导出设置：<code>linkdirs</code>, <code>links</code>, <code>includedirs</code>以及<code>defines</code></p>
<p>其中target自身生成的库默认就会自动导出链接设置，而<code>includedirs</code>和<code>defines</code>通过设置public属性，我们也将它们标记为导出，这样可以被test目标继承到。</p>
<p>并且，现在有了依赖关系，xmake在编译的时候，会自动处理这些target之间的编译顺序，保证不会出现链接的时候，libfoo库还没有生成的问题。</p>
<h3><a id="%E4%BE%9D%E8%B5%96%E7%BB%A7%E6%89%BF%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>依赖继承的进一步解析</h3>
<h4><a id="%E7%BA%A7%E8%81%94%E4%BE%9D%E8%B5%96%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>级联依赖继承</h4>
<p>根据上文所说，target会自动继承依赖目标中的配置和属性，不需要额外调用<code>add_links</code>, <code>add_linkdirs</code>和<code>add_rpathdirs</code>等接口去关联依赖目标了。</p>
<p>并且继承关系是支持级联的，例如：</p>
<pre><code class="language-plain_text">target(&quot;library1&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;*.c&quot;)
    add_includedirs(&quot;inc&quot;) -- 默认私有头文件目录不会被继承
    add_includedirs(&quot;inc1&quot;, {public = true}) -- 此处的头文件相关目录也会被继承

target(&quot;library2&quot;)
    set_kind(&quot;static&quot;)
    add_deps(&quot;library1&quot;)
    add_files(&quot;*.c&quot;)

target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_deps(&quot;library2&quot;)
</code></pre>
<p>上面的配置中，<code>test</code>依赖<code>library2</code>，然后<code>library2</code>又依赖<code>library1</code>，那么通过<code>add_deps</code>仅仅添加<code>library2</code>的依赖，test就可以完整继承整个依赖链上的所有导出设置。</p>
<h4><a id="%E7%A6%81%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A1%8C%E4%B8%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>禁用默认的继承行为</h4>
<p>那如果我们不想继承依赖target的任何配置，如何操作呢？</p>
<pre><code class="language-plain_text">add_deps(&quot;dep1&quot;, &quot;dep2&quot;, {inherit = false})
</code></pre>
<p>通过显式设置inherit配置，来告诉xmake，这两个依赖的配置是否需要被继承，如果不设置，默认就是启用继承的。</p>
<h4><a id="%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AF%BC%E5%87%BA%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可继承的导出属性详解</h4>
<p>通过 <code>add_includedirs(&quot;inc1&quot;, {public = true})</code>, 设置public为true, 将includedirs的设置公开给其他依赖的子target继承。</p>
<p>目前对于target的编译链接flags相关接口设置，都是支持继承属性的，可以人为控制是否需要导出给其他target来依赖继承，目前支持的属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>默认设置，作为当前target的私有配置，不会被依赖的其他target所继承</td>
</tr>
<tr>
<td>public</td>
<td>公有配置，当前target，依赖的子target都会被设置</td>
</tr>
<tr>
<td>interface</td>
<td>接口设置，仅被依赖的子target所继承设置，当前target不参与</td>
</tr>
</tbody>
</table>
<p>这个其实参考借鉴了cmake的设计，目前xmake中只要跟target相关的所有编译链接设置接口，都是支持可见性导出的，例如：<code>add_includedirs</code>, <code>add_defines</code>, <code>add_cflags</code>等等。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E5%B7%A5%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何组织构建大型工程</h2>
<h3><a id="%E7%BB%B4%E6%8A%A4%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>维护简单的项目结构</h3>
<p>对于一些轻量型的小工程，通常只需要单个xmake.lua文件就能搞定，大体结构如下：</p>
<pre><code class="language-plain_text">projectdir
  - xmake.lua
  - src
    - test
      - *.c
    - demo
      - *.c
</code></pre>
<p>源码下面层级简单，通常只需要在项目根目录维护一个xmake.lua来定义所有target就能完成构建，看上去并不是很复杂，也很清晰。</p>
<pre><code class="language-plain_text">-- 在根域设置通用配置，当前所有targets都会生效
add_defines(&quot;COMMON&quot;)

target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;src/test/*.c&quot;)
    add_defines(&quot;TEST&quot;)

target(&quot;demo&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;src/demo/*.c&quot;)
    add_defines(&quot;DEMO&quot;)
</code></pre>
<h3><a id="%E7%BB%B4%E6%8A%A4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>维护复杂的项目结构</h3>
<p>但是对于一些大型项目，通常的组织结构层次很多也很深，需要编译的target目标也可能有十几甚至上百个，这个时候如果还是都在根<code>xmake.lua</code>文件中维护，就有点吃不消了。</p>
<p>这个时候，我们就需要通过在每个子工程模块里面，单独创建xmake.lua来维护他们，然后使用xmake提供的includes接口，将他们按层级关系包含进来，最终变成一个树状结构：</p>
<pre><code class="language-plain_text">projectdir
  - xmake.lua
  - src
    - test
      - xmake.lua
      - test1
        - xmake.lua
      - test2
        - xmake.lua
      - test3
        - xmake.lua
    - demo
      - xmake.lua
      - demo1
        - xmake.lua
      - demo2
        - xmake.lua
    ...
</code></pre>
<p>然后，根xmake.lua会将所有子工程的xmake.lua通过层级includes全部引用进来，那么所有定义在子工程的target配置也会完全引用进来，我们在编译的时候永远不需要单独去切到某个子工程目录下操作，只需要：</p>
<pre><code class="language-plain_text">$ xmake build test1
$ xmake run test3
$ xmake install demo1
</code></pre>
<p>就可以编译，运行，打包以及安装指定的子工程target，所以除非特殊情况，平常不推荐来回切换目录到子工程下单独编译，非常的繁琐。</p>
<h3><a id="%E6%A0%B9xmake-lua%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>根xmake.lua文件配置</h3>
<p>通常推荐的做法就是在根xmake.lua中仅仅配置一些对所有target都通用的设置，以及includes对子工程的引用，不放置对targets的定义，例如：</p>
<pre><code class="language-plain_text">-- define project
set_project(&quot;tbox&quot;)
set_xmakever(&quot;2.3.2&quot;)
set_version(&quot;1.6.5&quot;, {build = &quot;%Y%m%d%H%M&quot;})

-- set common flags
set_warnings(&quot;all&quot;, &quot;error&quot;)
set_languages(&quot;c99&quot;)
add_cxflags(&quot;-Wno-error=deprecated-declarations&quot;, &quot;-fno-strict-aliasing&quot;, &quot;-Wno-error=expansion-to-defined&quot;)
add_mxflags(&quot;-Wno-error=deprecated-declarations&quot;, &quot;-fno-strict-aliasing&quot;, &quot;-Wno-error=expansion-to-defined&quot;)

-- add build modes
add_rules(&quot;mode.release&quot;, &quot;mode.debug&quot;)

-- includes sub-projects
includes(&quot;test&quot;, &quot;demo&quot;)
</code></pre>
<p>xmake里面所有的设置都是按tree状继承的，根xmake.lua中的root域设置会对所有includes的子xmake.lua里面的targets生效，</p>
<p>但反过来不会，子xmake.lua里面的root域设置仅对它下面的子xmake.lua生效，不会影响到父xmake.lua中定义的targets。</p>
<h3><a id="%E5%AD%90xmake-lua%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>子xmake.lua文件配置</h3>
<p>所以，我们可以在每个子工程目录中，单独配置xmake.lua，里面的所有配置不会干扰父xmake.lua，只对它下面的更细粒度的子工程生效，就这样一层层按tree状生效下去。</p>
<p>由于，已经在根xmake.lua配置了大部分通用配置，那么我们可以在test子工程下，专心配置只对test有用的设置，例如对于<code>projectdir/test/xmake.lua</code>：</p>
<pre><code class="language-plain_text">add_defines(&quot;TEST&quot;)

target(&quot;test1&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test1/*.c&quot;)
    add_defines(&quot;TEST1&quot;)

target(&quot;test2&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test2/*.c&quot;)
    add_defines(&quot;TEST2&quot;)
</code></pre>
<p>我们可以在这里定义test的所有target，当然也可以继续分层，在每个test1, test2目录下单独维护xmake.lua，这个看自己项目的规模来决定。</p>
<p>比如：</p>
<pre><code class="language-plain_text">add_defines(&quot;TEST&quot;)
includes(&quot;test1&quot;, &quot;test2&quot;)
</code></pre>
<p>test1/xmake.lua</p>
<pre><code class="language-plain_text">target(&quot;test1&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test1/*.c&quot;)
    add_defines(&quot;TEST1&quot;)
</code></pre>
<p>test2/xmake.lua</p>
<pre><code class="language-plain_text">target(&quot;test2&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test2/*.c&quot;)
    add_defines(&quot;TEST2&quot;)
</code></pre>
<p>而这里面的<code>add_defines(&quot;TEST&quot;)</code>在root域，会对test1/test2两个target都生效，但是对于demo目录的target不生效，因为它们是平级的，没有tree状继承关系。</p>
<h3><a id="%E8%B7%A8xmake-lua%E9%97%B4%E7%9B%AE%E6%A0%87%E4%BE%9D%E8%B5%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>跨xmake.lua间目标依赖</h3>
<p>虽然，<code>projectdir/test/xmake.lua</code>和<code>projectdir/demo/xmake.lua</code>两个子工程目录是平级关系，配置无法相互干扰，但是targets是可以跨xmake.lua访问的，来实现目标间的依赖。</p>
<p>比如demo需要依赖test静态库，进行链接使用，那么demo下xmake.lua可以这么写：</p>
<pre><code class="language-plain_text">target(&quot;demo1&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;demo1/*.c&quot;)
    add_deps(&quot;test1&quot;)
</code></pre>
<p>只要通过<code>add_deps(&quot;test1&quot;)</code>关联上对应其他子工程目标作为依赖即可，test1静态库会优先编译，并且demo可执行程序会自动link上它生成的libtest1.a库。</p>
<h3><a id="%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件路径的层级关系</h3>
<p>我们需要记住，所有跟路径相关的配置接口，比如<code>add_files</code>, <code>add_includedirs</code>等都是相对于当前子工程xmake.lua所在的目录的，所以只要添加的文件不跨模块，那么设置起来只需要考虑当前的相对路径就行了。</p>
<pre><code class="language-plain_text">projectdir
  - test
    - xmake.lua
    - test1/*.c
    - test2/*.c
</code></pre>
<p>比如，这里添加的源文件路径，都是相对于test子工程目录的，我们不需要去设置绝对路径，这样会简化很多。</p>
<pre><code class="language-plain_text">target(&quot;test1&quot;)
    add_files(&quot;test1/*.c&quot;)
target(&quot;test2&quot;)
    add_files(&quot;test2/*.c&quot;)
</code></pre>
<p>当然，如果我们有特殊需求，非要设置工程其他子模块下的文件路径呢？两种办法，通过<code>../../</code>的方式一层层绕出去，另外一种就是使用<code>$(projectdir)</code>内置变量，它表示项目全局根目录。</p>
<p>比如在demo子工程下：</p>
<pre><code class="language-plain_text">target(&quot;demo1&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;demo1/*.c&quot;)
    add_files(&quot;../../test/test1/*.c&quot;)
</code></pre>
<p>或者：</p>
<pre><code class="language-plain_text">target(&quot;demo1&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;demo1/*.c&quot;)
    add_files(&quot;$(projectdir)/test/test1/*.c&quot;)
</code></pre>
<h3><a id="includes%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>includes接口使用进阶</h3>
<h4><a id="%E9%94%99%E8%AF%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错误的使用方式</h4>
<p>includes这个接口属于全局接口，不隶属于任何target，所以请不要在target内部调用，下面是错误的用法：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    includes(&quot;test1&quot;, &quot;test2&quot;)
    add_files(&quot;test/*.c&quot;)
</code></pre>
<p>正确的用法是：</p>
<pre><code class="language-plain_text">includes(&quot;test1&quot;, &quot;test2&quot;)
target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test/*.c&quot;)
</code></pre>
<p>或者：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;static&quot;)
    add_files(&quot;test/*.c&quot;)
target_end()

-- 在下面调用，需要先显式退出target作用域
includes(&quot;test1&quot;, &quot;test2&quot;)
</code></pre>
<h4><a id="%E5%BC%95%E7%94%A8%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用目录或文件</h4>
<p>另外，includes既可以引用目录，也可以直接引用文件，如果test1目录下存在xmake.lua，那么可以直接<code>includes(&quot;test1&quot;)</code>来引用目录。</p>
<p>如果test1目录下是其他xxxx.lua命令的项目文件，可以通过指定文件来引用：<code>includes(&quot;test1/xxxx.lua&quot;)</code>，效果一样的。</p>
<h4><a id="%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%BF%9B%E8%A1%8C%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式匹配进行批量导入</h4>
<p>includes还支持通过模式匹配的方式来批量导入多个子工程，比如：</p>
<pre><code class="language-plain_text">includes(&quot;test/*/xmake.lua&quot;)
</code></pre>
<p>可以导入test目录下，所有test1, test2等子工程目录下的配置，如果是**还支持递归多级匹配</p>
<pre><code class="language-plain_text">includes(&quot;test/**/xmake.lua&quot;)
</code></pre>
<p>通过模式匹配，我们只需要在test/xmake.lua一处地方进行includes，以后用户在新增其他子工程xmake.lua，就会自动导入进来，非常方便。</p>
<h4><a id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意事项</h4>
<p>另外，在使用includes的过程中，需要注意的一点是，它不是c语言的<code>#include</code>，因此在当前配置中includes子配置，当前配置是不会有任何影响的，比如：</p>
<pre><code class="language-plain_text">includes(&quot;xxx&quot;)

target(&quot;test&quot;)
  -- ...
</code></pre>
<p>上面includes了一些子工程，但是这些子工程的配置是不会干扰当前test目标程序的。</p>
<h2><a id="%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%9C%B0%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过自定义脚本实现更灵活地配置</h2>
<h3><a id="%E9%85%8D%E7%BD%AE%E5%88%86%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置分离</h3>
<p>xmake.lua采用二八原则实现了描述域、脚本域两层分离式配置。</p>
<p>什么是二八原则呢，简单来说，大部分项目的配置，80%的情况下，都是些基础的常规配置，比如：<code>add_cxflags</code>, <code>add_links</code>等，只有剩下不到20%的地方才需要额外做些复杂来满足一些特殊的配置需求。</p>
<p>而这剩余的20%的配置通常比较复杂，如果直接充斥在整个xmake.lua里面，会把整个项目的配置整个很混乱，非常不可读。</p>
<p>因此，xmake通过描述域、脚本域两种不同的配置方式，来隔离80%的简单配置以及20%的复杂配置，使得整个xmake.lua看起来非常的清晰直观，可读性和可维护性都达到最佳。</p>
<h3><a id="%E6%8F%8F%E8%BF%B0%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>描述域</h3>
<p>对于刚入门的新手用户，或者仅仅是维护一些简单的小项目，通过完全在描述配置就已经完全满足需求了，那什么是描述域呢？它长这样：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;DEBUG&quot;)
    add_syslinks(&quot;pthread&quot;)
</code></pre>
<p>一眼望去，其实就是个 <code>set_xxx</code>/<code>add_xxx</code> 的配置集，对于新手，完全可以不把它当做lua脚本，仅仅作为普通的，但有一些基础规则的配置文件就行了。</p>
<p>这是不是看着更像配置文件了？其实描述域就是配置文件，类似像json等key/values的配置而已，所以即使完全不会lua的新手，也是能很快上手的。</p>
<p>而且，对于通常的项目，仅通过<code>set_xxx</code>/<code>add_xxx</code>去配置各种项目设置，已经完全满足需求了。</p>
<p>这也就是开头说的：80%的情况下，可以用最简单的配置规则去简化项目的配置，提高可读性和可维护性，这样对用户和开发者都会非常的友好，也更加直观。</p>
<p>如果我们要针对不同平台，架构做一些条件判断怎么办？没关系，描述域除了基础配置，也是支持条件判断，以及for循环的：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;DEBUG&quot;)
    if is_plat(&quot;linux&quot;, &quot;macosx&quot;) then
        add_links(&quot;pthread&quot;, &quot;m&quot;, &quot;dl&quot;)
    end
</code></pre>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_defines(&quot;DEBUG&quot;)
    for _, name in ipairs({&quot;pthread&quot;, &quot;m&quot;, &quot;dl&quot;}) do
        add_links(name)
    end
</code></pre>
<p>这是不是看着有点像lua了？虽说，平常可以把它当做普通配置问题，但是xmake毕竟基于lua，所以描述域还是支持lua的基础语言特性的。</p>
<blockquote>
<p>不过需要注意的是，描述域虽然支持lua的脚本语法，但在描述域尽量不要写太复杂的lua脚本，比如一些耗时的函数调用和for循环。</p>
</blockquote>
<p>并且在描述域，主要目的是为了设置配置项，因此xmake并没有完全开放所有的模块接口，很多接口在描述域是被禁止调用的，即使开放出来的一些可调用接口，也是完全只读的，不耗时的安全接口，比如：os.getenv()等读取一些常规的系统信息，用于配置逻辑的控制。</p>
<blockquote>
<p>另外需要注意一点，xmake.lua是会被多次解析的，用于在不同阶段解析不同的配置域：比如：option(), target()等域。<br />
因此，不要想着在xmake.lua的描述域，写复杂的lua脚本，也不要在描述域调用print去显示信息，因为会被执行多遍，记住：会被执行多遍！！！</p>
</blockquote>
<h3><a id="%E8%84%9A%E6%9C%AC%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本域</h3>
<p>限制描述域写复杂的lua，各种lua模块和接口都用不了？怎么办？这个时候就是脚本域出场的时候了。</p>
<p>如果用户已经完全熟悉了xmake的描述域配置，并且感觉有些满足不了项目上的一些特殊配置维护了，那么我们可以在脚本域做更加复杂的配置逻辑：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_load(function (target)
        if is_plat(&quot;linux&quot;, &quot;macosx&quot;) then
            target:add(&quot;links&quot;, &quot;pthread&quot;, &quot;m&quot;, &quot;dl&quot;)
        end
    end)
    after_build(function (target)
        import(&quot;core.project.config&quot;)
        local targetfile = target:targetfile()
        os.cp(targetfile, path.join(config.buildir(), path.filename(targetfile)))
        print(&quot;build %s&quot;, targetfile)
    end)
</code></pre>
<p>只要是类似：<code>on_xxx</code>, <code>after_xxx</code>, <code>before_xxx</code>等字样的function body内部的脚本，都属于脚本域。</p>
<p>在脚本域中，用户可以干任何事，xmake提供了import接口可以导入xmake内置的各种lua模块，也可以导入用户提供的lua脚本。</p>
<p>我们可以在脚本域实现你想实现的任意功能，甚至写个独立项目出来都是可以的。</p>
<p>对于一些脚本片段，不是很臃肿的话，像上面这么内置写写就足够了，如果需要实现更加复杂的脚本，不想充斥在一个xmake.lua里面，可以把脚本分离到独立的lua文件中去维护。</p>
<p>例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_load(&quot;modules.test.load&quot;)
    on_install(&quot;modules.test.install&quot;)
</code></pre>
<p>我们可以吧自定义的脚本放置到<code>xmake.lua</code>对应目录下，<code>modules/test/load.lua</code>和<code>modules/test/install.lua</code>中独立维护。</p>
<p>单独的lua脚本文件以main作为主入口，例如：</p>
<pre><code class="language-plain_text">-- 我们也可以在此处导入一些内置模块或者自己的扩展模块来使用
import(&quot;core.project.config&quot;)
import(&quot;mymodule&quot;)

function main(target)
    if is_plat(&quot;linux&quot;, &quot;macosx&quot;) then
        target:add(&quot;links&quot;, &quot;pthread&quot;, &quot;m&quot;, &quot;dl&quot;)
    end
end
</code></pre>
<p>这些独立的lua脚本里面，我们还可以通过import导入各种内置模块和自定义模块进来使用，就跟平常写lua, java没啥区别。</p>
<p>而对于脚本的域的不同阶段，<code>on_load</code>主要用于target加载时候，做一些动态化的配置，这里不像描述域，只会执行一遍哦!!!</p>
<p>其他阶段，还有很多，比如：<code>on/after/before_build/install/package/run</code>等，我们下面会详细描述。</p>
<h3><a id="import" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>import</h3>
<h4><a id="%E5%AF%BC%E5%85%A5%E6%89%A9%E5%B1%95%E6%91%B8%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导入扩展摸块</h4>
<p>在讲解各个脚本域之前，我们先来简单介绍下xmake的模块导入和使用方式，xmake采用import来引入其他的扩展模块，以及用户自己定义的模块，它可以在下面一些地方使用：</p>
<ul>
<li>自定义脚本(on_build, on_run ..)</li>
<li>插件开发</li>
<li>模板开发</li>
<li>平台扩展</li>
<li>自定义任务task</li>
</ul>
<p>导入机制如下：</p>
<ol>
<li>优先从当前脚本目录下导入</li>
<li>再从扩展类库中导入</li>
</ol>
<p>导入的语法规则：</p>
<p>基于<code>.</code>的类库路径规则，例如：</p>
<pre><code class="language-plain_text">import(&quot;core.base.option&quot;)
import(&quot;core.base.task&quot;)

function main()
    
    -- 获取参数选项
    print(option.get(&quot;version&quot;))

    -- 运行任务和插件
    task.run(&quot;hello&quot;)
end
</code></pre>
<p>导入当前目录下的自定义模块：</p>
<p>目录结构：</p>
<pre><code class="language-plain_text">plugin
  - xmake.lua
  - main.lua
  - modules
    - hello1.lua
    - hello2.lua
</code></pre>
<p>在main.lua中导入modules</p>
<pre><code class="language-plain_text">import(&quot;modules.hello1&quot;)
import(&quot;modules.hello2&quot;)
</code></pre>
<p>导入后就可以直接使用里面的所有公有接口，私有接口用_前缀标示，表明不会被导出，不会被外部调用到。。</p>
<p>除了当前目录，我们还可以导入其他指定目录里面的类库，例如：</p>
<pre><code class="language-plain_text">import(&quot;hello3&quot;, {rootdir = &quot;/home/xxx/modules&quot;})
</code></pre>
<p>为了防止命名冲突，导入后还可以指定的别名：</p>
<pre><code class="language-plain_text">import(&quot;core.platform.platform&quot;, {alias = &quot;p&quot;})

function main()
    -- 这样我们就可以使用p来调用platform模块的plats接口，获取所有xmake支持的平台列表了
    print(p.plats())
end
</code></pre>
<p>2.1.5版本新增两个新属性：<code>import(&quot;xxx.xxx&quot;, {try = true, anonymous = true})</code></p>
<p>try为true，则导入的模块不存在的话，仅仅返回nil，并不会抛异常后中断xmake.<br />
anonymous为true，则导入的模块不会引入当前作用域，仅仅在import接口返回导入的对象引用。</p>
<h3><a id="%E6%B5%8B%E8%AF%95%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试扩展模块</h3>
<p>一种方式我们可以在on_load等脚本中，直接调用print去打印模块的调用结果信息，来测试和验证。</p>
<p>不过xmake还提供了<code>xmake lua</code>插件可以更加灵活方便的测试脚本。</p>
<h4><a id="%E8%BF%90%E8%A1%8C%E6%8C%87%E5%AE%9A%E7%9A%84%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行指定的脚本文件</h4>
<p>比如，我们可以直接指定lua脚本来加载运行，这对于想要快速测试一些接口模块，验证自己的某些思路，都是一个不错的方式。</p>
<p>我们先写个简单的lua脚本：</p>
<pre><code class="language-plain_text">function main()
    print(&quot;hello xmake!&quot;)
end
</code></pre>
<p>然后直接运行它就行了：</p>
<pre><code class="language-plain_text">$ xmake lua /tmp/test.lua
</code></pre>
<h4><a id="%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接调用扩展模块</h4>
<p>所有内置模块和扩展模块的接口，我们都可以通过<code>xmake lua</code>直接调用，例如：</p>
<pre><code class="language-plain_text">$ xmake lua lib.detect.find_tool gcc
</code></pre>
<p>上面的命令，我们直接调用了<code>import(&quot;lib.detect.find_tool&quot;)</code>模块接口来快速执行。</p>
<h4><a id="%E8%BF%90%E8%A1%8C%E4%BA%A4%E4%BA%92%E5%91%BD%E4%BB%A4repl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行交互命令 (REPL)</h4>
<p>有时候在交互模式下，运行命令更加的方便测试和验证一些模块和api，也更加的灵活，不需要再去额外写一个脚本文件来加载。</p>
<p>我们先看下，如何进入交互模式：</p>
<pre><code class="language-plain_text"># 不带任何参数执行，就可以进入
$ xmake lua
&gt;

# 进行表达式计算
&gt; 1 + 2
3

# 赋值和打印变量值
&gt; a = 1
&gt; a
1

# 多行输入和执行
&gt; for _, v in pairs({1, 2, 3}) do
&gt;&gt; print(v)
&gt;&gt; end
1
2
3
</code></pre>
<p>我们也能够通过 <code>import</code> 来导入扩展模块：</p>
<pre><code class="language-plain_text">&gt; task = import(&quot;core.project.task&quot;)
&gt; task.run(&quot;hello&quot;)
hello xmake!
</code></pre>
<p>如果要中途取消多行输入，只需要输入字符：<code>q</code> 就行了</p>
<pre><code class="language-plain_text">&gt; for _, v in ipairs({1, 2}) do
&gt;&gt; print(v)
&gt;&gt; q             &lt;--  取消多行输入，清空先前的输入数据
&gt; 1 + 2
3
</code></pre>
<h3><a id="target-on-load" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_load</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义目标加载脚本</h4>
<p>在target初始化加载的时候，将会执行此脚本，在里面可以做一些动态的目标配置，实现更灵活的目标描述定义，例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    on_load(function (target)
        target:add(&quot;defines&quot;, &quot;DEBUG&quot;, &quot;TEST=\&quot;hello\&quot;&quot;)
        target:add(&quot;linkdirs&quot;, &quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;)
        target:add({includedirs = &quot;/usr/include&quot;, &quot;links&quot; = &quot;pthread&quot;})
    end)
</code></pre>
<p>可以在on_load里面，通过<code>target:set</code>, <code>target:add</code> 来动态添加各种target属性，所有描述域的set_, add_配置都可以通过这种方式动态配置。</p>
<p>另外，我们可以调用target的一些接口，获取和设置一些基础信息，比如：</p>
<table>
<thead>
<tr>
<th>target接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>target:name()</td>
<td>获取目标名</td>
</tr>
<tr>
<td>target:targetfile()</td>
<td>获取目标文件路径</td>
</tr>
<tr>
<td>target:targetkind()</td>
<td>获取目标的构建类型</td>
</tr>
<tr>
<td>target:get(&quot;defines&quot;)</td>
<td>获取目标的宏定义</td>
</tr>
<tr>
<td>target:get(&quot;xxx&quot;)</td>
<td>其他通过 <code>set_</code>/<code>add_</code>接口设置的target信息，都可以通过此接口来获取</td>
</tr>
<tr>
<td>target:add(&quot;links&quot;, &quot;pthread&quot;)</td>
<td>添加目标设置</td>
</tr>
<tr>
<td>target:set(&quot;links&quot;, &quot;pthread&quot;, &quot;z&quot;)</td>
<td>覆写目标设置</td>
</tr>
<tr>
<td>target:deps()</td>
<td>获取目标的所有依赖目标</td>
</tr>
<tr>
<td>target:dep(&quot;depname&quot;)</td>
<td>获取指定的依赖目标</td>
</tr>
<tr>
<td>target:opts()</td>
<td>获取目标的所有关联选项</td>
</tr>
<tr>
<td>target:opt(&quot;optname&quot;)</td>
<td>获取指定的关联选项</td>
</tr>
<tr>
<td>target:pkgs()</td>
<td>获取目标的所有关联依赖包</td>
</tr>
<tr>
<td>target:pkg(&quot;pkgname&quot;)</td>
<td>获取指定的关联依赖包</td>
</tr>
<tr>
<td>target:sourcebatches()</td>
<td>获取目标的所有源文件列表</td>
</tr>
</tbody>
</table>
<h3><a id="target-on-link" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_link</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编译脚本</h4>
<p>覆盖target目标默认的构建行为，实现自定义的编译过程，一般情况下，并不需要这么做，除非确实需要做一些xmake默认没有提供的编译操作。</p>
<p>你可以通过下面的方式覆盖它，来自定义编译操作：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)

    -- 设置自定义编译脚本
    on_build(function (target) 
        print(&quot;build it&quot;)
    end)
</code></pre>
<p>注：2.1.5版本之后，所有target的自定义脚本都可以针对不同平台和架构，分别处理，例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    on_build(&quot;iphoneos|arm*&quot;, function (target)
        print(&quot;build for iphoneos and arm&quot;)
    end)
</code></pre>
<p>其中如果第一个参数为字符串，那么就是指定这个脚本需要在哪个平台|架构下，才会被执行，并且支持模式匹配，例如arm*匹配所有arm架构。</p>
<p>当然也可以只设置平台，不设置架构，这样就是匹配指定平台下，执行脚本：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    on_build(&quot;windows&quot;, function (target)
        print(&quot;build for windows&quot;)
    end)
</code></pre>
<p>注：一旦对这个target目标设置了自己的build过程，那么xmake默认的构建过程将不再被执行。</p>
<h3><a id="target-on-build-file" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_build_file</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8D%95%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编译脚本, 实现单文件构建</h4>
<p>通过此接口，可以用来hook指定target内置的构建过程，自己重新实现每个源文件编译过程：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_build_file(function (target, sourcefile, opt)
    end)
</code></pre>
<h3><a id="target-on-build-files" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_build_files</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编译脚本, 实现多文件构建</h4>
<p>通过此接口，可以用来hook指定target内置的构建过程，替换一批同类型源文件编译过程：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    on_build_files(function (target, sourcebatch, opt)
    end)
</code></pre>
<p>设置此接口后，对应源文件列表中文件，就不会出现在自定义的target.on_build_file了，因为这个是包含关系。</p>
<p>其中sourcebatch描述了这批同类型源文件：</p>
<ul>
<li><code>sourcebatch.sourcekind</code>: 获取这批源文件的类型，比如：cc, as, ..</li>
<li><code>sourcebatch.sourcefiles()</code>: 获取源文件列表</li>
<li><code>sourcebatch.objectfiles()</code>: 获取对象文件列表</li>
<li><code>sourcebatch.dependfiles()</code>: 获取对应依赖文件列表，存有源文件中编译依赖信息，例如：xxx.d</li>
</ul>
<h3><a id="target-on-clean" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_clean</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义清理脚本</h4>
<p>覆盖target目标的<code>xmake [c|clean}</code>的清理操作，实现自定义清理过程。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)

    -- 设置自定义清理脚本
    on_clean(function (target) 

        -- 仅删掉目标文件
        os.rm(target:targetfile())
    end)
</code></pre>
<h3><a id="target-on-package" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_package</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义打包脚本</h4>
<p>覆盖target目标的<code>xmake [p|package}</code>的打包操作，实现自定义打包过程，如果你想对指定target打包成自己想要的格式，可以通过这个接口自定义它。</p>
<pre><code class="language-plain_text">target(&quot;demo&quot;)
    set_kind(&quot;shared&quot;)
    add_files(&quot;jni/*.c&quot;)
    on_package(function (target) 
        os.exec(&quot;./gradlew app:assembleDebug&quot;) 
    end)
</code></pre>
<p>当然这个例子有点老了，这里只是举例说明下用法而已，现在xmake提供了专门的xmake-gradle插件，来与gradle更好的集成。</p>
<h3><a id="target-on-install" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_install</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义安装脚本</h4>
<p>覆盖target目标的<code>xmake [i|install}</code>的安装操作，实现自定义安装过程。</p>
<p>例如，将生成的apk包，进行安装。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)

    -- 设置自定义安装脚本，自动安装apk文件
    on_install(function (target) 

        -- 使用adb安装打包生成的apk文件
        os.run(&quot;adb install -r ./bin/Demo-debug.apk&quot;)
    end)
</code></pre>
<h3><a id="target-on-uninstall" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_uninstall</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义卸载脚本</h4>
<p>覆盖target目标的<code>xmake [u|uninstall}</code>的卸载操作，实现自定义卸载过程。</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    on_uninstall(function (target) 
        ...
    end)
</code></pre>
<h3><a id="target-on-run" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>target:on_run</h3>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义运行脚本</h4>
<p>覆盖target目标的<code>xmake [r|run}</code>的运行操作，实现自定义运行过程。</p>
<p>例如，运行安装好的apk程序：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)

    -- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息
    on_run(function (target) 
        os.run(&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;)
        os.run(&quot;adb logcat&quot;)
    end)
</code></pre>
<h3><a id="before-xxx%E5%92%8Cafter-xxx" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>before_xxx和after_xxx</h3>
<p>需要注意的是，target:on_xxx的所有接口都覆盖内部默认实现，通常我们并不需要完全复写，只是额外挂接自己的一些逻辑，那么可以使用<code>target:before_xxx</code>和<code>target:after_xxx</code>系列脚本就行了。</p>
<p>所有的on_xxx都有对应的before_和after_xx版本，参数也完全一致，例如：</p>
<pre><code class="language-plain_text">target(&quot;test&quot;)
    before_build(function (target)
        print(&quot;&quot;)
    end)
</code></pre>
<h3><a id="%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内置模块</h3>
<p>在自定义脚本中，除了使用import接口导入各种扩展模块使用，xmake还提供了很多基础的内置模块，比如：os，io等基础操作，实现更加跨平台的处理系统接口。</p>
<h4><a id="os-cp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>os.cp</h4>
<p>os.cp的行为和shell中的<code>cp</code>命令类似，不过更加强大，不仅支持模式匹配（使用的是lua模式匹配），而且还确保目的路径递归目录创建、以及支持xmake的内置变量。</p>
<p>例如：</p>
<pre><code class="language-plain_text">os.cp(&quot;$(scriptdir)/*.h&quot;, &quot;$(buildir)/inc&quot;)
os.cp(&quot;$(projectdir)/src/test/**.h&quot;, &quot;$(buildir)/inc&quot;)
</code></pre>
<p>上面的代码将：当前<code>xmake.lua</code>目录下的所有头文件、工程源码test目录下的头文件全部复制到<code>$(buildir)</code>输出目录中。<br />
其中<code>$(scriptdir)</code>, <code>$(projectdir)</code> 这些变量是xmake的内置变量，具体详情见：内置变量的相关文档。<br />
而<code>*.h</code>和<code>**.h</code>中的匹配模式，跟<code>add_files</code>中的类似，前者是单级目录匹配，后者是递归多级目录匹配。<br />
上面的复制，会把所有文件全部展开复制到指定目录，丢失源目录层级，如果要按保持原有的目录结构复制，可以设置rootdir参数：</p>
<pre><code class="language-plain_text">os.cp(&quot;src/**.h&quot;, &quot;/tmp/&quot;, {rootdir = &quot;src&quot;})
</code></pre>
<p>上面的脚本可以按<code>src</code>根目录，将src下的所有子文件保持目录结构复制过去。</p>
<p>注：尽量使用<code>os.cp</code>接口，而不是<code>os.run(&quot;cp ..&quot;)</code>，这样更能保证平台一致性，实现跨平台构建描述。</p>
<h4><a id="os-run" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>os.run</h4>
<p>此接口会安静运行原生shell命令，用于执行第三方的shell命令，但不会回显输出，仅仅在出错后，高亮输出错误信息。</p>
<p>此接口支持参数格式化、内置变量，例如：</p>
<pre><code class="language-plain_text">-- 格式化参数传入
os.run(&quot;echo hello %s!&quot;, &quot;xmake&quot;)

-- 列举构建目录文件
os.run(&quot;ls -l $(buildir)&quot;)
</code></pre>
<h4><a id="os-execv" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>os.execv</h4>
<p>此接口相比os.run，在执行过程中还会回显输出，并且参数是通过列表方式传入，更加的灵活。</p>
<pre><code class="language-plain_text">os.execv(&quot;echo&quot;, {&quot;hello&quot;, &quot;xmake!&quot;})
</code></pre>
<p>另外，此接口还支持一个可选的参数，用于传递设置：重定向输出，执行环境变量设置，例如：</p>
<pre><code class="language-plain_text">os.execv(&quot;echo&quot;, {&quot;hello&quot;, &quot;xmake!&quot;}, {stdout = outfile, stderr = errfile, envs = {PATH = &quot;xxx;xx&quot;, CFLAGS = &quot;xx&quot;, curdir = &quot;/tmp&quot;}}
</code></pre>
<p>其中，stdout和stderr参数用于传递重定向输出和错误输出，可以直接传入文件路径，也可以传入io.open打开的文件对象。</p>
<p>另外，如果想在这次执行中临时设置和改写一些环境变量，可以传递envs参数，里面的环境变量设置会替换已有的设置，但是不影响外层的执行环境，只影响当前命令。</p>
<p>我们也可以通过<code>os.getenvs()</code>接口获取当前所有的环境变量，然后改写部分后传入envs参数。<br />
另外，还能通过curdir参数设置，在执行过程中修改子进程的工作目录。</p>
<p>其相关类似接口还有，<code>os.runv</code>, <code>os.exec</code>, <code>os.execv</code>, <code>os.iorun</code>, <code>os.iorunv</code>等等，比如os.iorun可以获取运行的输出内容。</p>
<p>这块的具体详情和差异，还有更多os接口，都可以到：<a href="https://xmake.io/#/zh-cn/manual/builtin_modules?id=os">os接口文档</a> 查看。</p>
<h3><a id="io-readfile" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>io.readfile</h3>
<p>此接口，从指定路径文件读取所有内容，我们可在不打开文件的情况下，直接读取整个文件的内容，更加的方便，例如：</p>
<pre><code class="language-plain_text">local data = io.readfile(&quot;xxx.txt&quot;)
</code></pre>
<h3><a id="io-writefile" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>io.writefile</h3>
<p>此接口写入所有内容到指定路径文件，我们可在不打开文件的情况下，直接写入整个文件的内容，更加的方便，例如：</p>
<pre><code class="language-plain_text">io.writefile(&quot;xxx.txt&quot;, &quot;all data&quot;)
</code></pre>
<h3><a id="path-join" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>path.join</h3>
<p>此接口实现跨平台地路径拼接操作，将多个路径项进行追加拼接，由于<code>windows/unix</code>风格的路径差异，使用api来追加路径更加跨平台，例如：</p>
<pre><code class="language-plain_text">print(path.join(&quot;$(tmpdir)&quot;, &quot;dir1&quot;, &quot;dir2&quot;, &quot;file.txt&quot;))
</code></pre>
<p>上述拼接在unix上相当于：<code>$(tmpdir)/dir1/dir2/file.txt</code>，而在windows上相当于：<code>$(tmpdir)\\dir1\\dir2\\file.txt</code></p>
<h2><a id="xmake%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xmake 的基本指令</h2>
<p>在介绍 xmake 命令行程序的各种子命令前，我们先介绍下 xmake 的 <strong>help 菜单</strong>，所有 xmake 命令参数都是可以从这个菜单中找到，并且有相应的描述和参数值说明。</p>
<p>因此，在还不熟悉怎么使用某个子命令的时候，都可以通过查看对应的帮助菜单里面的参数说明，来快速找到想要的某个设置参数的使用方式。</p>
<h3><a id="1%E4%B8%BB%E8%8F%9C%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.主菜单</h3>
<p>xmake 的整个命令行格式如下：</p>
<pre><code class="language-plain_text">xmake [task] [options] [target]
</code></pre>
<p>主要由 <code>[task]</code>、<code>[options]</code>、 <code>[target]</code>组成，其中 [] 部分表示可选输入。</p>
<p>里面的 <code>task</code> 就是子命令任务名，xmake 提供了很多的内置子命令以及插件任务子命令，可以通过执行 <code>xmake --help</code> 在主菜单里面查看具体有哪些子命令，整个主菜单的列表内容如下：</p>
<p><img src="media/16835100455777/16835108165732.jpg" alt="" /></p>
<ul>
<li><code>config</code>/<code>f</code>：配置编译需要的参数，比如平台、架构等。</li>
<li><code>global</code>/<code>g</code>：全局配置编译参数。</li>
<li><code>build</code>/<code>b</code>：构建程序。</li>
<li><code>run</code>/<code>r</code>：运行目标程序。</li>
<li><code>install</code>/<code>i</code>：安装编译后的目标程序。</li>
<li><code>uninstall</code>/<code>u</code>：卸载之前安装的程序文件。</li>
<li><code>package</code>/<code>p</code>：打包编译生成的库和头文件。</li>
<li><code>clean</code>/<code>c</code>：清理编译过程中生成的临时文件。</li>
<li><code>require</code>/<code>q</code>：手动拉取第三方依赖库。</li>
<li><code>update</code>：xmake 程序自更新。</li>
</ul>
<h3><a id="2-build%E5%AD%90%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.build 子命令</h3>
<p>build 子命令也就是默认的构建命令，由于这个命令最常用，因此即使用户不完整运行 xmake build，仅仅执行 xmake 就可以编译项目，两者是完全等价的。</p>
<p>如果我们要查看构建命令具体有哪些参数选项，可以执行下面的命令来查看，参数列表如下：</p>
<pre><code class="language-plain_text">xmake build --help
</code></pre>
<p>输出内容如下：</p>
<p><img src="media/16835100455777/16835110026813.jpg" alt="" /></p>
<ul>
<li><code>-v</code>/<code>--verbose</code>：查看详细完整的编译命令。</li>
<li><code>-r</code>/<code>--rebuild</code>：强制重新编译所有代码。</li>
<li><code>-j</code>/<code>--jobs</code>：指定多任务编译的并行任务数。</li>
<li><code>-w</code>/<code>--warning</code>：编译过程中显示编译警告信息。</li>
</ul>
<h3><a id="3%E6%9F%A5%E7%9C%8B%E8%AF%A6%E7%BB%86%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.查看详细编译选项</h3>
<p>通过添加 <code>-v</code> 参数，在编译过程中，查看完整的编译选项，这是非常有用的。</p>
<p>它可以排查和确认设置的编译选项是否生效，我们可以进入之前的 hello 项目中执行下面的命令。</p>
<pre><code class="language-plain_text">xmake -rv
</code></pre>
<p>这里我们还同时追加<code>-r</code>选项，<code>-r</code>和<code>-v</code>可以组合在一起变成<code>-rv</code>同时生效（这是由于 xmake 采用的是 unix 的命令参数风格），也就是重新编译并且显示详细命令输出，具体效果如图：</p>
<p><img src="media/16835100455777/16835110949060.jpg" alt="" /></p>
<h3><a id="4-config%E5%AD%90%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.config 子命令</h3>
<p>config 子命令主要用于在<strong>编译前</strong>，对项目进行一些参数配置，比如切换平台、架构以及编译模式等。</p>
<p>它可用于修改编译过程中的各种行为，当然里面很多配置是可以直接在 xmake.lua 中配置来<strong>永久生效</strong>的。不过这里通过配置命令，也可以针对当前编译临时生效，配置结果也会被缓存。</p>
<p><strong>【注意】</strong> 每次的配置都是完整配置，会完全覆盖上一次的配置结果。</p>
<ul>
<li><strong>切换到调试编译模式</strong></li>
</ul>
<pre><code class="language-plain_text">xmake f -m debug
</code></pre>
<p>需要提示的一点是，xmake f 是 xmake config 的简写，用来简化输入提高效率，其它子命令也都是有简写的，大家可以在帮助菜单中查看。</p>
<ul>
<li><strong>切换编译输出目录</strong></li>
</ul>
<p>默认编译 xmake 会在当前项目根目录下生成 build 子目录作为编译输出目录，如果不想生成到当前目录下，我们可以通过下面的配置命令切换到其它输出目录下：</p>
<p><img src="media/16835100455777/16835112027083.jpg" alt="" /></p>
<p>如果配置成功，通过下面的命令查看当前的配置信息，确认是否生效。</p>
<p><img src="media/16835100455777/16835112136382.jpg" alt="" /></p>
<ul>
<li><strong>添加 C/C++ 编译选项</strong></li>
</ul>
<p>通过配置命令，我们可以在命令行中快速添加一些自定义的 C/C++ 编译选项，其中主要涉及这三个选项：</p>
<p><code>--cflags</code>：仅仅添加 C 编译选项。</p>
<p><code>--cxxflags</code>：仅仅添加 C++ 编译选项。</p>
<p><code>--cxflags</code>：同时添加 C/C++ 编译选项。</p>
<p>如果你的项目中既有 C 代码，也有 C++ 代码，那么使用 --cxflags 来同时设置会更加方便，使用方式如下：</p>
<pre><code class="language-plain_text">xmake f --cxflags=&quot;-DTEST&quot;xmake -rv
</code></pre>
<p>我们通过执行 <code>xmake -rv</code> 强制重新编译并且显示详细输出，来确认是否添加生效，下图红框部分中的 <code>-DTEST</code> 说明我们添加的 TEST 宏定义确实传入了 gcc 编译器。</p>
<p><img src="media/16835100455777/16835112882390.jpg" alt="" /></p>
<ul>
<li><strong>添加链接库和搜索路径</strong></li>
</ul>
<p>除了 C/C++ 代码编译，最后的链接器阶段的选项，我们也可以通过 --ldflags 命令参数添加设置，例如：</p>
<pre><code class="language-plain_text">xmake f --ldflags=&quot;-L/tmp -lpthread&quot;xmake -rv
</code></pre>
<p>通过添加额外的 pthread 链接库，同时新增了 /tmp 的库搜索目录，最后生效的效果如下：</p>
<p><img src="media/16835100455777/16835113231602.jpg" alt="" /></p>
<p>另外，我们也可以通过 <code>--links</code> 和 <code>--linkdirs</code> 达到同样的效果。</p>
<pre><code class="language-plain_text">xmake f --links=&quot;pthread&quot; --linkdirs=&quot;/tmp&quot;xmake -rv
</code></pre>
<ul>
<li><strong>切换到 clang 编译器</strong></li>
</ul>
<p>默认情况下，在 Linux 环境中，xmake 会优先使用 gcc 编译器，不过我们也可以很方便地切换使用其它的编译器，比如 clang，不过在使用 clang 编译器之前，需要执行下面的命令安装它。</p>
<pre><code class="language-plain_text">sudo apt update
sudo apt install -y clang
</code></pre>
<p>安装完成后，执行 <code>clang --version</code> 命令来确认 clang 是否安装成功。</p>
<p><img src="media/16835100455777/16835114030438.jpg" alt="" /></p>
<p>如果安装成功，执行下面的命令切换到 clang 编译工具链，然后执行编译。</p>
<pre><code class="language-plain_text">xmake f --toolchain=clang
xmake -rv
</code></pre>
<ul>
<li><strong>重置所有配置</strong></li>
</ul>
<p>经过之前的一些配置，我们缓存了不少编译配置，如果想重置所有配置到最初的默认状态，那么可以添加 -c 选项来重置所有。</p>
<p>默认配置下，也就是 release 编译模式，会忽略本地的配置缓存，像之前的编译输出路径、新增的编译选项配置都会被忽略。</p>
<pre><code class="language-plain_text">xmake f -c
xmake -rv
</code></pre>
<p>重置配置后，我们重新编译当前工程，可以看下里面的详细编译选项，已经完全还原回去了，刚刚设置的 clang 编译器重新变成了 gcc 编译器。</p>
<p><img src="media/16835100455777/16835114596113.jpg" alt="" /></p>
<h3><a id="5-show%E5%AD%90%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.show 子命令</h3>
<p>我们可以使用此命令，查看当前工程的基本信息，以及 xmake 自身的一些基本信息，这通常是非常有用的。</p>
<p>比如可以知道当前项目有哪些目标程序，当前的编译架构和模式是什么，以及 xmake 的临时目录、缓存目录和安装路径在哪里等。</p>
<pre><code class="language-plain_text">xmake show
</code></pre>
<p>显示的一些信息如下图：<br />
<img src="media/16835100455777/16835114977846.jpg" alt="" /></p>
<h3><a id="6-update%E5%AD%90%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.update 子命令</h3>
<p>如果 xmake 有新版本发布，我们可以使用自更新命令快速更新版本，只需要执行下面的命令。</p>
<pre><code class="language-plain_text">xmake update -f
</code></pre>
<p>这里我们额外加上了 <code>-f/--force</code> 参数，这是因为我们当前环境的 xmake 已经是最新版本，通常不需要更新，为了演示这个更新操作，我们通过这个参数来强制重新更新一遍当前的最新版本。</p>
<p><img src="media/16835100455777/16835116114472.jpg" alt="" /></p>
<p>更新完成后，我们可以继续执行 <code>xmake --version</code> 确认下版本是否为最新版本，实际的版本号由于时间关系，会有所变动，毕竟 xmake 的版本迭代还是挺频繁的。</p>
<p><img src="media/16835100455777/16835116307646.jpg" alt="" /></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16842229324486.html" 
          title="Previous Post: Mac生成和查看SSH Key">&laquo; Mac生成和查看SSH Key</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16781667160143.html" 
          title="Next Post: 使用KubeSphere部署Kubernetes">使用KubeSphere部署Kubernetes &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
