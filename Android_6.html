<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870849.html">
                
                  <h1>Android-酷炫的Activity切换动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码：</p>

<pre><code class="language-java">Intent intent=new Intent(this,SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
</code></pre>

<p>在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799839139489.gif" alt="20171015150799839139489.gif"/></p>

<p>先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。</p>

<h2 id="toc_1">使用内置Activity之间切换动画代码步骤</h2>

<p>Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示：</p>

<blockquote>
<p><strong>enter</strong>：用于决定第一次打开当前Activity时的动画<br/><br/>
<strong>exit</strong> : 用于决定退出当前Activity时的动画<br/><br/>
<strong>reenter</strong>: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画<br/><br/>
<strong>shared elements</strong>:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果  </p>
</blockquote>

<p>那么应该怎么去使用Activity切换动画呢？我们看看使用步骤：</p>

<ul>
<li>首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画<br/>
<code>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</code></li>
<li>接下来就是加载切换动画<br/>
其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。<br/>
<code>Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode);</code></li>
<li>告诉Window，当前的Activity在什么情况下使用上面的动画<br/>
上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果:<br/></li>
</ul>

<pre><code class="language-java">//退出时使用
getWindow().setExitTransition(explode);
//第一次进入时使用
getWindow().setEnterTransition(explode);
//再次进入时使用
getWindow().setReenterTransition(explode);
</code></pre>

<p>当然了，你也可以不使用代码的方式，直接在你使用的主题<style>标签里添加类似如下代码：</p>

<pre><code class="language-markup">&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt;
</code></pre>

<ul>
<li>调用startActivity<br/>
跟我们之前使用的<code>startActivity(Intent intent);</code>不同，这里多了一个参数<code>Bundle</code>，我们是先通过<code>makeSceneTransitionAnimation</code>函数创建一个<code>ActivityOptions</code>对象，再将其转为<code>Bundle</code>对象:<br/>
<code>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());</code><br/>
整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~</li>
</ul>

<h2 id="toc_2">Explode效果</h2>

<p>Explode即爆炸效果，使用Explode效果很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>explode.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>其中<code>duration</code>表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。<br/>
我们看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799868975358.gif" alt="20171015150799868975358.gif"/></p>

<h2 id="toc_3">Slide效果</h2>

<p>即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如<code>slide.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;/&gt;
</code></pre>

<p>其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799873587032.gif" alt="20171015150799873587032.gif"/></p>

<p>GIF 效果看的比较死板，可以下载我的源码实际运行一下~</p>

<p>如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定：</p>

<pre><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;&gt;
    &lt;targets&gt;
        &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot; /&gt;
        &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot; /&gt;
    &lt;/targets&gt;
&lt;/slide&gt;
</code></pre>

<h2 id="toc_4">Fade效果</h2>

<p>Fade效果即淡化效果，使用淡化效果依然是很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>fade.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~</p>

<h2 id="toc_5">Shared Element效果</h2>

<p>即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799880319943.gif" alt="20171015150799880319943.gif"/></p>

<p>从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~</p>

<p>接下来我们看看如何实现这个效果：</p>

<p><strong>1.将两个Activity中需要过渡的View加上<code>android:transitionName</code>属性</strong></p>

<p>两个View的<code>android:transitionName</code>属性取值要一致，比如：<br/><br/>
第一个Activity布局：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:id=&quot;@+id/firstSharedView&quot;
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>第二个Activity布局：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;300dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>两个绿色的View都添加<code>android:transitionName</code>属性，并且取名一致。</p>

<p><strong>2.调用startActivity</strong><br/><br/>
<code>ActivityOptions</code>的<code>makeSceneTransitionAnimation</code>函数第一个参数<code>Activity</code>没啥解释的，第二个参数就是第一个<code>Activity</code>中的<code>View</code>对象，第三个参数就是两个Activity的View的 <code>android:transitionName</code>属性的值。</p>

<p><code>startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView,&quot;sharedView&quot;).toBundle());</code></p>

<p>现在就可以实现这种<code>Shared Element</code>效果啦，但是可能你会想实现同时让两个View有这样的效果，可是<code>makeSceneTransitionAnimation</code>函数却只能让我们设置一个<code>View</code>和一个<code>transitionName</code>属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。</p>

<p>除了需要将两个<code>Activity</code>中需要过渡的<code>View</code>对应取相同的名称外，还需将需要过渡的<code>View</code>和<code>transitionName</code>取值对应的String这两个对象封装到一个Pair对象中：</p>

<pre><code class="language-java">Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));
Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));
</code></pre>

<p>然后调用<code>ActivityOptionsCompat</code>类的<code>makeSceneTransitionAnimation</code>的另一个重载函数<code>makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements)</code>，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。</p>

<pre><code class="language-java"> ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second);
</code></pre>

<p>最后调用startActivity</p>

<pre><code class="language-java"> ActivityCompat.startActivity(this,intent, transitionActivityOptions.toBundle());
</code></pre>

<p>说了这么多步骤，我们来看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799903533027.gif" alt="20171015150799903533027.gif"/></p>

<h3 id="toc_6">1 自定义 Shared Element切换动画</h3>

<p>如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下：</p>

<h4 id="toc_7">创建一个View的过渡移动的轨迹路径PathMotion类</h4>

<p>我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看<a href="https://developer.android.com/reference/android/transition/ArcMotion.html">【ArcMotion官方文档】</a></p>

<pre><code class="language-java">ArcMotion arcMotion = new ArcMotion();
arcMotion.setMinimumHorizontalAngle(50f);
arcMotion.setMinimumVerticalAngle(50f);
</code></pre>

<h4 id="toc_8">定义ChangeBounds类</h4>

<p>我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数：</p>

<blockquote>
<p>1.<code>ViewGroup  sceneRoot</code>：屏幕根View，即DecorView，第二个Activity的DecorView。<br/>
2.<code>TransitionValues  startValues</code>：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数<code>captureStartValues</code>里放置，因此你可以重写<code>captureStartValues</code>函数，并把你自定义的属性动画中的属性放进去。<br/>
3.<code>TransitionValues endValues</code> ：与<code>startValues</code>类似，表示属性动画结束时的属性值。可以通过重写<code>captureEndValues</code>函数，并把你自定义的属性动画里面的最终属性值放进去。</p>
</blockquote>

<p>我们先看一个最简单的示例：</p>

<pre><code class="language-java">package com.hc.util;

import android.animation.Animator;
import android.transition.ChangeBounds;
import android.transition.TransitionValues;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;


public class CustomChangeBounds extends ChangeBounds {

 @Override
  public Animator createAnimator(final ViewGroup sceneRoot,
                                 TransitionValues startValues,
                                 final TransitionValues endValues) {
      Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues);
      if (startValues == null || endValues == null || changeBounds == null) 
          return null;

      changeBounds.setDuration(300);
      changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(),
              android.R.interpolator.fast_out_slow_in));
      return changeBounds;
  }
}
</code></pre>

<p>看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799918618986.gif" alt="20171015150799918618986.gif"/></p>

<p>最后，再献上<a href="http://download.csdn.net/detail/huachao1001/9550440">源码</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870815.html">
                
                  <h1>Android-smali文件格式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">HelloWorld</h2>

<p>首先写一个 HelloWorld 类：</p>

<pre><code class="language-java">package jiuyou.hello.info;

public class HelloWorld {
    public static void main(String[] args){
        System.out.println(&quot;hello world&quot;);
    }
}
</code></pre>

<p>然后生成 apk 再用 apktool 工具转成 smali 文件：</p>

<pre><code class="language-text">.class public Ljiuyou/hello/info/HelloWorld;    #定义类名
.super Ljava/lang/Object;                       #定义父类
.source &quot;HelloWorld.java&quot;                       #源文件名

# direct methods      #直接方法  （# virtual methods 为虚方法）
.method public constructor &lt;init&gt;()V      #构造函数
    .locals 0     #方法中使用到的局部变量个数

    .prologue     #代码起始指令
    .line 8       #源代码所在行数
    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V         #调用父类构造方法

    return-void     #返回空
.end method         #方法结束

.method public static main([Ljava/lang/String;)V      #对应 main 方法
    .locals 2       #方法包含两个局部 v0,v1
    .param p0, &quot;args&quot;    # [Ljava/lang/String;   # main 方法的参数 agrs 标记为 p0

    .prologue       #代码起始指令
    .line 10
    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;  #将 System.out 这个静态变量赋给 v0

    const-string v1, &quot;hello world&quot;    #构造字符串

    #方法调用（调用 v0 的方法 println ，v1 是参数）
    invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V    

    .line 11
    return-void
.end method
</code></pre>

<h2 id="toc_1">字段</h2>

<p>静态字段格式如下：</p>

<pre><code class="language-text"># static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>实例字段格式如下：</p>

<pre><code class="language-text"># instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>举个栗子</p>

<p><strong>java</strong> ：</p>

<pre><code class="language-java">private String name;

private final String sex=&quot;男&quot;;

public static int age;
</code></pre>

<p><strong>smali</strong> :</p>

<pre><code class="language-text"># static fields
.field public static age:I

# instance fields
.field private name:Ljava/lang/String;

.field private final sex:Ljava/lang/String;
</code></pre>

<h2 id="toc_2">方法</h2>

<p>方法有直接方法和虚方法两种，两者格式基本相同：</p>

<pre><code class="language-text"># direct methods  (virtual methods)
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
    &lt;.locals&gt;
    [.parameter] or [.param]
    [.prologue]
    [.line]
    &lt;代码体&gt;
.end method
</code></pre>

<p><strong>.locals</strong>：局部变量个数<br/><br/>
<strong>.parameter or .param</strong>：指定每个参数<br/><br/>
<strong>.prologue</strong>：代码的开始处，混淆过的代码可能没有该指令<br/><br/>
<strong>.line</strong>：指定了该处指令在源代码中的行号，混淆过的代码可能没有该指令</p>

<p>举个栗子：<br/><br/>
<strong>java</strong></p>

<pre><code class="language-java">public String test(int a){
    int b=a+10;
    return &quot;test&quot;;
}
</code></pre>

<p><strong>smali</strong></p>

<pre><code class="language-text"># virtual methods
.method public test(I)Ljava/lang/String;
    .locals 2
    .param p1, &quot;a&quot;    # I

    .prologue
    .line 11
    add-int/lit8 v0, p1, 0xa

    .line 12
    .local v0, &quot;b&quot;:I
    const-string v1, &quot;test&quot;

    return-object v1
.end method
</code></pre>

<h2 id="toc_3">接口</h2>

<p>interface 格式如下：</p>

<pre><code class="language-text"># interfaces
.implements &lt;接口名&gt;
</code></pre>

<p>举个例子：<br/><br/>
<strong>java</strong></p>

<pre><code class="language-java">public interface If {
    int demo(String s);
}

public class InterfaceTest implements If {
    @Override
    public int demo(String s) {
        return 0;
    }
}
</code></pre>

<p><strong>smali</strong> ：</p>

<p>If.smali</p>

<pre><code class="language-text"># virtual methods
.method public abstract demo(Ljava/lang/String;)I
.end method
</code></pre>

<p>InterfaceTest.smali</p>

<pre><code class="language-text"># interfaces
.implements Ljiuyou/hello/info/If;

# virtual methods
.method public demo(Ljava/lang/String;)I
    .locals 1
    .param p1, &quot;s&quot;    # Ljava/lang/String;

    .prologue
    .line 11
    const/4 v0, 0x0

    return v0
.end method
</code></pre>

<h2 id="toc_4">注解</h2>

<p>格式如下：</p>

<pre><code class="language-text">.annotation [注解属性] &lt;注解类名&gt;
    [注解字段 = 值]
.end annotation
</code></pre>

<p>如果注解的作用范围是类， <strong>.annotation</strong> 指令会直接定义在 smali 文件中，如果作用范围是方法或者字段，则会包含在方法或字段定义中。  </p>

<p>举个栗子：<br/><br/>
<strong>java</strong>  </p>

<pre><code class="language-java">@Deprecated
public class AnnotationTest {
    @At(value = &quot;tom&quot;)
    public String name;
}
</code></pre>

<p><strong>smali</strong></p>

<pre><code class="language-text"># annotations
.annotation runtime Ljava/lang/Deprecated;
.end annotation


# instance fields
.field public name:Ljava/lang/String;
    .annotation runtime Ljiuyou/hello/info/At;
        value = &quot;tom&quot;
    .end annotation
.end field
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870745.html">
                
                  <h1>Android-CoordinatorLayout详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>曾在网上找了一些关于<code>CoordinatorLayout</code>的教程，大部分文章都是把<code>CoordinatorLayout</code>、<code>AppbarLayout</code>、<code>CollapsingToolbarLayout</code> 以及<code>Toolbar</code>等一起使用来介绍，这让我不知不觉在心中认为把这几个布局要一起使用，而且只是用于那种场景中。其实<code>CoordinatorLayout</code>的功能并不是局限于与<code>AppBarLayout</code>一起使用，它的功能强大着呢，本文主要对<code>CoordinatorLayout</code>的使用进行介绍，后面再写一篇文章将<code>AppBarLayout</code>和<code>CollapsingToolBarLayout</code>整合<code>CoordinatorLayout</code>一起。那么到底<code>CoordinatorLayout</code>有多好用，请往下感受吧~</p>

<h2 id="toc_0">CoordinatorLayout能做什么</h2>

<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子View的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子View的布局。我们先看一组动画图~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799569357936.gif" alt="20171014150799569357936.gif"/></p>

<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色Button查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。</p>

<p>这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个View的引用，然后在onTouchEvent里面做各种判断。如果我们想要实现的功能是，有更多的View要根据蓝色的View的移动相应作出响应，那么那就得在蓝色View的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~</p>

<p>而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>

<h2 id="toc_1">CoordinatorLayout使用</h2>

<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子View的意思了，是谁的子View呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code>是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的<code>View</code>的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个View就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。</p>

<p>怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>

<pre><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>

<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>

<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>

<p>我们看看<code>Behavior</code>的使用：</p>

<pre><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }
}
</code></pre>

<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>

<p>附上<a href="http://download.csdn.net/detail/huachao1001/9537636">源码地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870778.html">
                
                  <h1>Android-NDK图片高斯模糊</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CMake</h2>

<p>CMake是一款项目构建工具，通过编写简单明了的在CmakeLists.txt来生成makefile，简单来说就是一个makefile生成器。</p>

<p>在Android Studio中安装CMake非常简单，打开Tools-&gt;Android-&gt;SDK Manager，选择SDK Tools标签页，勾选CMake、LLDB、NDK，OK自动安装即可。其中LLDB可以使我们在Android Studio中调试C/C++程序。NDK为原生开发工具包，必不可少。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799632916996.png" alt="20171014150799632916996.png"/></p>

<h2 id="toc_1">为什么要做JNI/NDK开发</h2>

<p>众所周知，Java/Android程序是运行在JVM/Dalvik VM中，所以Java程序远没有C/C++程序性能高，尤其是在CPU密集型运算时，所以Java平台提供了JNI（Java Native Interface），可通过JNI调用C/C++等编写的so动态链接库。</p>

<p><strong>注：Google在Android L以后用ART彻底代替了Dalvik VM，但ART本质上仍是一个虚拟机，并支持所有Dalvik VM指令集。</strong></p>

<p>Java API中几乎所有与硬件相关的方法都是native的，比如I/O操作、网络访问、手机传感器、串口读写等。<br/><br/>
本文涉及的图片处理是一种CPU密集型任务，在Android开发中使用native方法最为合适。</p>

<h2 id="toc_2">如何使用CMake做JNI/NDK开发</h2>

<h3 id="toc_3">新建工程</h3>

<p>选中Include C++ Support，意为引入C++支持。</p>

<h3 id="toc_4">配置C++支持</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799640481339.png" alt="20171014150799640481339.png"/></p>

<p>在Customize C++ Support界面默认即可,意为CMake/C++11环境</p>

<h3 id="toc_5">认识CMakeLists.txt</h3>

<p>工程创建完毕之后Android Studio会在app目录下生成CMakeLists.txt文件。CMakeLists.txt是CMake的配置文件，用于表明版本、依赖、等信息，以下为Android Studio生成的CMakeLists（过滤注释）</p>

<pre><code class="language-text">cmake_minimum_required(VERSION 3.4.1)

add_library(native-lib SHARED src/main/cpp/native-lib.cpp)

find_library(log-lib log)

target_link_libraries(native-lib ${log-lib})
</code></pre>

<ul>
<li>cmake_minimum_required(VERSION 3.4.1)<br/>
CMake最小版本使用的是3.4.1。</li>
<li>add_library()<br/>
配置so库信息（为当前当前脚本文件添加库）
<ul>
<li>native-lib<br/>
这个是声明引用so库的名称，在项目中，如果需要使用这个so文件，引用的名称就是这个。值得注意的是，实际上生成的so文件名称是libnative-lib。</li>
<li>SHARED<br/>
这个参数表示共享so库文件，也就是在Run项目或者build项目时会在目录intermediates\transforms\mergeJniLibs\debug\folders\2000\1f\main下生成so文件。</li>
<li>src/main/cpp/native-lib.cpp<br/>
构建so库的源文件。</li>
</ul></li>
<li>find_library()查找一个库文件
<ul>
<li>log-lib<br/>
这个指定的是在NDK库中每个类型的库会存放一个特定的位置，而log库存放在log-lib中</li>
<li>log<br/>
指定使用log库</li>
</ul></li>
<li>target_link_libraries()<br/>
如果你本地的库（native-lib）想要调用log库的方法，那么就需要配置这个属性，意思是把NDK库关联到本地库。
<ul>
<li>native-lib<br/>
要被关联的库名称</li>
<li>\({log-lib}  <br/>
要关联的库名称，要用大括号包裹，前面还要有\)符号去引用。</li>
</ul></li>
</ul>

<h3 id="toc_6">了解JNI的C/C++规范</h3>

<h4 id="toc_7">数据类型</h4>

<p>JNI的数据类型包含两种，分别是基本类型和引用类型，它们和Java中的数据类型对应关系如下两表所示。</p>

<h5 id="toc_8">基本数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jboolean</td>
<td style="text-align: center">boolean</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jbyte</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jchar</td>
<td style="text-align: center">char</td>
<td style="text-align: center">无符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jshort</td>
<td style="text-align: center">short</td>
<td style="text-align: center">有符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jint</td>
<td style="text-align: center">int</td>
<td style="text-align: center">32位整型</td>
</tr>
<tr>
<td style="text-align: left">jlong</td>
<td style="text-align: center">long</td>
<td style="text-align: center">64位整型</td>
</tr>
<tr>
<td style="text-align: left">jfloat</td>
<td style="text-align: center">float</td>
<td style="text-align: center">32位浮点型</td>
</tr>
<tr>
<td style="text-align: left">jdouble</td>
<td style="text-align: center">double</td>
<td style="text-align: center">64位浮点型</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: center">void</td>
<td style="text-align: center">无类型</td>
</tr>
</tbody>
</table>

<h5 id="toc_9">引用数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jobject</td>
<td style="text-align: center">Object</td>
<td style="text-align: center">Object类型</td>
</tr>
<tr>
<td style="text-align: left">jclass</td>
<td style="text-align: center">Class</td>
<td style="text-align: center">Class类型</td>
</tr>
<tr>
<td style="text-align: left">jstring</td>
<td style="text-align: center">String</td>
<td style="text-align: center">String类型</td>
</tr>
<tr>
<td style="text-align: left">jobjectArray</td>
<td style="text-align: center">Object[]</td>
<td style="text-align: center">对象数组</td>
</tr>
<tr>
<td style="text-align: left">jbooleanArray</td>
<td style="text-align: center">boolean[]</td>
<td style="text-align: center">boolean数组</td>
</tr>
<tr>
<td style="text-align: left">jbyteArray</td>
<td style="text-align: center">byte[]</td>
<td style="text-align: center">byte数组</td>
</tr>
<tr>
<td style="text-align: left">jcharArray</td>
<td style="text-align: center">char[]</td>
<td style="text-align: center">char数组</td>
</tr>
<tr>
<td style="text-align: left">jshortArray</td>
<td style="text-align: center">short[]</td>
<td style="text-align: center">short数组</td>
</tr>
<tr>
<td style="text-align: left">jintArray</td>
<td style="text-align: center">int[]</td>
<td style="text-align: center">int数组</td>
</tr>
<tr>
<td style="text-align: left">jlongArray</td>
<td style="text-align: center">long[]</td>
<td style="text-align: center">long数组</td>
</tr>
<tr>
<td style="text-align: left">jfloatArray</td>
<td style="text-align: center">float[]</td>
<td style="text-align: center">float数组</td>
</tr>
<tr>
<td style="text-align: left">jdoubleArray</td>
<td style="text-align: center">double[]</td>
<td style="text-align: center">double数组</td>
</tr>
<tr>
<td style="text-align: left">jthrowable</td>
<td style="text-align: center">Throwable</td>
<td style="text-align: center">Throwable</td>
</tr>
</tbody>
</table>

<h4 id="toc_10">JNI的类型签名</h4>

<p>JNI的类型签名标识了一个特定的Java类型，这个类型既可以是类也可以是方法，也可以是数据类型。</p>

<ul>
<li>类的签名比较简单，它采用 L+包名+类型+; 的形式，只需要将其中的.替换为/即可。例如java.lang.String， 它的签名为Ljava/lang/String; ，注意末尾的;也是签名一部分。<br/></li>
<li>基本数据类型的签名采用一系列大写字母来表示, 如下表所示</li>
</ul>

<h5 id="toc_11">基本数据类型的签名</h5>

<table>
<thead>
<tr>
<th style="text-align: left">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">boolean</td>
<td style="text-align: center">Z</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">B</td>
<td style="text-align: center">char</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: left">short</td>
<td style="text-align: center">S</td>
<td style="text-align: center">int</td>
<td style="text-align: center">I</td>
<td style="text-align: center">long</td>
<td style="text-align: center">J</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: center">F</td>
<td style="text-align: center">double</td>
<td style="text-align: center">D</td>
<td style="text-align: center">void</td>
<td style="text-align: center">V</td>
</tr>
</tbody>
</table>

<h4 id="toc_12">JNI C/C++函数编写</h4>

<p>先来看看Android Studio为我们生成的示例</p>

<pre><code class="language-java">JNIEXPORT jstring JNICALL
Java_com_glee_myapplication_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = &quot;Hello from C++&quot;;
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<ul>
<li>JNIEXPORT &amp; JNICALL<br/>
JNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且编译器会进行正确的调用转换。</li>
<li>函数规范<br/>
在JNI中C/C++的函数名是有规范要求的，由以下几部分串接而成
<ul>
<li>Java_前缀</li>
<li>完全限定的类名，并用下划线“_”作为分隔符</li>
<li>第一参数JNIEnv* env</li>
<li>第二个参数jobject或jclass</li>
<li>其他参数按类型映射</li>
<li>返回参数按类型映射</li>
</ul></li>
</ul>

<h2 id="toc_13">JNI层操作Bitmap对象</h2>

<h3 id="toc_14">原理</h3>

<p>Android中JNI层处理Bitmap通常有两种方法</p>

<ul>
<li>获取到Bitmap中的byte数组并传入native方法，JNI层处理得到的byte数组后返回一个新的byte数组，Java层重建Bitmap对象。（不推荐）</li>
<li>Java层直接向JNI层传入Bitmap的引用，JNI层得到Bitmap对象的图像数据的地址，直接修改Bitmap的byte数组。</li>
</ul>

<p>阅读了很多篇博客，很多开发者都会采用第一种方法，本人是极不推荐的。这种方法会在内存中重建一个byte数组，会造成内存的浪费，性能低下。<br/><br/>
第二种方法是性能最优的，JNI层充分利用的C/C++指针的特性，直接获取到Bitmap中byte数组在内存中的地址，通过指针直接修改图像数据，所以用到了NDK中的android/bitmap.h。  </p>

<p><strong>android/bitmap.h</strong></p>

<p>android/bitmap.h这个头文件用于在JNI层操作Bitmap对象的，其包含于jnigraphics库中，所以要在CMakeLists.txt中的target_link_libraries加入-ljnigraphics，如下</p>

<p><code>target_link_libraries(native-lib -ljnigraphics ${log-lib})</code></p>

<p><strong>三个常用函数</strong></p>

<ul>
<li>AndroidBitmap_getInfo() 从位图句柄获得信息（宽度、高度、像素格式）</li>
<li>AndroidBitmap_lockPixels() 对像素缓存上锁，即获得该缓存的指针。</li>
<li>AndroidBitmap_unlockPixels() 解锁</li>
</ul>

<h3 id="toc_15">JNI接口函数</h3>

<p>请看注释</p>

<pre><code class="language-java">JNIEXPORT void JNICALL
Java_com_glee_ndkroad1006_MainActivity_gaussBlur(JNIEnv *env, jobject /* this */, jobject bmp) {
    AndroidBitmapInfo info = {0};//初始化BitmapInfo结构体
    int *data=NULL;//初始化Bitmap图像数据指针
    AndroidBitmap_getInfo(env, bmp, &amp;info);
    AndroidBitmap_lockPixels(env, bmp, (void **) &amp;data);//锁定Bitmap，并且获得指针
    /**********高斯模糊算法作对int数组进行处理***********/
    //调用gaussBlur函数，把图像数据指针、图片长宽和模糊半径传入
    gaussBlur(data,info.width,info.height,80);
    /****************************************************/
    AndroidBitmap_unlockPixels(env,bmp);//解锁
}
</code></pre>

<p>这里用到的gaussBlur函数代码将在文章最后列出。</p>

<h3 id="toc_16">Java层代码</h3>

<p>请看注释</p>

<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    static {
        //通过静态代码块加载so库
        System.loadLibrary(&quot;native-lib&quot;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //初始化两个ImageView
        ImageView iv1 = (ImageView) findViewById(R.id.img1);
        ImageView iv2 = (ImageView) findViewById(R.id.img2);
        //iv1设置图片
        iv1.setImageResource(R.drawable.test);
        //生成bitmap对象
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);
        //调用native方法，传入Bitmap对象，对Bitmap进行高斯迷糊处理
        gaussBlur(bitmap);
        //把Bitmap对象设置给iv2
        iv2.setImageBitmap(bitmap);
    }
    //native方法声明
    public native void gaussBlur(Bitmap bitmap);
}
</code></pre>

<h3 id="toc_17">运行效果</h3>

<p>上方的ImageView是没有进行高斯模糊处理的，下方的ImageView调用了JNI方法进行高斯模糊处理。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799728682414.png" alt="20171015150799728682414.png"/></p>

<h3 id="toc_18">高斯模糊算法</h3>

<pre><code class="language-c">void gaussBlur1(int* pix, int w, int h, int radius)
{
    float sigma = (float) (1.0 * radius / 2.57);
    float deno  = (float) (1.0 / (sigma * sqrt(2.0 * PI)));
    float nume  = (float) (-1.0 / (2.0 * sigma * sigma));
    float* gaussMatrix = (float*)malloc(sizeof(float)* (radius + radius + 1));
    float gaussSum = 0.0;
    for (int i = 0, x = -radius; x &lt;= radius; ++x, ++i)
    {
        float g = (float) (deno * exp(1.0 * nume * x * x));
        gaussMatrix[i] = g;
        gaussSum += g;
    }
    int len = radius + radius + 1;
    for (int i = 0; i &lt; len; ++i)
        gaussMatrix[i] /= gaussSum;
    int* rowData  = (int*)malloc(w * sizeof(int));
    int* listData = (int*)malloc(h * sizeof(int));
    for (int y = 0; y &lt; h; ++y)
    {
        memcpy(rowData, pix + y * w, sizeof(int) * w);
        for (int x = 0; x &lt; w; ++x)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int i = -radius; i &lt;= radius; ++i)
            {
                int k = x + i;
                if (0 &lt;= k &amp;&amp; k &lt;= w)
                {
                    //得到像素点的rgb值
                    int color = rowData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[i + radius];
                    g += cg * gaussMatrix[i + radius];
                    b += cb * gaussMatrix[i + radius];
                    gaussSum += gaussMatrix[i + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    for (int x = 0; x &lt; w; ++x)
    {
        for (int y = 0; y &lt; h; ++y)
            listData[y] = pix[y * w + x];
        for (int y = 0; y &lt; h; ++y)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int j = -radius; j &lt;= radius; ++j)
            {
                int k = y + j;
                if (0 &lt;= k &amp;&amp; k &lt;= h)
                {
                    int color = listData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[j + radius];
                    g += cg * gaussMatrix[j + radius];
                    b += cb * gaussMatrix[j + radius];
                    gaussSum += gaussMatrix[j + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    free(gaussMatrix);
    free(rowData);
    free(listData);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870710.html">
                
                  <h1>Android-AppBarLayout</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar</h2>

<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦~</p>

<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>

<pre><code class="language-markup">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>

<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将<code>AppTheme</code>的<code>parent</code>设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。</p>

<p>接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>

<pre><code class="language-markup">  &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>

<p>最后将Toobar作为“ActionBar”来用</p>

<pre><code class="language-java"> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>

<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦，hongyang大神有篇博客写的挺好的<a href="http://blog.csdn.net/lmj623565791/article/details/45303349">《 Android 5.x Theme 与 ToolBar 实战 》</a>可以去参考一下。</p>

<p>如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>

<p>正如你所看的这样，Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>

<h2 id="toc_1">AppBarLayout</h2>

<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当<strong>某个可滚动View</strong>的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>

<p>请注意：上面提到的<strong>某个可滚动View</strong>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>

<h3 id="toc_2">AppBarLayout子View的动作</h3>

<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>

<blockquote>
<p>（1） scroll:值设为scroll的View会跟随滚动事件一起发生移动。</p>
</blockquote>

<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>

<p>一张gif足以说明：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799488071606.gif" alt="20171014150799488071606.gif"/></p>

<p>对应的布局文件</p>

<pre><code class="language-markup">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<blockquote>
<p>（2） enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</p>
</blockquote>

<p>看个动画片（Y(<sup>o<sup>)Y）（ToolBar高度设为：<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code>）：</sup></sup></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799493830006.gif" alt="20171014150799493830006.gif"/></p>

<blockquote>
<p>（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</p>
</blockquote>

<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code>）：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799499853731.gif" alt="20171014150799499853731.gif"/></p>

<blockquote>
<p>（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。<br/>
来个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code>）：</p>
</blockquote>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799505696205.gif" alt="20171014150799505696205.gif"/></p>

<h3 id="toc_3">将AppBarLayout与ScrollView关联起来</h3>

<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，这不就是我们上一篇<a href="http://blog.csdn.net/huachao1001/article/details/51554608">《CoordinateLayout的使用如此简单 》</a>所学的内容吗？把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>

<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>

<pre><code class="language-markup"> &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

&lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>

<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。</p>

<p>好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>

<h2 id="toc_4">CollapsingToolbarLayout</h2>

<p>CollapsingToolbarLayout是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在AppBarLayout布局里面，并且作为AppBarLayout的直接子View。CollapsingToolbarLayout主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>

<blockquote>
<p>(1) 折叠Title（Collapsing title）：当布局内容全部显示出来时，title是最大的，但是随着View逐步移出屏幕顶部，title变得越来越小。你可以通过调用<code>setTitle</code>函数来设置title。  </p>

<p>(2)内容纱布（Content scrim）：根据滚动的位置是否到达一个阀值，来决定是否对View“盖上纱布”。可以通过<code>setContentScrim(Drawable)</code>来设置纱布的图片.  </p>

<p>(3)状态栏纱布（Status bar scrim)：根据滚动位置是否到达一个阀值决定是否对状态栏“盖上纱布”，你可以通过<code>setStatusBarScrim(Drawable)</code>来设置纱布图片，但是只能在LOLLIPOP设备上面有作用。  </p>

<p>(4)视差滚动子<code>View(Parallax scrolling children)</code>:子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动。<strong>（PS:其实就是让这个View的滚动的速度比其他正常滚动的View速度稍微慢一点）</strong>。将布局参数<code>app:layout_collapseMode</code>设为<code>parallax</code> </p>

<p>(5)将子View位置固定(Pinned position children)：子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将app:layout_collapseMode设为pin。</p>
</blockquote>

<p>了解这些概念后，我们来看看布局吧~</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;


    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150799532425417.gif" alt="20171014150799532425417.gif"/></p>

<p>如果你希望拖动过程中状态栏是透明的，可以在<code>CollapsingToolbarLayout</code>中加 <code>app:statusBarScrim=&quot;@android:color/transparent</code>&quot;，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>

<p>献上<a href="http://download.csdn.net/detail/huachao1001/9538934">源码</a></p>

<h2 id="toc_5">AppBarLayout的ScrollFlags属性</h2>

<p>在前面两篇MD系列的文章中，通过两个案例基本上能够掌握了CoordinatorLayout与AppBarLayout的配合使用。本文我们回过头来详细聊聊AppBarLayout的ScrollFlags属性，了解一下不同值之间的区别。至此，Android Material Design系列的学习已进行到第七篇，大家可以点击以下链接查看之前的文章：</p>

<ul>
<li><a href="http://www.jianshu.com/p/39a66373498c">Android TabLayout 分分钟打造一个滑动标签页</a></li>
<li><a href="http://www.jianshu.com/p/9eb3b17b0e77">Android 一文告诉你到底是用Dialog，Snackbar，还是Toast</a></li>
<li><a href="http://www.jianshu.com/p/5328b2eee827">Android FloatingActionButton 重要的操作不要太多，一个就好</a></li>
<li><a href="http://www.jianshu.com/p/ab04627cce58">Android 初识AppBarLayout 和 CoordinatorLayout</a></li>
<li><a href="http://www.jianshu.com/p/4b0f3c80ebc9">Android CoordinatorLayout实战案例学习《一》</a></li>
<li><a href="http://www.jianshu.com/p/360fd368936d">Android CoordinatorLayout 实战案例学习《二》</a></li>
</ul>

<p>ScrollFlags共有五种常量值供AppBarLayout的Children View使用，在xml布局文件中通过<code>app:layout_scrollFlags</code>设置，对应的值为：scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；也可以在代码中通过<code>setScrollFlags(int)</code>方法使用，比如：</p>

<pre><code class="language-java">Toolbar toolbar = ... // your toolbar within an AppBarLayout
AppBarLayout.LayoutParams params = 
    (AppBarLayout.LayoutParams) toolbar.getLayoutParams();
params.setScrollFlags(AppBarLayout.LayoutParams.SCROLL_FLAG_SCROLL
    | AppBarLayout.LayoutParams.SCROLL_FLAG_ENTER_ALWAYS);
</code></pre>

<p>下面我们通过官网介绍、XML代码和对应的效果图分别分析这五种值的使用（备注：代码中设置也一样，不再赘述）：</p>

<h3 id="toc_6">scroll</h3>

<blockquote>
<p>The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect.</p>
</blockquote>

<p>Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个child View前面的任何其他Child View没有设置这个值，那么这个Child View的设置将失去作用。</p>

<p>示例XML代码：</p>

<pre><code class="language-markup">    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
            android:id=&quot;@+id/tb_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;@dimen/dp_56&quot;
            app:titleTextColor=&quot;@color/white&quot;
            app:title=&quot;@string/app_name&quot;
            app:theme=&quot;@style/OverFlowMenuTheme&quot;
            app:popupTheme=&quot;@style/AppTheme&quot;
            android:background=&quot;@color/blue&quot;
            app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p>对应效果图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150842247229844.gif" alt="20171019150842247229844.gif"/></p>

<h3 id="toc_7">enterAlways</h3>

<blockquote>
<p>When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the &#39;quick return&#39; pattern.</p>
</blockquote>

<p>快速返回模式。其实就是向下滚动时Scrolling View和Child View之间的滚动优先级问题。对比<code>scroll</code>和<code>scroll | enterAlways</code>设置，发生向下滚动事件时，前者优先滚动Scrolling View，后者优先滚动Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。</p>

<p>示例XML代码：</p>

<pre><code class="language-java">...
app:layout_scrollFlags=&quot;scroll|enterAlways&quot;
...

</code></pre>

<p>对应效果图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150842251698266.gif" alt="20171019150842251698266.gif"/></p>

<h3 id="toc_8">enterAlwaysCollapsed</h3>

<blockquote>
<p>An additional flag for &#39;enterAlways&#39; which modifies the returning view to only initially scroll back to it&#39;s collapsed height. Once the scrolling view has reached the end of it&#39;s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>enterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。</p>

<p>示例XML代码：</p>

<pre><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150842256217688.gif" alt="20171019150842256217688.gif"/></p>

<h3 id="toc_9">exitUntilCollapsed</h3>

<blockquote>
<p>When exiting (scrolling off screen) the view will be scrolled until it is &#39;collapsed&#39;. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>这里也涉及到最小高度。发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。</p>

<p>示例SML代码：</p>

<pre><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150842260265572.gif" alt="20171019150842260265572.gif"/></p>

<h3 id="toc_10">snap</h3>

<blockquote>
<p>Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it&#39;s closest edge. For example, if the view only has it&#39;s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it&#39;s bottom 75% is visible then it will be scrolled fully into view.</p>
</blockquote>

<p>简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。</p>

<p>示例XML代码：</p>

<pre><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
...
app:layout_scrollFlags=&quot;scroll|snap&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150842265497458.gif" alt="20171019150842265497458.gif"/></p>

<h3 id="toc_11">示例源码</h3>

<p>我在GitHub上建立了一个Repository，用来存放整个Android Material Design系列控件的学习案例，会伴随着文章逐渐更新完善，欢迎大家补充交流，Star地址：</p>

<p><a href="https://github.com/Mike-bel/MDStudySamples">https://github.com/Mike-bel/MDStudySamples</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870673.html">
                
                  <h1>Android-Debug</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、 进入 debug 模式的两种姿势</h2>

<p>第一种是点击运行按钮旁边的“绿色甲虫”(debug app)开始以调试模式编译运行。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797278068907.png" alt="20171014150797278068907.png"/></p>

<p>这个方式的特点是，一开始就进入了调试模式。适合希望尽早进入调试模式的场景，比如你想从头开始追踪问题，或者断点在启动页或首页之类的。它的弊端是每次需要从头跑一遍，且由于调试模式下应用程序略卡顿，等你到达调试页面时会觉得老费劲。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797280245394.png" alt="20171014150797280245394.png"/></p>

<p>第二种方式是在手机或模拟器已经跑起来应用程序后点击 <code>Run</code> -&gt; <code>Attach debugger to Android process</code>，选择应用程序主进程，即可进入调试模式。</p>

<p>这种方式的特点是，随时随地自由进入调试模式，不需要重头开始跑应用程序，该方式适合绝大多数调试场景。需要注意的是，假如跑的是 <code>release</code> 版本且有混淆加固之类的话，该方式就无法正常调试。</p>

<h2 id="toc_1">二、 常见的调试操作</h2>

<h3 id="toc_2">1 典型的调试场景</h3>

<p>一个最常见的调试场景如下：</p>

<ol>
<li>完成包括打开 Android Studio、打开需要调试的类、连接手机等准备工作</li>
<li>在关键位置打上普通断点，进入调试模式后触发断点，将当前线程阻塞在断点处</li>
<li>单步调试，一行一行往下运行</li>
<li>碰到方法调用时进入方法内部</li>
<li>用单步调试单步执行直到该方法结束回到方法调用的下一行，或者直接退出当前方法</li>
<li>通过观察观察区的相关变量，推断出问题所在，结束本次调试</li>
</ol>

<p>以上是最常规的 debug 场景，下面介绍下调试界面。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797289056229.png" alt="20171014150797289056229.png"/></p>

<p>在 Android Studio 的 debug 标签（假如一开始没有，等触发断点后自然会出现）中有两个面板 debugger 和 console。debugger 又分为 Frames、Threads 和 Variables 三块，分别是堆栈内容、线程、变量区。</p>

<p>在 debugger 标签右边有一些操作按钮，是我们常用的调试操作，下面会一一介绍。（可以用鼠标悬停在上面看每个按钮的具体名称）</p>

<h3 id="toc_3">2 设置断点</h3>

<p>断点有多种类型，我们这里先只谈普通断点。在每行的最前端单击一下即可<strong>添加断点</strong>，在断点上单击一下是<strong>取消断点</strong>。普通模式下断点只是一个普通的红点，但假如是在调试模式下，则红点上会有一个“√”或“✘”表示该行是否会被运行，例如，注释行前的断点会是“✘”。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797294991936.png" alt="20171014150797294991936.png"/></p>

<p>不管怎样，触发断点肯定是调试的起点。只有触发了断点，才会开始阻塞线程（注意是只会阻塞当前线程，这个后面会扩展一下详细介绍），此时当前代码行会被蓝色高亮，观察面板上的变量也会显示当前环境下的值。</p>

<h3 id="toc_4">3 跳到下一个断点（F9）</h3>

<p>一般情况下，在调试时我们可以根据我们的经验在几个关键的位置打上断点，这里就需要从一个断点直接跳到下一个断点。操作是继续以 debug 模式运行，快捷键是 F9（假如没改动的话应该都是这个快捷键，假如不同，可以把鼠标悬浮在该图标上看提示，下同）。</p>

<h3 id="toc_5">4 单步调试（F8）</h3>

<p>触发断点后，我们当然可以通过加 N 个断点来定位问题，但在较复杂的场景里可能没法判断出关键点。这时可以在比较靠前的位置添加断点作为起点，一行一行执行。操作是单步调试，快捷键是 F8。</p>

<h3 id="toc_6">5 进入方法内部（F7）</h3>

<p>在单步调试时方法调用语句会被看做一行，那么如何进入方法内部呢？用“进入内部”操作，快捷键是 F7.</p>

<h3 id="toc_7">6 退出当前方法（上档键+F8）</h3>

<p>既然有进入方法内部，就有退出当前方法的操作。当进入某个方法内部后觉得该方法后面的代码不需要看了，不需要猛按 F8 让它们跑完，可以直接退出当前方法去到该方法调用处的下一行。</p>

<p>有了这些操作，基本可以应付常见的 80% 的调试场景了。但仅仅了解这些，在面对复杂场景时难免效率低下。下面介绍几种非常高效的断点。</p>

<h2 id="toc_8">三、 几种高效断点</h2>

<h3 id="toc_9">1 条件成立时才触发的条件断点</h3>

<p>普通断点在每次运行到时都会被触发，这在多次调用、有“循环”的场景会比较麻烦，比如循环 100 次只希望停留在第 98 次。那么此刻就可以用上条件断点了。</p>

<p>添加条件断点：先在需要的行前左键单击添加普通断点，右键点击该断点出现对话框，在“Condition”处填入条件即可，条件语法同 Java，如 i == 98。点击 Done，完成添加。这样当条件未满足时，不会阻塞程序运行；当条件满足时断点被触发。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797301917622.png" alt="20171014150797301917622.png"/></p>

<h3 id="toc_10">2 不会阻塞应用程序的日志断点</h3>

<p>有时候我们仅仅希望在关键时刻输出一些 log，那么我们需要做这些工作：</p>

<ol>
<li>在代码里加上 log 代码</li>
<li>重新运行程序</li>
<li>重新触发断点</li>
</ol>

<p>那么有没有什么方法可以避免这些繁杂的操作呢？这时可以试试日志断点。</p>

<p>在条件断点弹出的对话框里，将“suspend”设置为未选中状态，断点触发时就不会被阻塞。此时对话框会多出一些选项。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079730545598.png" alt="2017101415079730545598.png"/></p>

<p>我们选中“Evaluated and log”，并在里面填写希望输出的日志，点击 Done 即可。注意，日志将输出到 Console 而非 LogCat。</p>

<h3 id="toc_11">3 被异常触发的异常断点</h3>

<p>我们做 debug，一般面对的都是未崩溃的异常，例如 UI 状态不对、数值不对、代码执行逻辑不对等等。碰到直接 crash 的情况，我们往往不会去 debug，而是根据报错信息定位到某某行，然后解决问题。最典型的就是空指针异常了，只要看到报错位置，基本手到擒来。</p>

<p>但日常开发难免碰到一些给出具体信息和抛异常的位置也没有头绪或者未给出具体位置的情况，比如某 API 抛了个状态异常，那么我们可能得去琢磨为何会状态不对。</p>

<p>这时还是得调试，但我们也不能眼睁睁看着抛出的异常让应用程序崩了，可以用上“异常断点”。</p>

<p>我们打开断点管理器，可以看到有一类是“Java Exception Breakpoints”，直接勾上是所有异常都会被触发。</p>

<p>假如只想被某种异常触发，我们可以点击“+”，选中“Java Exception Breakpoints”，然后输出该种异常即可。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797308856387.png" alt="20171014150797308856387.png"/></p>

<p>有朋友可能注意到除了 “Java Exception Breakpoints” 外还有一个 “Exception Breakpoints”，两者区别主要是前者只支持 Java 本身的异常，后者可以支持自定义异常。</p>

<h3 id="toc_12">4 追踪关键点的字段断点和方法断点</h3>

<p>在诸如多线程等复杂场景下，超多的变量和超多的类再加上一些 native 方法和第三方库，调试的复杂度也直线上升。</p>

<p><strong>这时可以尝试以点破面，抓住关键方法或字段来追踪应用程序的运行轨迹。</strong>于是关注某字段的字段断点和关注某方法的方法断点就派上用场了。</p>

<p>顾名思义，字段断点的触发条件是字段值被更改，方法断点是方法被调用。</p>

<p>添加方式：在字段那行、在方法声明的那行单击即可。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797311954451.png" alt="20171014150797311954451.png"/></p>

<h3 id="toc_13">5 注意事项</h3>

<p>除了以上这些，还有其他断点未列出来，比如临时断点等。考虑到这类断点实用性不强，就不多加说明，有需求的朋友自然会去了解。</p>

<p><strong>需要说明的是，给断点命名只是为了方便交流，各类型之间并没有特别边界。</strong> 实际上，断点只是某些操作的集合而已。比如日志断点是“不阻塞”和“输出日志”两个操作的集合，那么我们当然可以加上“设置条件”操作变成“条件日志断点”，诸如此类。我们设置断点的面板是允许我们将多种断点条件混合使用的。</p>

<p>所以，<strong>断点名称和类型不重要，重要的是针对现场选用合适的操作。</strong></p>

<h2 id="toc_14">四 调试中的变量</h2>

<p>在设置了合适的断点后，我们就可以进行下一步操作 —— 观察变量，准确的说是观察变量的值。</p>

<h3 id="toc_15">1 变量观测面板</h3>

<p>众所周知，应用程序在运行期间元素都处于一种动态状态，此刻你是无法观测到具体变量的值的。只有当动态变成静态，即阻塞住应用程序，才能开始变量观测。</p>

<p>这个“阻塞”操作也就是上文提到的断点触发。</p>

<p>这里需要特别指出的是，当需要追踪某一个特定变量时，字段断点是一大利器。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797315866815.png" alt="20171014150797315866815.png"/></p>

<p>如上图所示，变量观察面板会列出所有当前能访问到的成员变量和局部变量。</p>

<p>点击变量前的箭头，可以将该实例展开，列出所有字段。</p>

<h3 id="toc_16">2 Add New Watch</h3>

<p>将所有变量、所有字段列出来是比较直观，但当我们要去获取某些属性时就略蛋疼了。</p>

<p>比如，获取某成员变量 View 的第一个 <code>child</code> 的 <code>measuredHeight</code>。假如是靠手动去一个个“打开”属性列表，拿得多麻烦。</p>

<p>又比如，我们需要获取到两个属性相加后占另一个值的百分比。先去找到这两个属性的值然后额外拿计算器计算？</p>

<p>这时就可以用上 “Add New Watch”了，添加一个观察表达式。通俗点就是在变量观测区执行一个表达式并得到它的值。</p>

<p>在面试左侧点击绿色“+”，或者点击右键在菜单中选择“New Watch”, 就会出现一个框，输入表达式即可。</p>

<p>举个例子：</p>

<p>在示例中输入<code>toolbar.getChildAt(0).getMeasuredHeight()</code>，可得到如图的结果。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797320181952.png" alt="20171014150797320181952.png"/></p>

<h3 id="toc_17">3 设置变量的值</h3>

<p><strong>变量的值除了能被观察外，还可以在运行时改变。</strong> 这个可以说是超酷的黑科技了。试想，碰到一个 <code>if else</code> 时，我们可以很轻松无成本地通过更改变量的值，让应用程序能跑到我们期望的分支上。</p>

<p>设置变量的值有两种方式：方式一是在变量观测区右键单击变量，在菜单中选中“set value”；方式二是鼠标悬浮在代码区中的某个可访问的变量上，在弹出的浮层里更改值。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797323062129.png" alt="20171014150797323062129.png"/></p>

<h2 id="toc_18">五 犀利的小功能</h2>

<p>除了以上那些常规的操作，还有一些“还有这种操作”的小功能。</p>

<h3 id="toc_19">1 Force Run to Cursor</h3>

<p>该操作可以忽视已存在的断点，直接跳到光标所在的行。有种脱离断点、繁琐操作的束缚轻松自由的感觉有木有。</p>

<h3 id="toc_20">2 Drop frame</h3>

<p>经过不懈努力，终于快到出错的那个时刻啦，你眉飞色舞手指按得飞快，结果小手一抖，多按了几个 F8 （单步调试快捷键），错过了出错的那个时刻。<strong>如果能回退到方法执行前？</strong></p>

<p>Drop frame 功能能让你回到当前方法被调用的地方，并且当前上下文所有变量也都恢复到方法调用前 —— 时光回溯有木有？</p>

<p><strong>当然别太兴奋，由于 DalvikVM 和 Android Runtime (ART) 不支持，大部分情况下你是用不到的，那个按钮长期处于不可点击状态。</strong>但如果你是在跑 JUnit 测试的话，是可以用上的。</p>

<h3 id="toc_21">3 Log</h3>

<p>在多线程环境下，光靠 debug 是不行的。有时 debug 本身会带来一些问题混淆了现场，比如因为 debug 时的卡顿造成环境不一致等等，这时应该学会使用打日志的形式帮忙调试。</p>

<h3 id="toc_22">4 布局查看器</h3>

<p>在 Android Studio 的 Android Device Monitor 里有一个 “Dump View Hierarchy for UI Automator” 功能，可以看到当前手机上应用的具体布局情况 —— 甚至布局元素的属性都会一一给出（仅可用于可调试的应用）。对 UI 调试非常有帮助。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797328687524.png" alt="20171014150797328687524.png"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870639.html">
                
                  <h1>Android-组件化学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>网上关于组件化的文章有很多了，大部分都知道实现的思路，不过还是要自己去实践一下才会发现问题。文章的<a href="https://github.com/zj-wukewei/ModularizationExample">项目地址</a>，项目用到CleanArchitecture框架，本文会介绍CleanArchitecture框架和dagger2在组件化的使用。</p>

<h2 id="toc_0">项目关系图</h2>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797219986560.png" alt="20171014150797219986560.png"/></p>

<ul>
<li>sdk: 一些公用库，各种辅助类，和第三方view</li>
<li>basic: (依赖sdk) 网络访问初始化，本地缓存和第三方包等。</li>
<li>commonbusiness: (依赖basic) 这里为什么我会多出这一层，因为有很多公共的业务，好比公司的app是强登录的，我会把登录模块写在这里，里面也包含了一些baseActivity和BaseApplication和各个组件的一些公共方法还有组件各种的服务接口的定义。</li>
<li>module_archives和module_knowledge： 就是两个组件，可以单独运行。</li>
</ul>

<h2 id="toc_1">application和library切换</h2>

<p>想必大家都知道了，定义一个isBuildModule=false，在组件的build.gradle中加入</p>

<pre><code class="language-java">if (isBuildModule.toBoolean()) {
    apply plugin: &#39;com.android.application&#39;
} else {
    apply plugin: &#39;com.android.library&#39;
    apply from: &#39;maven-release-kline-aar.gradle&#39;
}

 sourceSets {
        main {
            if (isBuildModule.toBoolean()) {
                manifest.srcFile &#39;src/main/debug/AndroidManifest.xml&#39;
            } else {
                manifest.srcFile &#39;src/main/release/AndroidManifest.xml&#39;
                java {
                    exclude &#39;**/debug/**&#39;
                }
            }
        }
    }
</code></pre>

<p>maven-release-kline-aar.gradle是一个打包aar的文件，在切换的时候也会使用不同的AndroidManifest.xml，因为在组件是debug的时候它是单独单独运行的，还有就是代码可以在建立一个debug包，可以在单独运行的时候做些初始化app的，打包的时候回剔除这部分代码。</p>

<h2 id="toc_2">library依赖和资源问题</h2>

<p>我把所以的library都依赖在basic，每个组件都会依赖这个包，这样就不会存在library的版本问题，资源的问题就是</p>

<pre><code class="language-text"> defaultConfig {

        if (isBuildModule.toBoolean()) {
            applicationId &quot;com.wkw.archives&quot;
        }

        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName

        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;

        resourcePrefix &quot;archives&quot;
    }
</code></pre>

<h2 id="toc_3">组件之间的通信</h2>

<p>你可以选择阿里的<a href="https://github.com/alibaba/ARouter">ARouter</a>库，但是我的项目没有那么复杂，组件也就4个左右，所以没有使用阿里的库，我采用的是以下就是核心代码，</p>

<pre><code class="language-java">Object result = null;
Class&lt;?&gt; c = Class.forName(className);
if (c != null) {
    result = c.newInstance();
}
return result;
</code></pre>

<p>但是采用Class.forName会有个问题那就是在混淆的时候，className是指定的，所以要在类上加@Keep 。</p>

<h2 id="toc_4">CleanArchitecture框架和dagger在组件化的使用</h2>

<p><a href="https://github.com/android10/Android-CleanArchitecture">CleanArchitecture框架的github地址</a>，这里再介绍分享一篇文章小鄧子的<a href="http://www.jianshu.com/p/3edcf85539a6">Easy Clean architecture on Android</a>,我把data和domain会写在各自的业务模块中，自己的模块只要定义自己的就可以了，有个ApplicationModule会定义一些每个模块都需要的，</p>

<pre><code class="language-java">public class ApplicationModule {

    @Provides
    @Singleton
    Context provideContext(Application application) {
        return application;
    }

    @Provides
    @Singleton
    UserSystem provideUserSystem() {
        return new UserSystem();
    }

    @Provides
    @Singleton
    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {
        return jobExecutor;
    }

    @Provides
    @Singleton
    PostExecutionThread providePostExecutionThread(UIThread uiThread) {
        return uiThread;
    }

    @Provides
    @Singleton
    MrService provideMrService() {
        return new MrService();
    }

    @Provides
    @Singleton
    UserCache provideUserCache(UserCacheImpl userCache) {
        return userCache;
    }
}
</code></pre>

<p>然后在module_archives模块中会有ArchivesDataRepositoryModule和ArchivesActivityModule<br/>
其中KnowledgeDataRepositoryModule用于提供如下：</p>

<pre><code class="language-java">@Module
public class ArchivesDataRepositoryModule {

    @Provides
    @Singleton
    ArchivesApi providesArchivesApi(MrService mrService) {
        return mrService.createApi(ArchivesApi.class);
    }

    @Provides
    @Singleton
    ArchivesRepository prvidesArchivesRepository(ArchivesDataRepository archivesDataRepository) {
        return archivesDataRepository;
    }
}
</code></pre>

<p>ArchivesActivityModule的代码如下：</p>

<pre><code class="language-java">@Module
public abstract class ArchivesActivityModule {
   @PerActivity
   @ContributesAndroidInjector()
   abstract ArchivesActivity contributeArchivesActivity();
}
</code></pre>

<p>这样在主app的AppComponent类中加入：</p>

<pre><code class="language-java">@Singleton
@Component(modules = {
       AndroidInjectionModule.class, ApplicationModule.class,
       ArchivesDataRepositoryModule.class, ArchivesActivityModule.class,
       KnowledgeDataRepositoryModule.class, KnowledgeActivityModule.class
})
public interface AppComponent {
   @Component.Builder
   interface Builder {
       @BindsInstance
       Builder application(Application application);
       AppComponent build();
   }
   void inject(MrApplication mrApplication);
}
</code></pre>

<p>在module_archives为debug模式下也会有个AppComponent</p>

<pre><code class="language-java">@Singleton
@Component(modules = {
        AndroidInjectionModule.class, ApplicationModule.class,
        ArchivesDataRepositoryModule.class, ArchivesActivityModule.class
})
public interface AppComponent {
    @Component.Builder
    interface Builder {
        @BindsInstance
        Builder application(Application application);
        AppComponent build();
    }
    void inject(ArchivesApplication mrApplication);
}
</code></pre>

<p>各种模块初始化api和Repository，你要是嫌弃每个模块都要引入两个.class文件，你可以使用一个然后采用include的方式好比dagger中的AndroidSupportInjectionModule类方式</p>

<pre><code class="language-java">@Beta
@Module(includes = AndroidInjectionModule.class)
public abstract class AndroidSupportInjectionModule {
  @Multibinds
  abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;
      supportFragmentInjectorFactories();

  private AndroidSupportInjectionModule() {}
}
</code></pre>

<p>这样就会很清楚的知道自己模块需要初始化什么和使用什么，也不用考虑其它模块的初始化的数据，之后只需要在主app加入就行，也是比较方便的。</p>

<h2 id="toc_5">打包</h2>

<p>各种模块当为library是要打包成aar的，maven-release-kline-aar.gradle文件代码如下:</p>

<pre><code class="language-java">apply plugin: &#39;maven&#39;

ext {// ext is a gradle closure allowing the declaration of global properties
    PUBLISH_GROUP_ID = &#39;com.wkw&#39;
    PUBLISH_ARTIFACT_ID = &#39;archives&#39;
    PUBLISH_VERSION = rootProject.ext.versionName
}

uploadArchives {
    repositories.mavenDeployer {
        //这里就是最后输出地址，在自己电脑上新建个文件夹，把文件夹路径粘贴在此
        //注意”file://“ + 路径，有三个斜杠，别漏了
        repository(url: &quot;file:///Users/wukewei/Documents/android/ModularizationExample/repo&quot;)

        pom.project {
            groupId project.PUBLISH_GROUP_ID
            artifactId project.PUBLISH_ARTIFACT_ID
            version project.PUBLISH_VERSION
        }
    }
}

//以下代码会生成jar包源文件，如果是不开源码，请不要输入这段
//aar包内包含注释
task androidSourcesJar(type: Jar) {
    classifier = &#39;sources&#39;
    from android.sourceSets.main.java.sourceFiles
}

artifacts {
    archives androidSourcesJar
}
</code></pre>

<p>我只是打包到本地，你可以自己建立一个本地maven库。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870604.html">
                
                  <h1>Android-自定义皮肤</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">自定义Style和Theme</h2>

<p>  Style和Theme主要用来实现白天模式和夜间模式。<br/><br/>
  一个Style是一系列属性的集合，用来指定View或者Window的外观和格式。它可以指定的属性包括高度, Padding, 文字颜色，文字尺寸，背景颜色等等。<br/><br/>
  Style是在Xml资源文件中定义的，比如：</p>

<pre><code class="language-markup">&lt;style name=&quot;ListItemTitleStyle&quot; parent=&quot;TextAppearance.AppCompat.Body1&quot;&gt;
    &lt;item name=&quot;android:singleLine&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:ellipsize&quot;&gt;end&lt;/item&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;?android:attr/textColorPrimary&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  在布局文件中是这样使用的：</p>

<pre><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/text_item_title&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    style=&quot;@style/ListItemTitleStyle&quot; /&gt;
</code></pre>

<p>  这样一个Style就可以运用在多个地方，既可以统一样式，又可以减少代码量。<br/><br/>
  而Theme，其实就是一个Style，不同于我们上面提到对单一View的应用，Theme是应用于整个Activity或Application的。各位Android开发同学一定不陌生，在Manifest的Activity声明中就会经常看到。  </p>

<pre><code class="language-java">&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;
</code></pre>

<p>  这样，AppLightTheme.NoActionBar中的所有属性都会应用在整个Activity中。</p>

<p>  轻听这里，实现夜间模式分三步：</p>

<ul>
<li>自定义Style</li>
<li>应用Style中的属性</li>
<li>设置Theme</li>
</ul>

<h2 id="toc_1">自定义Style</h2>

<p>  我们这里，就是写两个Style ，然后各自有一套对应的颜色值。<br/>
  简单介绍一下几个主要的颜色值：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797106845044.png" alt="20171014150797106845044.png"/></p>

<ul>
<li>colorPrimary: 主题色</li>
<li>colorAccent: 辅助色（或强调色）</li>
<li>textColorPrimary: 主要的文字颜色，一般TextView的文字都是这个颜色</li>
<li>textColorSecondary: 辅助的文字颜色，一般比textColorPrimary的颜色弱一点，用于一些弱化的表示</li>
<li>windowBackground: Window的背景色<br/>
  <br/>
  我们在资源文件中写对应的两套Style:</li>
</ul>

<pre><code class="language-markup">&lt;style name=&quot;AppLightTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorPrimaryTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;AppDarkTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/darkColorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/darkColorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextWhite&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/dark_bg&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  细心的同学会发现，Style里的属性，有的前面会以“android:”开头，如<code>android:textColorPrimary</code>，有的则没有，如<code>colorPrimary</code>。<br/>
  以“android:”开头的属性，是系统的属性。而另一种属于自定义的属性，在资源文件中声明如下：</p>

<pre><code class="language-markup">&lt;attr name=&quot;minibar_background&quot; format=&quot;color&quot; /&gt;
</code></pre>

<p>  format包括boolean, color, dimension, enum, flag, float, fraction, integer, reference, string。 在此就不赘述了，这是它们的一个相当灵活的使用方式。</p>

<h2 id="toc_2">应用Style中的属性</h2>

<p>  比如，colorAccent是在design包中定义的，属于自定义属性，在使用的时候，直接“?attr/”+属性名就可以了。</p>

<pre><code class="language-markup">&lt;ImageView
    android:tint=&quot;?attr/colorAccent&quot; /&gt;
</code></pre>

<p>  系统属性要多加一个”android:”, 是”?android:attr/“+属性名。</p>

<pre><code class="language-markup">&lt;TextView
    android:textColor=&quot;?android:attr/textColorPrimary&quot;/&gt;
</code></pre>

<p>  这样，当指定了Theme之后，就会去相应的Style下面取对应的颜色值，从而呈现出不同的色彩。</p>

<h2 id="toc_3">设置Theme</h2>

<p>  在Manifest中设置是常见的方式。</p>

<p><code>&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;</code></p>

<p>  不过为了实现模式的切换，我们是在Activity的onCreate中进行的设置</p>

<pre><code class="language-java">protected void initTheme() {
    if (MusicPreferences.getInstance().isNightMode()) {
        setTheme(R.style.AppDarkTheme_NoActionBar);
    } else {
        setTheme(R.style.AppLightTheme_NoActionBar);
    }
}
</code></pre>

<p>  这样，通过给Activity设置不同的Theme，页面就能呈现出不同的颜色搭配。</p>

<h2 id="toc_4">问题</h2>

<p>  Style和Theme的方式实现简单，非常适用于模式较为固定的场景，如白天模式和夜间模式。<br/><br/>
  但是，轻听在白天的模式的时候的基础之上还有几种不同的主题色。</p>

<p>  简单聊一下主题色。<br/><br/>
  主题色，即colorPrimary，是根据品牌形象，为App定义的一个主色调，一般应用于AppBar。<br/><br/>
  同时，有一个强调色，即colorAccent，是用在Checkbox或下划线等需要给人以提示作用的地方，起辅助的作用。<br/><br/>
  还有一个颜色是colorPrimaryDark，就是比colorPrimary稍微深一些，主要用在状态栏。  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797127564468.png" alt="20171014150797127564468.png"/></p>

<p>  比如上图中，“蓝色”就是主题色，“红”色就是强调色。<br/><br/>
  主题色和强调色的色值可以不一样，也可以一样。在一般的设计中都是不同的。在轻听的设计中，为了突出品牌色，将强调色跟主题色统一设计成了一个颜色，所以你会看到，到处都是“绿”色。  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797135079962.png" alt="20171014150797135079962.png"/></p>

<p>  在强调色跟主题色统一的情况下，6个主题色，6套Style，似乎还可以接受。<br/><br/>
  但是，万一以后设计同学良心发现了呢？6在6套主题色的基础之上再出6套强调色，那可就是36个Style。如果以后的调色方式再更为灵活，如：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079715404497.png" alt="2017101415079715404497.png"/></p>

<p>  我数学不好，谁帮我算算，别忘了加上强调色还得再平方一下……<br/><br/>
  如果给每一个主题色都写一套Style，工作量会很大，而且不灵活。这个时候Style就玩不转了。<br/><br/>
  我们需要一种更为灵活的方案。  </p>

<h2 id="toc_5">动态配置主题色</h2>

<p>  动态配置主题色是借鉴了github开源控件app-theme-engine。在gradle中引入方式是:</p>

<pre><code class="language-text">compile(&#39;com.github.naman14:app-theme-engine:0.5.1@aar&#39;) {
    transitive = true
}
</code></pre>

<p>  由于找不到这个项目维护的地址，所以我们自己进行了扩展和优化。<br/><br/>
  主要由三个模块组成  </p>

<ul>
<li>颜色配置</li>
<li>颜色处理器</li>
<li>遍历逻辑控制器</li>
</ul>

<h2 id="toc_6">颜色配置</h2>

<p>  颜色配置主要负责存储颜色值。<br/><br/>
  因为这里存储数据较小，而且简单，所以用SharedPreference来存储，稍加封装就可以。</p>

<h2 id="toc_7">颜色处理器</h2>

<p>  颜色处理器Processor主要负责对每一个View的各种颜色进行设置。<br/><br/>
  首先，定义一个接口</p>

<pre><code class="language-java">public interface Processor&lt;T extends View, E&gt; {
    void process(@NonNull Context context, @Nullable String key, @Nullable T target, @Nullable E extra);
}
</code></pre>

<p>  process方法就是来处理视图颜色的。<br/><br/>
  其中target就是要传入的视图，这里使用泛型，在各个派生的Processor中具体实现。<br/><br/>
  以下是几个主要的Processor。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079716547714.png" alt="2017101415079716547714.png"/></p>

<p>  其中DefaultProcessor是默认Processor，可以处理绝大部分的变色情况。其他几种，如他们的名字一样，会额外再处理他们特定的情况。</p>

<p>Processor的处理方式分三步：</p>

<ul>
<li>给View设置tag</li>
<li>解析View的tag</li>
<li>根据具体的tag进行颜色的设置<br/>
  <br/>
  以DefaultProcessor为例。有一个TextView，我们要使他的文字颜色为强调色。<br/>
  首先，给View设置一个tag，”text_accent_color”。如果有多个tag，以逗号分隔。</li>
</ul>

<pre><code class="language-markup">&lt;TextView
    android:tag=&quot;text_accent_color&quot;
    /&gt;
</code></pre>

<p>  然后在process方法中将tag解析出来</p>

<pre><code class="language-java">public void process(@NonNull Context context, @Nullable String key, @Nullable View view, @Nullable Void extra) {
    if(view != null &amp;&amp; view.getTag() != null &amp;&amp; view.getTag() instanceof String) {
        String tag = (String)view.getTag();
        if(tag.contains(&quot;,&quot;)) {
            String[] splitTags = tag.split(&quot;,&quot;);
            int len = splitTags.length;

            for(int i = 0; i &lt; len; ++i) {
                String part = splitTags[i];
                processTagPart(context, view, part, key);
            }
        } else {
            processTagPart(context, view, tag, key);
        }

    }
}
</code></pre>

<p>  这里会根据分隔符（逗号）来对tag的数量进行解析，然后依次根据每个tag依次处理。<br/><br/>
  在处理方法processTagPart中，会找到”text_accent_color”相对应的处理逻辑</p>

<pre><code class="language-java">if (view instanceof  TextView) {
    ((TextView) view).setTextColor(Config.accentColor(context, key));
}
</code></pre>

<p>  Config.accentColor(context, key)的作用就是从颜色配置模块中读取当前的强调色。<br/><br/>
  其他一些稍微复杂一点的情况，则可以使用相对应的Processor去进行特殊的处理。<br/><br/>
  例如，ViewPagerProcessor。ViewPager在滑动边界的时候会有一个边界反馈的效果，如下图：  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797172826663.png" alt="20171014150797172826663.png"/></p>

<p>  这里需要特殊处理一下。ViewPager中，负责两个边缘效果的是EdgeEffectCompat。</p>

<pre><code class="language-java">private EdgeEffectCompat mLeftEdge;
private EdgeEffectCompat mRightEdge;
  EdgeEffectCompat是一个对系统版本做兼容性处理的类，里面有真正的边缘效果模块EdgeEffect

public final class EdgeEffectCompat {
    private Object mEdgeEffect;
}
</code></pre>

<p>  注意到，这两处都是私有的，所以我们必须通过两次反射来获取EdgeEffect，然后更改颜色。<br/><br/>
  首先，通过反射获取ViewPager的左右EdgeEffectCompat。</p>

<pre><code class="language-java">public static void setEdgeGlowColor(@NonNull ViewPager viewPager, @ColorInt int color) {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        try {
            Field edgeLeft = ViewPager.class.getDeclaredField(&quot;mLeftEdge&quot;);
            edgeLeft.setAccessible(true);
            Field edgeRight = ViewPager.class.getDeclaredField(&quot;mRightEdge&quot;);
            edgeRight.setAccessible(true);
            EdgeEffectCompat ee = (EdgeEffectCompat)edgeLeft.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
            ee = (EdgeEffectCompat)edgeRight.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>  然后再获取真正的EdgeEffect，并更改颜色。</p>

<pre><code class="language-java">private static void setEdgeGlowColor(@NonNull EdgeEffectCompat edgeEffect, @ColorInt int color) throws Exception {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        Field field = EdgeEffectCompat.class.getDeclaredField(&quot;mEdgeEffect&quot;);
        field.setAccessible(true);
        EdgeEffect effect = (EdgeEffect) field.get(edgeEffect);
        if (effect != null) {
            effect.setColor(color);
        }
    }
}
</code></pre>

<p>  这样边缘效果的颜色就修改好啦。</p>

<h2 id="toc_8">遍历逻辑</h2>

<p>  遍历逻辑控制器主要负责对整个页面的所有View进行遍历，并进行颜色处理。<br/>
  以下是遍历逻辑：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150797182427607.png" alt="20171014150797182427607.png"/></p>

<ul>
<li>初始化Processor</li>
</ul>

<pre><code class="language-java">private static void initProcessors() {
    mProcessors = new HashMap();
    mProcessors.put(&quot;[default]&quot;, new DefaultProcessor());
    mProcessors.put(ScrollView.class.getName(), new MusicScrollViewProcessor());
    mProcessors.put(ListView.class.getName(), new MusicListViewProcessor());
    mProcessors.put(RecyclerView.class.getName(), new MusicRecyclerViewProcessor());
    mProcessors.put(Toolbar.class.getName(), new MusicToolbarProcessor());
    mProcessors.put(NavigationView.class.getName(), new MusicNavigationViewProcessor());
    mProcessors.put(TabLayout.class.getName(), new MusicTabLayoutProcessor());
    mProcessors.put(ViewPager.class.getName(), new MusicViewPagerProcessor());
}
</code></pre>

<p>  将各Processor实例化后存入HashMap，key为类名。</p>

<ul>
<li><p>开始刷新的时机是onStart，因为这个时候布局已经基本初始化完毕。我们会判断Activity之前是否start过，避免重复的进行处理。至于在此之后生成的布局，会单独对其进行一次刷新。</p></li>
<li><p>从流程图中可以看出，在处理ContentView之前，我们会单独处理几个特殊的布局。<br/><br/>
StatusBar是顶部状态栏，NavigationBar是底部导航栏，有时我们会希望让这两处也兼容主题色。<br/><br/>
    如果用到ActionBar，也需要处理一下。不过MD的实现中，一般都是NoActionBar的，而用我们自己布局的ToolBar来代替。<br/><br/>
    在有侧边栏的页面中，根布局一般都是DrawerLayout，在侧边栏滑出的时候，可以设置DrawerLayout的状态栏颜色。  </p></li>
<li><p>找我们自己的根布局：ContentView<br/><br/>
ContentView就是我们用setContentView设置的布局，它上面还有ContentParent，DecorView，Window。<br/><br/>
  直接根据资源id找？不现实，因为每个Activity的ContentView资源id基本都不一样的。<br/><br/>
  这里采取一种迂回的方式，先找到ContentView的父布局ContentParent。<br/><br/>
  我们看setContentView的代码：  </p></li>
</ul>

<pre><code class="language-java">@Override
public void setContentView(int resId) {
    ensureSubDecor();
    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);
    contentParent.removeAllViews();
    LayoutInflater.from(mContext).inflate(resId, contentParent);
    mOriginalWindowCallback.onContentChanged();
}
</code></pre>

<p>  可以看到，实际上ContentParent的资源id是固定的：android.R.id.content。<br/><br/>
  系统会先把ContentParent的子视图清除，然后通过LayoutInflater的inflate方法将我们指定布局的视图解析出来并添加到ContentParent中。<br/><br/>
  那么我们就可以根据android.R.id.content先找到ContentParent，进而找到ContentView<br/><br/>
  </p>

<pre><code class="language-java">ViewGroup contentView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);
</code></pre>

<ul>
<li>获取Processor</li>
</ul>

<p>  根据View的类名获取Processor</p>

<pre><code class="language-java">Processor processor = mProcessors.get(viewClass.getName());
if(processor != null) {
    return processor;
} else {
    Class current = viewClass;

    do {
        current = current.getSuperclass();
        if(current == null) {
            break;
        }

        processor = mProcessors.get(current.getName());
    } while(processor == null);

    if (processor == null) {
        mProcessors.get(&quot;[default]&quot;)
    }

    return processor;
}
</code></pre>

<p>  从HashMap中获取对应的Processor，如果找不到则根据父类的名字查找。找到之后就可以调用process方法进行处理。</p>

<ul>
<li>遍历</li>
</ul>

<p>  这里会从ContentView开始进行深度优先遍历，处理所有的视图。<br/><br/>
  有一些特殊的ViewGroup不需要遍历其子布局，例如TabLayout，因为其自己的方法已经满足绝大部分的情况。</p>

<h2 id="toc_9">结语</h2>

<p>  以上，就是两种变色方案的具体实现。</p>

<ul>
<li>自定义Style和Theme实现简单，整洁，适用于模式较为固定的场景。</li>
<li>动态配置主题色实现起来略微复杂，但是比较灵活，适用于主题色较多的场景。</li>
</ul>

<p>  将这两种方案结合，就实现了轻听的变色。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870570.html">
                
                  <h1>Android-自定义锁屏页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、为什么需要自定义锁屏页</h2>

<p>　　锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。<br/>
　　当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）：</p>

<ol>
<li>点亮手机屏幕</li>
<li>解开系统锁屏</li>
<li>打开音乐播放器</li>
<li>切歌再熄灭屏幕</li>
</ol>

<p>　　这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。</p>

<h2 id="toc_1">二、自定义锁屏页的基本原理</h2>

<p>　　然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。<br/><br/>
　　Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795013363128.png" alt="20171014150795013363128.png"/></p>

<p>道理很简单，我们这里需要讨论的是细节。</p>

<h3 id="toc_2">广播注册</h3>

<p>　　Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册：</p>

<pre><code class="language-java">IntentFilter mSereenOffFilter = new IntentFilter();
mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);
registerReceiver(mScreenOffReveiver,mScreenOffFilter);
</code></pre>

<p>　　对应的BroadcastReceiver定义如下：</p>

<pre><code class="language-java">private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver(){
    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void onReceive(Context context,Intent intent){
        if(intent.getAction().equals(NOTIFY_SCREEN_OFF)){
            Intent mLockIntent = new Intent(context, LockScreenActivity.class);
            mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            startActivity(mLockIntent);
        }
    }
}
</code></pre>

<p>　　关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。<br/>
　　标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。</p>

<h3 id="toc_3">Activity设置</h3>

<p>　　锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。<br/><br/>
　　典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下：<br/>
　　</p>

<pre><code class="language-java">KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock(&quot;CustomLockScreen&quot;);
mKeyguardLock.disableKeyguard();
</code></pre>

<p>　　其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。<br/><br/>
　　上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能：</p>

<pre><code class="language-java"> getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
 getWindow().addFlags(WindowManager.LayoutParams.FLAG_OW_WHEN_LOCKED);
</code></pre>

<p>　　FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限：</p>

<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot;/&gt;
</code></pre>

<h3 id="toc_4">屏蔽按键</h3>

<p>　　当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。<br/><br/>
　　Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽：<br/>
　　</p>

<pre><code class="language-java">public boolean onKeyDown(int keyCode, KeyEvent event){
    int key = event.getKeyCode();
    switch(key){
        case KeyEvent.KEYCODE_BACK:{
            return true;
        }
        case KeyEvent.KEYCODE_MENU:{
            return true;
        }
    }
    return super.onKeyDown(keyCode,event);
}
</code></pre>

<p>　　Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。</p>

<h3 id="toc_5">划屏解锁</h3>

<p>　　做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。<br/><br/>
　　划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。<br/><br/>
　　为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795122322931.png" alt="20171014150795122322931.png"/></p>

<p>mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现：</p>

<pre><code class="language-java">@Override
public boolean onTouchEvent(MotionEvent event){
    final int action = event.getAction();
    final float nx = event.getX();
    switch(action){
        case MotionEvent.ACTION_DOWN:
            mStartX = nx;
            onAnimationEnd();
        case MotionEvent.ACTION_MOVE:
            handleMoveView(nx);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            doTriggerEvent(nx);
            break;
    }
    return true;
}
</code></pre>

<p>　　其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下：<br/>
　　</p>

<pre><code class="language-java">private void handleMoveView(float x){
    float movex = x - mStartX;
    if(movex &lt; 0)
        movex = 0;
    mMoveView.setTranslationX(movex);
    
    float mWidthFloat = (float) mWidth; // 屏幕显示宽度
    if(getBackground() != null){
        getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200));  //初始透明度的值为200
    }
}
</code></pre>

<p>　　在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。<br/><br/>
　　此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。</p>

<pre><code class="language-java">private void doTriggerEvent(float x){
    float movex = x - mStartX;
    if(movex &gt; (mWidth * 0.4)){
        moveMoveView(mWidth - mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉
    } else {
        moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖
    }
}

private void moveMoveView(float to,boolean exit){
    ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, &quot;translationX&quot;,to);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
        @Override
        public void onAnimationUpdate(new ValueAnimator animation){
            if(getBackground() != null){
                getBackground().setAlpha((int)(((float)mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200));
            }
        }
    });//随意动动画背景更新背景透明度
    animator.setDuration(250).start();
    if(exit){
        animator.addListener(new AnimatorListenerAdapter(){
            @Override
            public void onAnimationEnd(Animator animation){
                mainHandler.obtainMessage(LockScreenAcitvity.MSG_LAUNCH_HOME).sendToTarget();
                super.onAnimationEnd(animation);
            }
        });
    }//监听动画结束，利用Handler通知Activity退出
}
</code></pre>

<p>　　当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图：</p>

<h2 id="toc_6">三、透明栏与沉浸模式</h2>

<p>　　沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。</p>

<h3 id="toc_7">沉浸模式</h3>

<p>　　什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。<br/><br/>
　　之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。<br/>
　　这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。<br/><br/>
　　而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。<br/><br/>
　　Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html">参考</a>）</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795293493925.png" alt="20171014150795293493925.png"/></p>

<p>　　状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。<br/><br/>
　　一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表：<br/><br/>
　　<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795296598206.png" alt="20171014150795296598206.png"/></p>

<p>　　如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用：<br/>
　　</p>

<pre><code class="language-java">getWindow().getDecorView().getSystemUiVisibility(
    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
)
</code></pre>

<p>　　总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。<br/><br/>
　　需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。<br/><br/>
　　</p>

<pre><code class="language-java">@Override
public void onWindowFocusChanged(boolean hasFocus){
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus){
        getWindow().getDecorView().setSystemUiVisiblity(
            View.SYSTEM_UI_FLAG_LAYOUT_STABLE
            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        )
    }
}
</code></pre>

<p>　　此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下：</p>

<pre><code class="language-java">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>　　<br/>
手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。</p>

<h3 id="toc_8">透明栏</h3>

<p>　　什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079538614391.png" alt="2017101415079538614391.png"/></p>

<p>　　在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795389627420.png" alt="20171014150795389627420.png"/></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079539225975.png" alt="2017101415079539225975.png"/></p>

<p>　　所以，<strong>透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。</strong><br/><br/>
　　对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下：</p>

<pre><code class="language-java">if(Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT){
    Window window = getWindow();
    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
</code></pre>

<p>　　对于Android 5.0及以上版本，设置透明状态栏的方法如下：</p>

<pre><code class="language-java">if(Build.VERSION.SDK_INT &gt;= Build.VERSION.LOLLIPOP){
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TrANSLUCENT_STATUS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.addFlags(WindowManager.LayoutParams.Flag_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.setStatusBarColor(0);
}
</code></pre>

<p>　　除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。  </p>

<h2 id="toc_9">四、指纹解锁</h2>

<p>　　到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。</p>

<h3 id="toc_10">指纹识别无法解锁自定义锁屏页的问题</h3>

<p>　　持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。<br/><br/>
　　解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。<br/><br/>
　　因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码:</p>

<pre><code class="language-java">if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)){
    if(VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN){
        if(km.isKeyguardSecure()){
            MLog.d(TAG,&quot;KeyguardSecure!&quot;);
            Intent i = new Intent(NOTIFY_USER_PRESENT);
            context.sendBroadcast(i);
        }
    }
}
</code></pre>

<p>　　这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。<br/><br/>
　　这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。</p>

<h3 id="toc_11">自定义锁屏页下指纹识别无法使用的问题</h3>

<p>　　此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下：</p>

<pre><code class="language-java">private void startFingerPrintListening(){
    if(!isFingerprintAuthAvailable()){
        return;
    } else {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
            if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {
                mFingerprintManager.authenticate(null,mCancellationSignal,0,new FingerprintManager.AuthenticationCallback(){
                    @Override
                    public void onAuthenticationError(int errorCode,CharSequence errString){
                        super.onAuthenticationError(errorCode,errString);
                    }
                    @Override
                    public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result){
                        super.onAuthenticationSucceeded(result);
                        finish();
                    }
                    
                    @Override
                    public void onAuthenticationFailed(){
                        super.onAuthenticationFailed();
                    }
                },null);
                return;
            }
        }
    }
}
</code></pre>

<pre><code class="language-java">public boolean isFingerprintAuthAvailable(){
    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
        mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE);
        if(!mKeyguardManager.isKeyguardSecure()){
            return false;
        }
        if(checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED){
            mFingerprintManager = (FingerprintManager)getSystemService(Activity.FINGERPRINT_SERVICE);
            mCancellationSignal = new CancellationSignal();
            
            return mFingerprintManager.isHardwareDetected() &amp;&amp; mFingerprintManager.hasEnrolledFingerprints();
        } else {
         return false;
        }
    } else {
        return false;
    }
}
</code></pre>

<p>　　当然，不要忘记在Manifest中加入适当的权限：<br/>
　　</p>

<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.USEFINGERPRINT&quot;/&gt;
</code></pre>

<p>　　在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。<br/><br/>
　　指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法<br/>
　　</p>

<pre><code class="language-java">authenticate(FingerprintManager.CryptoObject crypto,CancellationSignal cancel,int flags,FingerprintManager.AuthenticationCallback callback,Handler handler)
</code></pre>

<p>　　其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。</p>

<h2 id="toc_12">五、总结</h2>

<p>　　通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870533.html">
                
                  <h1>Android-ImageView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ScaleType</h2>

<ul>
<li><p><code>android:scaleType=&quot;center&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerCrop&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</li>
<li>当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerInside&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitCenter&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitStart&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitEnd&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitXY&quot;</code></p>
<ul>
<li>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_5.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_7.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15663678647312.html">Docker学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662718181666.html">Android GRPC接入</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662693410122.html">Docker搭建Maven私服</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15639522586909.html">Kotlin为序列化类生成serialVersionUID</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15620327900428.html">Xposed开发</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
