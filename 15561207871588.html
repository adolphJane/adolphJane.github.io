<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android 自定义 LayoutInflate 实现酷炫引导页 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Android 自定义 LayoutInflate 实现酷炫引导页</h1>
     
        <div class="read-more clearfix">
          <span class="date">2017/10/4</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>今天，我们来搞点事情，自定义一个 LayoutInflate，搞点有意思的东西，实现一个酷炫的动画。<br/><br/>
首先，在自定义 LayoutInflate 之前，我们要先分析一下 LayoutInflate 的源码，了解了源码的实现方式，才能定制嘛~~~~<br/>
好了，怕你们无聊跑了，先放效果图出来镇贴</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150978927436317.gif" alt="20171104150978927436317.gif"/><figcaption>20171104150978927436317.gif</figcaption></figure></p>

<p>好了，效果看完了，</p>

<p>那就先从LayoutInflate的源码开始吧。</p>

<h2 id="toc_0">LayoutInflate</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201711041509789321695.jpg" alt="201711041509789321695.jpg"/><figcaption>201711041509789321695.jpg</figcaption></figure></p>

<p>还是提取一下关键信息吧。</p>

<ol>
<li><p>LayoutInflate 可以将 xml 文件解析成 View 对象。获取方式有两种getLayoutInflater()和getSystemService(Class)。</p></li>
<li><p>如果要创建一个新的 LayoutInflate去解析你自己的 xml，可以使用 cloneInContext，然后调用 setFactor()。</p></li>
</ol>

<p>好了，我们先来回顾一下平时我们是怎么把 xml 转换成 View 的吧。</p>

<ul>
<li>setContentView（）</li>
</ul>

<p>我们给 Activity 设置 布局 xml 都是调用这个方法，现在我们就来看看这个方法到底干了什么事。</p>

<pre class="line-numbers"><code class="language-java">public void setContentView(@LayoutRes int layoutResID) {
  getWindow().setContentView(layoutResID);
  initWindowDecorActionBar();
}
-----以上是 Activity 的方法，调用了 Window 的 steContentView
----手机上的 window 都是 PhoneWindow,就不饶弯了，直接看 PhoneWindow
----的setContentView方法。
public void setContentView(int layoutResID) {
    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
    // decor, when theme attributes and the like are crystalized. Do not check the feature
    // before this happens.
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        cb.onContentChanged();
    }
}
----在构造方法里面找到了mLayoutInflater 的赋值
public PhoneWindow(Context context) {
    super(context);
    mLayoutInflater = LayoutInflater.from(context);
}
</code></pre>

<ul>
<li>View.inflate()</li>
</ul>

<p>同样是调用了LayoutInflate.inflate()方法</p>

<pre class="line-numbers"><code class="language-java">public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) {
    LayoutInflater factory = LayoutInflater.from(context);
    return factory.inflate(resource, root);
}
</code></pre>

<ul>
<li>LayoutInflate.from(context).inflate()  同上</li>
</ul>

<p>我们项目中所有的 Xml 转 View 都离不开这三个方法吧，这三个方法最终调用的都还是 LayoutInflate 的 inflate 方法。</p>

<p>我们再来看看怎么获取到 LayoutInflate 的实例。<br/>
上面三个xml 解析成 view 的方法都是用LayoutInflate.from(context)来获取 LayoutInflate 实例的。</p>

<pre class="line-numbers"><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
   if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
   }
   return LayoutInflater;
}
</code></pre>

<p>看到这个代码有木有觉得很眼熟啊，我们的 ActivityService、WindowService、NotificationService等等各种 Service 是不是都这样获取的。而我们都知道这些系统服务都是单例的，并且在应用启动的时候系统为其初始化的。好了，撤远了~~</p>

<p>回过头来，我们继续看 LayoutInflate 源码。</p>

<ul>
<li>inflate(@LayoutRes int resource, @Nullable ViewGroup root)<br/>
这个方法就是将xml 文件转换成 View 的方法，我们项目中所有的 xml 解析调用的都是这个方法。第一个参数是 xml 资源 id，第二个方法是解析后的 View 是否要添加到 root view里面去。</li>
</ul>

<p>通过 Resources 获取 xml 解析器XmlResourceParser。</p>

<pre class="line-numbers"><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre>

<p>XmlResourceParser解析 xml，并且返回 view</p>

<pre class="line-numbers"><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        //写入跟踪信息，用于 Debug 相关，先不关心这个
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        //用于读取 xml 节点
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
          // Look for the root node.
          int type;
          //空信息直接跳过
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }
            //防错判断
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;);
            }
            //获取类名，比如说 TextView
          final String name = parser.getName();

          if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot; + name);
                System.out.println(&quot;**************************&quot;);
            }
            //如果标签是merge
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                //merge作为顶级节点的时候必须添加的 rootview
                throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;);
                }
                //递归方法去掉不必要的节点，为什么 merge 可以优化布局
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp 是根节点
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
               //如果不添加到 rootView 切 rootView 不等于空，则生成 LayoutParams
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

             if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // 解析子节点
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // 如果要添加到 rootview。。
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
          ex.initCause(e);
          throw ex;
       } catch (Exception e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
       } finally {
            // Don&#39;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        //返回解析结果
        return result;
    }
}
</code></pre>

<p>在这个方法中，判断了是否使用 merge 优化布局，然后通过createViewFromTag解析的顶级 xml 节点的 view，并且处理了是否添加解析的布局到 rootView。调用rInflateChildren方法去解析子 View 并且添加到顶级节点 temp 里面。最后返回解析结果。</p>

<p>我们先来看看 createViewFromTag</p>

<pre class="line-numbers"><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) {
    //获取命名空间
   if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
   }
   // 给 view 设置主题。现在知道为什么colorPrimary等 theme 属性会影响控件颜色了吧
   if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
   }
    //让 view 闪烁，可以参考http://blog.csdn.net/qq_22644219/article/details/69367150
    if (name.equals(TAG_1995)) {
        // Let&#39;s party like it&#39;s 1995!
        return new BlinkLayout(context, attrs);
    }

   try {
        View view;
        //优先调用了mFactory2的 oncreateView 方法，创建了 temp View
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }

        if (view == null &amp;&amp; mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }

        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf(&#39;.&#39;)) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
        throw e;

    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    }
}
</code></pre>

<p>这里我们可以知道，mFactor或者 mFactor 不为 null，则调用mFactor来创建 View，如果mFactor为 null 或者mFactor创建是失败，则最终调用LayoutInflate 的createView方法 来创建 View 的，它传入了 view 的 parent、name、context、 attrs。</p>

<p>接下来继续去看子 View 的解析rInflateChildren</p>

<pre class="line-numbers"><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {
//获取布局层级
    final int depth = parser.getDepth();
    int type;
    //没看懂没事，我们不是来纠结 xml 解析的
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        final String name = parser.getName();
        //requestFocus标签，http://blog.csdn.net/ouyang_peng/article/details/46957281
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
        } else if (TAG_TAG.equals(name)) {
        //tag标签，只能用于 api21以上，给父view 设置一个 tag
            parseViewTag(parser, parent, attrs);
       } else if (TAG_INCLUDE.equals(name)) {
       //include 节点
            if (parser.getDepth() == 0) {
                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
        //merge 节点
            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
        } else {
        //走了刚刚的那个方法，创建 view 设置 LayoutParams
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            //添加到付 view
            viewGroup.addView(view, params);
        }
    }

    if (finishInflate) {
        parent.onFinishInflate();
    }
}
</code></pre>

<p>我们来整理一下思路吧，调用步骤</p>

<ol>
<li>LayoutInflater 的静态方法 form 获取LayoutInflater实力</li>
<li>inflate解析 xml 资源</li>
<li>inflate 调用createViewFromTag创建了顶级view</li>
<li>inflate 调用rInflateChildren 创建所有子 view</li>
<li>rInflateChildren递归调用rInflate创建所有子 view。</li>
<li>rInflate通过调用createViewFromTag真正创建一个 view。</li>
<li>createViewFromTag优先使用 mFactory2、mFactory、mPrivateFactory来创建 View，如果创建失败，则最终调用createView方法来创建。创建的过程中用了parent,name,context,attrs等参数，然后运用反射的方法，创建出 View，</li>
</ol>

<p>因此，我们所有的 View 的构造方法都是被 <code>LayoutInflate</code> 的Factory调用创建出来的。<br/>
如果要自定义 <code>LayoutInflate</code> 解析，只需要给调用<code>LayoutInflate</code>的 <code>setFactory</code>设置我们自定义的 <code>Factory</code> 即可。<br/>
但是问题来了，LayoutInflate是系统服务，而且是单例，我们直接调用LayoutInflate的 setFactory 方法，会影响后期所有 view 的创建。</p>

<p>所以我们需要用到<code>LayoutInflate</code>的<code>cloneInContext</code>方法<code>clone</code>一个新的 <code>LayoutInflate</code>，然后再设置自己的 <code>Factory</code>。至于<code>LayoutInflate</code>是一个抽象类，<code>cloneInContext</code>是一个抽象方法，我们根本不用关心，因为我们直接用系统创建好的<code>LayoutInflate</code>即可。</p>

<p>好了，<code>LayoutInflate</code>的源码分析完了，接下来我们来分析动画了。</p>

<h2 id="toc_1">动画分析</h2>

<p>源码看了很久，我们再来重新看一遍动画吧</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150979091135893.gif" alt="20171104150979091135893.gif"/><figcaption>20171104150979091135893.gif</figcaption></figure></p>

<ol>
<li>翻页</li>
<li>翻页的时候天上的云，地上的建筑物移动速度和翻页速度不一样</li>
<li>不同的背景物移动速度不一样，最后一页背景物上下扩散</li>
<li>翻页的过程中，人一直在走路</li>
<li>最后一页人要消失。</li>
</ol>

<p>解决方案：</p>

<ol>
<li>ViewPager</li>
<li>给 viewPage设置PageChangeListener，在滚动的时候给各种 背景物体设置setTranslation。</li>
<li>不同的背景物设置不同的setTranslation系数。</li>
<li>人物走路用帧动画即可，在viewPage滑动处于SCROLL_STATE_DRAGGING状态的时候开启帧动画。</li>
<li>这个简单，监听onPageSelected，然后再设置人为 View.GONE即可。</li>
</ol>

<p>解决方案的问题：<br/><br/>
粗略数了一下，6个页面大概有50个左右的背景物。如果要一个一个去获取 id，然后再根据不同的 id，设置不同的滑动速度滑动方向，可能你会疯掉。</p>

<p>因此，我们需要想一个办法，去解决这个问题。可能有的童鞋会说，我写一个自定义 View，设置滑动速度系数属性就行了呀。这个方法可以实现，but，你还是需要一个一个去 <code>findViewbyid</code>。</p>

<p>那么，我们是不是可以给 xml 添加自定义标签，然后自定义解析。比如说，天上的云，滑进来的阻尼系数是0.4，滑出去的阻尼系数是0.6，只需要在 xml 里面设置好这两个参数，然后我们再在合适的时使用这两个参数即可啊。</p>

<h2 id="toc_2">自定义LayoutInflater.Factory</h2>

<p>咦，怎么变成自定义<code>LayoutInflater.Factory</code>了，哈哈哈，还记得刚刚<code>LayoutInflater</code>的源码分析么，View 的创建全部在<code>createViewFromTag</code>里面，而<code>createViewFromTag</code>优先使用 Factory 来 创建。然后我们来看看Factory到底是干嘛的。</p>

<p>Hook you can supply that is called when inflating from a LayoutInflater.<br/>
You can use this to customize the tag names available in your XML layout files.</p>

<ul>
<li>当LayoutInflater在解析布局的时候会被调用</li>
<li>可以用来读取 xml 中的自定义标签。</li>
</ul>

<p>这下迷惑都解开了吧，啊哈哈哈哈~~<br/><br/>
现在，我们就来定义这个 Factory<br/><br/>
思路很简单。  </p>

<ol>
<li>继承LayoutInflater.Factory2</li>
<li>实现抽象方法onCreateView</li>
<li>在onCreateView里面使用 LayoutInflate 的 createView方法创建View</li>
<li>创建成功之后，读取 view 的 attrs 属性，作为 tag 保持到 viewTag。</li>
</ol>

<p>关键代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
 //创建一个 View
    View view = createViewOrFailQuietly(name, context, attrs);

    //实例化完成
    if (view != null) {
        //获取自定义属性，通过标签关联到视图上
        setViewTag(view, context, attrs);
        //所有带有自定义属性的 View 保存起来，供动画切换的时候调用
        mParallaxView.getParallaxViews().add(view);
    }
    return view;
}
</code></pre>

<p>创建 view 的方法，这里注意一下，xml 标签里面系统的 view只有类名，自定义 view 是全路径。如：,而可以省略路径的 View 又分为 &quot;android.widget.&quot;和&quot;android.view.&quot;包下，所以对于只写缩写的 view，需要遍历这两个路径。</p>

<pre class="line-numbers"><code class="language-java">private View createViewOrFailQuietly(String name, Context context,
                                     AttributeSet attrs) {
    //1.自定义控件标签名称带点，所以创建时不需要前缀
    if (name.contains(&quot;.&quot;)) {
        createViewOrFailQuietly(name, null, context, attrs);
    }
    //2.系统视图需要加上前缀
    for (String prefix : sClassPrefix) {
        View view = createViewOrFailQuietly(name, prefix, context, attrs);
        if (view != null) {
            return view;
        }
    }
    return null;
}
private View createViewOrFailQuietly(String name, String prefix, Context context,
                                     AttributeSet attrs) {
    try {
        //通过系统的inflater创建视图，读取系统的属性
        return inflater.createView(name, prefix, attrs);
    } catch (Exception e) {
        return null;
    }
}
</code></pre>

<p>读取 attrs 里面的属性，给含有特点 attrs 属性的 view设置 tag 并保存起来。</p>

<pre class="line-numbers"><code class="language-java">private void setViewTag(View view, Context context, AttributeSet attrs) {
    //所有自定义的属性
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AnimationView);
    if (a != null &amp;&amp; a.length() &gt; 0) {
        //获取自定义属性的值
        ParallaxViewTag tag = new ParallaxViewTag();
       tag.xIn = a.getFloat(R.styleable.AnimationView_x_in, 0f);
       tag.xOut = a.getFloat(R.styleable.AnimationView_x_out, 0f);
       tag.yIn = a.getFloat(R.styleable.AnimationView_y_in, 0f);
       tag.yOut = a.getFloat(R.styleable.AnimationView_y_in, 0f);

       //index
       view.setTag(view.getId(), tag);
       a.recycle();
   }
}
</code></pre>

<p>好了，我们自定义LayoutInflater.Factory已经结束了，so，我们可以直接调用 LayoutInflate.cloneInContext(context)获取一个新的 LayoutInflate，然后再setFactor(customFactor)就可以了。代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(LayoutInflater original, ViewGroup container,
                         Bundle savedInstanceState) {
    Bundle args = getArguments();
    int layoutId = args.getInt(&quot;layoutId&quot;);
    LayoutInflater layoutInflater = original.cloneInContext(getActivity());
    layoutInflater.setFactory(new ParallaxFactory(layoutInflater, this));
    return layoutInflater.inflate(layoutId, null);
}
</code></pre>

<p>接下来的代码就不写了吧，就是监听 ViewPager 的滑动事件，获取当前滑出滑进页面的自定义了 attrs 属性的 View 列表，然后再根据滑出屏幕的比例*属性参数做 view 的 TranslationY/TranslationX 操作。<br/><br/>
这里我贴一下代码仓库地址吧，有兴趣的小伙伴可以把代码跑起来看一下  </p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdiamondlin2016%2FParallaxlayoutinflater">github传送门</a></p>

<p>看起来好像并没有什么卵用，就是秀了一波骚操作。写一个自定义 view，继承 ImageView，设置几个自定义 attrs 属性，再在构造方法里面把属性读出来保存到类变量，对外提供读取方法，然后同样监听 viewpager 的滑动就行了。</p>

<p>哈哈哈哈~~分享这篇文章的最终目的不是为了实现这个动画，就是想看一下 LayoutInflate 的源码，了解一下 xml 文件是怎么解析成 view的过程。。。。</p>

<h2 id="toc_3">已知 bug：</h2>

<p>v4的版本升级到19.1.0之后动画会失效<br/><br/>
引入appcompat包会报 xml 解析错误。  </p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15561207871631.html" 
          title="Previous Post: Android 使用 Palette 让你的 UI 色彩与内容更贴合">&laquo; Android 使用 Palette 让你的 UI 色彩与内容更贴合</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15561207871543.html" 
          title="Next Post: Android 用贝塞尔曲线绘制酷炫轮廓背景">Android 用贝塞尔曲线绘制酷炫轮廓背景 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
