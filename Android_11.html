<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android%E6%BA%90%E7%A0%81.html">Android源码</a></li>
        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207869292.html">
                
                  <h1>EventBus 3.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>

<h2 id="toc_1">使用EventBus</h2>

<h3 id="toc_2">添加依赖库</h3>

<p><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;</code></p>

<h3 id="toc_3">注册</h3>

<p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre>

<h3 id="toc_4">订阅者</h3>

<p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:</p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre>

<p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br/>
我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>

<h3 id="toc_5">发布者</h3>

<p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>

<pre class="line-numbers"><code class="language-java">String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre>

<p>这样就OK了，你可以试下能否正常运行了！</p>

<h2 id="toc_6">原理初探</h2>

<p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>

<h3 id="toc_7">如果你post的是对象</h3>

<p>首先你需要定义一个类似pojo类：</p>

<pre class="line-numbers"><code class="language-java">public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre>

<h3 id="toc_8">然后你post的时候：</h3>

<p><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));</code></p>

<h3 id="toc_9">当然，你接收的方法也需要改为：</h3>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre>

<h2 id="toc_10">ThreadMode提供了四个常量：</h2>

<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>

<p>BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。<br/><br/>
Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>

<h2 id="toc_11">EventBus黏性事件</h2>

<p>EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加<code>sticky = true</code></p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h3 id="toc_12">发送粘性事件</h3>

<p><code>EventBus.getDefault().postSticky(new DataSynEvent());</code>  </p>

<h3 id="toc_13">对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除</h3>

<p><code>EventBus.getDefault().removeStickyEvent(new DataSynEvent());</code>  </p>

<h3 id="toc_14">或者调用移除所有粘性事件</h3>

<p><code>EventBus.getDefault().removeAllStickyEvents();</code>  </p>

<p>默认情况下，其为false。什么情况下使用sticky呢？<br/><br/>
当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。  </p>

<h2 id="toc_15">订阅事件的优先级</h2>

<p>事件的优先级类似广播的优先级，优先级越高优先获得消息</p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h2 id="toc_16">终止事件往下传递</h2>

<p>发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能<br/>
<code>EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递</code></p>

<h2 id="toc_17">建议</h2>

<p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>

<pre class="line-numbers"><code class="language-java">public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}
</code></pre>

<h2 id="toc_18">processor使用</h2>

<p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.<br/>
EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.<br/><br/>
其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br/><br/>
<figure><img src="media/15561207869292/15713067794323.jpg" alt=""/></figure></p>

<h3 id="toc_19">具体使用：在build.gradle中添加如下配置</h3>

<pre class="line-numbers"><code class="language-text">buildscript {
    dependencies {
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;
    }
}
apply plugin: &#39;com.neenbedankt.android-apt&#39;

dependencies {
    compile &#39;org.greenrobot:eventbus:3.0.0&#39;
    apt &#39;org.greenrobot:eventbus-annotation-processor:3.0.1&#39;
}
apt {
    arguments {
        eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot;
    }
}
</code></pre>

<h3 id="toc_20">使用索引</h3>

<p>此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。</p>

<pre class="line-numbers"><code class="language-java">/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();

        putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo(&quot;onDataSynEvent&quot;, com.whoislcj.testhttp.eventBus.DataSynEvent.class,
                    ThreadMode.MAIN, 100, false),
            new SubscriberMethodInfo(&quot;onDataSynEvent1&quot;, com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN,
                    0, true),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
</code></pre>

<p>添加索引到EventBus默认的单例中<br/><br/>
<code>EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</code>  </p>

<h3 id="toc_21">对比添加前后注册效率对比</h3>

<p>分别EventBus.getDefault().register(this);</p>

<ul>
<li>添加之前：前后用了9毫秒</li>
<li>添加之后：前后用了2毫秒</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869255.html">
                
                  <h1>GreenDao3.2.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。</p>

<p><figure><img src="media/15561207869255/15713066502027.jpg" alt=""/></figure></p>

<p>这个图对于理解greenDAO是必不可少的。</p>

<h2 id="toc_1">greenDAO特点</h2>

<ul>
<li>性能最大化，可能是Android平台上最快的ORM框架</li>
<li>易于使用的API</li>
<li>最小的内存开销</li>
<li>依赖体积小</li>
<li>支持数据库加密</li>
<li>强大的社区支持</li>
</ul>

<h2 id="toc_2">配置greenDAO</h2>

<h3 id="toc_3">在<code>app</code>的Gradle中配置：</h3>

<p><code>apply plugin: &#39;org.greenrobot.greendao&#39;</code>  </p>

<pre class="line-numbers"><code class="language-text">dependencies {
        compile &#39;org.greenrobot:greendao:3.2.0&#39;
}
</code></pre>

<h3 id="toc_4">在<code>project</code>的Gradle中配置：</h3>

<pre class="line-numbers"><code class="language-text">buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath &#39;org.greenrobot:greendao-gradle-plugin:3.2.1&#39; 
    }
}
</code></pre>

<h3 id="toc_5">在app的Gradle配置数据库版本等信息</h3>

<pre class="line-numbers"><code class="language-text">greendao {
    schemaVersion 1                         //对应当前数据库版本c
    daoPackage &#39;com.koma.greendao.gen&#39;  //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。
    targetGenDir &#39;src/main/java&#39;        //设置自动生成代码的目录
}
</code></pre>

<h2 id="toc_6">使用greenDAO</h2>

<h3 id="toc_7">使用流程</h3>

<p>在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图：   </p>

<p><figure><img src="media/15561207869255/15713066625628.jpg" alt=""/></figure></p>

<p>选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图：  </p>

<p><figure><img src="media/15561207869255/15713066721049.jpg" alt=""/></figure></p>

<p>Ps:新建一个实体类，对项目进行<code>Make Project</code>，成功之后会在daoPackage目录下自动生成代码</p>

<h3 id="toc_8">在项目中定义实体类</h3>

<pre class="line-numbers"><code class="language-java">@Entity
public class User  {
    @Id(autoincrement = true)
    private Long id;
    @Property(nameInDb = &quot;USERNAME&quot;)
    private String name;
    private int age;
}
</code></pre>

<h3 id="toc_9">注解：</h3>

<ul>
<li>@Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式
<ul>
<li>schema：告知GreenDao当前实体属于哪个schema</li>
<li>active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法</li>
<li>nameInDb：在数据库中使用的别名，默认使用的是实体的类名</li>
<li>indexes：定义索引，可以跨越多个列</li>
<li>createInDb：标记创建数据库表</li>
</ul></li>
<li>基础属性注解
<ul>
<li>@Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长</li>
<li>@Property——————————标识该属性在表中对应的列名称, nameInDb设置名称</li>
<li>@Transient——————————标识该属性将不会映射到表中，也就是没有这列</li>
<li>@NotNull——————————设置表中当前列的值不可为空</li>
</ul></li>
<li>索引注解
<ul>
<li>@Unique——————————向数据库列添加了一个唯一的约束</li>
<li>@Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes())</li>
</ul></li>
<li>关系注解
<ul>
<li>@ToMany——————————定义与多个实体对象的关系</li>
<li>@ToOne——————————定义与另一个实体（一个实体对象）的关系</li>
</ul></li>
<li>@Convert——————————指定自定义类型(@linkPropertyConverter)</li>
<li>@Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除</li>
<li>@JoinEntity——————————定义表连接关系</li>
<li>@JoinProperty——————————定义名称和引用名称属性关系</li>
<li>@Keep——————————注解的代码段在GreenDao下次运行时保持不变
<ul>
<li>注解实体类：默认禁止修改此类</li>
<li>注解其他代码段，默认禁止修改注解的代码段</li>
</ul></li>
<li>@OrderBy——————————指定排序</li>
</ul>

<h3 id="toc_10">初始化GreenDao</h3>

<p>一般建议在Application中初始化数据库  </p>

<pre class="line-numbers"><code class="language-java">private void setupDataBase(Context context){
    DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME);
    Database db = openHelper.getWritableDb();
    DaoMaster daoMaster = new DaoMaster(db);
    mDaoSession = daoMaster.new Session();
}

public static DaoSession getDaoSession(){
    return mDaoSession;
}
</code></pre>

<p><code>DevOpenHelper</code>有两个重载方法：  </p>

<ul>
<li><code>DevOpenHelper(Context context,String name)</code></li>
<li><code>DevOpenHelper(Context context,String name,CursorFactory factory)</code>
<code>context</code>上下文这个不用多说，<code>name</code>数据库的名字，<code>cursorFactory</code>游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。</li>
</ul>

<h3 id="toc_11">对数据库的增、删、改、查操作</h3>

<h4 id="toc_12">首先获得UserDao的对象</h4>

<p><code>UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao();</code></p>

<h4 id="toc_13">增：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);
userDao.insert(user);
insert(T entity)       当指定主键在表中存在时会发生异常
insertOrReplace(T entity)      当指定主键在表中存在时会覆盖数据
insertInTx(Iterable&lt;T&gt; entities)      批量插入数据
</code></pre>

<h4 id="toc_14">删：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);    
userDao.delete(user)
 
delete(T entity)       删除数据
deleteByKey(K key)     指定主键删除数据
deleteInTx(Iterable&lt;T&gt; entities)      批量删除数据
deleteByKeyInTx(Iterable&lt;K&gt; keys)      批量按数据删除数据        
deleteAll()    删除所有数据
</code></pre>

<h4 id="toc_15">改：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(id, name, age, studentId);
userDao.update(user);
 
update(T entity)       修改数据，主键需相同
updateInTx(Iterable&lt;T&gt; entities)      批量更新数据
</code></pre>

<h4 id="toc_16">查：</h4>

<pre class="line-numbers"><code class="language-java">userDao.load(id)
 
load(K key)    根据id查找数据
loadByRowId(long rowId)        根据行号查找数据
loadAll()      查找全部数据
</code></pre>

<h5 id="toc_17">查询功能</h5>

<p>GreeDAO提供了各种各种的查询API，参见<a href="http://greenrobot.org/greendao/documentation/queries/">http://greenrobot.org/greendao/documentation/queries/</a>  </p>

<p><figure><img src="media/15561207869255/15713066831882.jpg" alt=""/></figure></p>

<p>如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关：<br/><br/>
<figure><img src="media/15561207869255/15713066943832.jpg" alt=""/></figure></p>

<h5 id="toc_18">条件查询</h5>

<pre class="line-numbers"><code class="language-java">//查询所有数据  
public void queryAll() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().list();  
}  
  
//eq: equal 精确查询  名字等于jackie  
public void queryEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq(&quot;jackie&quot;)).unique();  
}  
  
//notEq: not equal 精确查询  名字不等于jackie  
public void queryNotEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq(&quot;jackie&quot;)).unique();  
}  
  
//like  模糊查询  名字以jackie开头  
public void queryLike() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie&quot;)).unique();  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).list();  
}  
  
//between 区间查询 年龄在20到30之间  
public void queryBetween() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list();  
}  
  
//gt: greater than 半开区间查询，年龄大于18  
public void queryGt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list();  
}  
  
//ge: greater equal 半封闭区间查询，年龄大于或者等于18  
public void queryGe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list();  
}  
  
//lt: less than 半开区间查询，年龄小于18  
public void queryLt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list();  
}  
  
//le: less equal 半封闭区间查询，年龄小于或者等于18  
public void queryLe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list();  
}  
  
//名字以jackie开头，年龄升序排序  
public void queryLikeAsc() {  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderAsc(PersonDao.Properties.Age).list();  
}  
  
//名字以jackie开头，年龄降序排序  
public void queryLikeDesc() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderDesc(PersonDao.Properties.Age).list();  
}  
</code></pre>

<p>当上述查询满足不了业务逻辑时，可以自定义查询语句：   </p>

<p><figure><img src="media/15561207869255/15713067068458.jpg" alt=""/></figure></p>

<h5 id="toc_19">多线程查询</h5>

<p>首先来看错误的方法：<br/><br/>
<figure><img src="media/15561207869255/15713067155848.jpg" alt=""/></figure></p>

<p>错误截图：<br/><br/>
<figure><img src="media/15561207869255/15713067289369.jpg" alt=""/></figure> </p>

<p>从上面可以看出，只能在创建Query对象的线程中调用查询方法！<br/><br/>
解决方法：<br/><br/>
<figure><img src="media/15561207869255/15713067386987.jpg" alt=""/></figure></p>

<h5 id="toc_20">一对一查询</h5>

<p><figure><img src="media/15561207869255/15713067480106.jpg" alt=""/></figure></p>

<h4 id="toc_21">一对一、一对多关系</h4>

<p>greenDAO目前只支持一对一和一对多关系，并不支持多对多关系  </p>

<h5 id="toc_22">一对一：</h5>

<pre class="line-numbers"><code class="language-java">private Long studentId;
@ToOne(joinProperty = &quot;studentId&quot;)
private Studentstudent;
</code></pre>

<pre class="line-numbers"><code class="language-java">@Generated(hash = 313494093)
public Student getStudent() {
    Long __key = this.studentId;
    if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) {
        final DaoSession daoSession = this.daoSession;
        if (daoSession == null) {
            throw new DaoException(&quot;Entity is detached from DAO context&quot;);
        }
        StudentDao targetDao = daoSession.getStudentDao();
        Student studentNew = targetDao.load(__key);
        synchronized (this) {
            student = studentNew;
            student__resolvedKey = __key;
        }
    }
    return student;
}
</code></pre>

<p>使用<code>@ToOne</code>标记，<code>joinProperty</code>指定一个字段，如果没有定义，会自动生成一个字段，<code>get</code>方法时自动生成的，使用<code>@Generated</code>标记，代表自动生成的，无需动代码。</p>

<h5 id="toc_23">一对多（有三种映射形式）</h5>

<pre class="line-numbers"><code class="language-java">@ToMany(referencedJoinProperty = &quot;teacherId&quot;)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>referencedJoinProperty</code>：指定目标实体中与源实体相对应的外键。</p>

<pre class="line-numbers"><code class="language-java">@ToMany(joinProperties = {
        @JoinProperty(name=&quot;studentTag&quot;,referencedName = &quot;teacherTag&quot;)
})
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>JoinProperty</code>: 对于复杂一点的关系可以定义一组<code>@JoinProperty</code>注解。每个<code>@JoinProperty</code>注解都需要有源实体中的源属性和对应实体中的引用属性。</p>

<pre class="line-numbers"><code class="language-java">@ToMany
@JoinEntity(
        entity = Teacher.class,
        sourceProperty = &quot;teacherId&quot;,
        targetProperty = &quot;id&quot;
)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p>@JoinEntity：在做NM多对多映射的时候使用</p>

<h4 id="toc_24">数据库的升级</h4>

<p>数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。</p>

<pre class="line-numbers"><code class="language-java">/** WARNING: Drops all table on Upgrade! Use only during development. */
public static class DevOpenHelper extends OpenHelper {
    public DevOpenHelper(Context context, String name) {
        super(context, name);
    }

    public DevOpenHelper(Context context, String name, CursorFactory factory) {
        super(context, name, factory);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {
        Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);
        dropAllTables(db, true);
        onCreate(db);
    }
}
</code></pre>

<p>第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承<code>OpenHelper</code>，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。</p>

<h5 id="toc_25">在project的gradle添加</h5>

<pre class="line-numbers"><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven { url &quot;https://jitpack.io&quot; }
    }
}
</code></pre>

<h5 id="toc_26">在app的gradle添加：</h5>

<p><code>compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0&#39;</code></p>

<h5 id="toc_27">新建一个类</h5>

<pre class="line-numbers"><code class="language-java">public class MySQLiteOpenHelper extends DaoMaster.OpenHelper{
    public MySQLiteOpenHelper(Contextcontext,Stringname){
        super(context,name);
    }
    public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) {
        super(context,name,factory);
    }
    @Override
    public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) {
        Log.d(&quot;SQLite&quot;,&quot;数据库从&quot;+oldVersion+&quot;升级到&quot;+newVersion);
        MigrationHelper.migrate(db,UserDao.class,StudentDao.class);
    }
}
</code></pre>

<p>使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。</p>

<h2 id="toc_28">实战</h2>

<p>下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下<br/><br/>
<figure><img src="media/15561207869255/15713067603164.jpg" alt=""/></figure></p>

<p>我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建  </p>

<h3 id="toc_29">一、创建Bean对象（表名和字段名）</h3>

<p>GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）  </p>

<pre class="line-numbers"><code class="language-java">@Entity
public class Shop{

    //表示为购物车列表
    public static final int TYPE_CART = 0x01;
    //表示为收藏列表
    public static final int TYPE_LOVE = 0x02;

    //不能用int
    @Id(autoincrement = true)
    private Long id;
    //商品名称
    @Unique
    private String name;
    //商品价格
    @Property(nameInDb = &quot;price&quot;)
    private String price;
    //已售数量
    private int sell_num;
    //图标url
    private String image_url;
    //商家地址
    private String address;
    //商品列表类型
    private int type;
}
</code></pre>

<p>之后进行<code>Make Project</code> <br/>
生成<code>Bean</code>实体的构造方法和<code>get</code>、<code>set</code>方法和<code>DaoMaster</code>、<code>DaoSession</code>、<code>DAOS</code>类</p>

<h3 id="toc_30">二、创建数据库</h3>

<pre class="line-numbers"><code class="language-java">public class BaseApplication extends Application {

    private static DaoSession daoSession;

    @Override
    public void onCreate() {
        super.onCreate();
        //配置数据库
        setupDatabase();
    }

    /**
     * 配置数据库
     */
    private void setupDatabase() {
        //创建数据库shop.db&quot;
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;shop.db&quot;, null);
        //获取可写数据库
        SQLiteDatabase db = helper.getWritableDatabase();
        //获取数据库对象
        DaoMaster daoMaster = new DaoMaster(db);
        //获取Dao对象管理者
        daoSession = daoMaster.newSession();
    }

    public static DaoSession getDaoInstant() {
        return daoSession;
    }
}
</code></pre>

<p>GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释  </p>

<ul>
<li><code>DevOpenHelper</code>：创建SQLite数据库的SQLiteOpenHelper的具体实现</li>
<li><code>DaoMaster</code>：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表</li>
<li><code>DaoSession</code>：管理所有的Dao对象，Dao对象中存在着增删改查等API</li>
</ul>

<p>由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得<br/><br/>
<code>ShopDao dao = daoSession.getShopDao();</code><br/><br/>
这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。</p>

<h3 id="toc_31">三、数据库的增删改查</h3>

<pre class="line-numbers"><code class="language-java">public class LoveDao {

    /**
     * 添加数据，如果有重复则覆盖
     *
     * @param shop
     */
    public static void insertLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop);
    }

    /**
     * 删除数据
     *
     * @param id
     */
    public static void deleteLove(long id) {
        BaseApplication.getDaoInstant().getShopDao().deleteByKey(id);
    }

    /**
     * 更新数据
     *
     * @param shop
     */
    public static void updateLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().update(shop);
    }

    /**
     * 查询条件为Type=TYPE_LOVE的数据
     *
     * @return
     */
    public static List&lt;Shop&gt; queryLove() {
        return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list();
    }

    /**
     * 查询全部数据
     */
    public static List&lt;Shop&gt; queryAll() {
        return BaseApplication.getDaoInstant().getShopDao().loadAll();
    }
}
</code></pre>

<p>GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍  </p>

<ul>
<li>增加单个数据
<ul>
<li><code>getShopDao().insert(shop);</code></li>
<li><code>getShopDao().insertOrReplace(shop);</code></li>
</ul></li>
<li>增加多个数据
<ul>
<li><code>getShopDao().insertInTx(shopList);</code></li>
<li><code>getShopDao().insertOrReplaceInTx(shopList);</code></li>
</ul></li>
<li>查询全部
<ul>
<li><code>List&lt; Shop&gt; list = getShopDao().loadAll();</code></li>
<li><code>List&lt; Shop&gt; list = getShopDao().queryBuilder().list();</code></li>
</ul></li>
<li>查询附加单个条件
<ul>
<li><code>.where()</code></li>
<li><code>.whereOr()</code></li>
</ul></li>
<li>查询附加多个条件
<ul>
<li><code>.where(, , ,)</code></li>
<li><code>.whereOr(, , ,)</code></li>
</ul></li>
<li>查询附加排序
<ul>
<li><code>.orderDesc()</code></li>
<li><code>.orderAsc()</code></li>
</ul></li>
<li>查询限制当页个数
<ul>
<li><code>.limit()</code></li>
</ul></li>
<li>查询总个数
<ul>
<li><code>.count()</code></li>
</ul></li>
<li>修改单个数据
<ul>
<li><code>getShopDao().update(shop);</code></li>
</ul></li>
<li>修改多个数据
<ul>
<li><code>getShopDao().updateInTx(shopList);</code></li>
</ul></li>
<li>删除单个数据
<ul>
<li><code>getTABUserDao().delete(user);</code></li>
</ul></li>
<li>删除多个数据
<ul>
<li><code>getUserDao().deleteInTx(userList);</code></li>
</ul></li>
<li>删除数据ByKey
<ul>
<li><code>getTABUserDao().deleteByKey();</code></li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/3/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869044.html">
                
                  <h1>Android ADB 命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">基本命令</h2>

<ul>
<li>进入指定设备 <code>adb -s serialNumber shell</code></li>
<li>查看版本 <code>adb version</code></li>
<li>查看日志 <code>adb logcat</code></li>
<li>查看设备 <code>adb devices</code></li>
<li>连接状态 <code>adb get-state</code></li>
<li>启动ADB服务 <code>adb start-server</code></li>
<li>停止ADB服务 <code>adb kill-server</code></li>
<li>电脑推送到手机 <code>adb push [local path] [remote path]</code></li>
<li>手机拉取到电脑 <code>adb pull [remote path] [local path]</code></li>
</ul>

<h2 id="toc_1">adb shell下的am 与 pm</h2>

<blockquote>
<p>注:am和pm命令必须先切换到adb shell模式下才能使用</p>
</blockquote>

<h3 id="toc_2">am</h3>

<p>am全称activity manager，你能使用am去模拟各种系统的行为，例如去启动一个activity，强制停止进程，发送广播进程，修改设备屏幕属性等等。当你在adb shell命令下执行am命令:</p>

<p><strong>am <command></strong></p>

<ul>
<li>启动app <code>am start -n {packageName}/.{activityName}</code></li>
<li>杀app的进程 <code>am kill &lt;packageName&gt;</code></li>
<li>强制停止一切 <code>am force-stop &lt;packageName&gt;</code></li>
<li>启动服务 <code>am startservice</code></li>
<li>停止服务 <code>am stopservice</code></li>
<li>打开简书 <code>am start -a android.intent.action.VIEW -d http://www.jianshu.cn/</code></li>
<li>拨打10086 <code>am start -a android.intent.action.CALL -d tel:10086</code></li>
</ul>

<h3 id="toc_3">pm</h3>

<p>pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：</p>

<p><strong>pm <command></strong></p>

<ul>
<li>列出手机所有的包名 <code>pm list packages</code></li>
<li>安装/卸载 <code>pm install/uninstall</code></li>
</ul>

<h2 id="toc_4">模拟用户事件</h2>

<ul>
<li><strong>文本输入:</strong> <code>adb shell input text &lt;string&gt;</code>
例:手机端输出demo字符串，相应指令：<code>adb shell input &quot;demo&quot;</code>.</li>
<li><strong>键盘事件：</strong> <code>input keyevent &lt;KEYCODE&gt;</code>，其中KEYCODE见本文结尾的附表
例:点击返回键，相应指令： <code>input keyevent 4</code>.</li>
<li><strong>点击事件：</strong> <code>input tap &lt;x&gt; &lt;y&gt;</code>
例: 点击坐标（500，500），相应指令： <code>input tap 500 500</code>.</li>
<li><strong>滑动事件：</strong> <code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; &lt;time&gt;</code>
例: 从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500</code>.<br/>
例: 200ms时间从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500 200</code>.</li>
</ul>

<h2 id="toc_5">logcat日志</h2>

<ul>
<li>显示包含的<code>logcat logcat \| grep &lt;str&gt;</code></li>
<li>显示包含，并忽略大小写的<code>logcat logcat \| grep -i &lt;str&gt;</code></li>
<li>读完所有log后返回，而不会一直等待 <code>logcat -d</code></li>
<li>清空log并退出 <code>logcat -c</code></li>
<li>打印最近的<code>count logcat -t &lt;count&gt;</code></li>
<li>格式化输出Log，其中format有如下可选值： <code>logcat -v &lt;format&gt;</code>
<ul>
<li><strong>brief</strong> — 显示优先级/标记和原始进程的PID (默认格式)</li>
<li><strong>process</strong> — 仅显示进程PID</li>
<li><strong>tag</strong> — 仅显示优先级/标记</li>
<li><strong>thread</strong> — 仅显示进程：线程和优先级/标记</li>
<li><strong>raw</strong> — 显示原始的日志信息，没有其他的元数据字段</li>
<li><strong>time</strong> — 显示日期，调用时间，优先级/标记，PID</li>
<li><strong>long</strong> —显示所有的元数据字段并且用空行分隔消息内容</li>
</ul></li>
</ul>

<h2 id="toc_6">远程ADB</h2>

<p>为避免使用数据线，可通过wifi通信，前提是手机与PC处于同一局域网</p>

<ul>
<li><p><strong>启动方法:</strong> <code>adb tcpip 5555  //这一步，必须通过数据线把手机与PC连接后再执行</code><br/>
<code>adb connect &lt;手机IP&gt;</code></p></li>
<li><p>**停止方法: **<code>adb disconnect //断开wifi连接</code><br/>
<code>adb usb //切换到usb模式</code></p></li>
</ul>

<h2 id="toc_7">其他命令</h2>

<ul>
<li>查看当前 <code>ls</code></li>
<li>打印当前路径 <code>pwd</code></li>
<li>查看当前连接的设备 <code>adb devices</code></li>
<li>终止adb服务进程 <code>adb kill-server</code></li>
<li>重启adb服务进程 <code>adb start-server</code></li>
<li>PID是:8607 查看某个进程的日志 <code>adb logcat -v process |grep 8607</code></li>
<li>清理缓存 <code>logcat -c</code></li>
<li>打印xys标签log <code>adb logcat -s xys</code></li>
<li>打印192.168.56.101:5555设备里的xys标签log <code>adb -s 192.168.56.101:5555 logcat -s xys</code></li>
<li>打印在ActivityManager标签里包含start的日志 <code>adb logcat -s ActivityManager | findstr &quot;START&quot;</code>
<ul>
<li>&quot;-s&quot;选项 : 设置输出日志的标签, 只显示该标签的日志;</li>
<li>&quot;-f&quot;选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</li>
<li>&quot;-r&quot;选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</li>
<li>&quot;-n&quot;选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</li>
<li>&quot;-v&quot;选项 : 设置日志的输出格式, 注意只能设置一项;</li>
<li>&quot;-c&quot;选项 : 清空所有的日志缓存信息;</li>
<li>&quot;-d&quot;选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;</li>
<li>&quot;-t&quot;选项 : 输出最近的几行日志, 输出完退出, 不阻塞;</li>
<li>&quot;-g&quot;选项 : 查看日志缓冲区信息;</li>
<li>&quot;-b&quot;选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;</li>
<li>&quot;-B&quot;选项 : 以二进制形式输出日志;</li>
</ul></li>
<li>重启机器 <code>adb reboot</code></li>
<li>获取序列号 <code>adb get-serialno</code></li>
<li>重启到bootloader，即刷机模式 <code>adb reboot bootloader</code></li>
<li>重启到recovery，即恢复模式 <code>adb reboot recovery</code></li>
<li>安装APK：<code>adb install &lt;apkfile&gt; //比如：adb install baidu.apk</code></li>
<li>安装apk到sd卡： <code>adb install -s &lt;apkfile&gt; // 比如：adb install -s baidu.apk</code></li>
<li>卸载APK：<code>adb uninstall &lt;package&gt; //比如：adb uninstall com.baidu.search</code></li>
<li>获取机器MAC地址 <code>adb shell cat /sys/class/net/wlan0/address</code></li>
<li>启动应用：<code>adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt; 例如:adb shell am start -n yf.o2o.store/yf.o2o.store.activity.LoginActivity</code></li>
<li>查看占用内存排序 <code>adb shell top</code></li>
<li>查看占用内存前6的app： <code>adb shell top -m 6</code></li>
<li>刷新一次内存信息，然后返回：<code>adb shell top -n 1</code></li>
<li>查询各进程内存使用情况：<code>adb shell procrank</code></li>
<li>杀死一个进程：<code>adb shell kill [pid]</code></li>
<li>查看进程列表：<code>adb shell ps</code></li>
<li>查看指定进程状态：<code>adb shell ps -x [PID]</code></li>
<li>查看后台services信息： <code>adb shell service list</code></li>
<li>查看当前内存占用： <code>adb shell cat /proc/meminfo</code></li>
<li>查看IO内存分区：<code>adb shell cat /proc/iomem</code></li>
<li>将system分区重新挂载为可读写分区：<code>adb remount</code></li>
<li>从本地复制文件到设备： <code>adb push &lt;local&gt; &lt;remote&gt;</code></li>
<li>从设备复制文件到本地： <code>adb pull &lt;remote&gt; &lt;local&gt;</code></li>
<li>列出目录下的文件和文件夹，等同于dos中的dir命令：<code>adb shell ls</code></li>
<li>进入文件夹，等同于dos中的cd 命令：<code>adb shell cd &lt;folder&gt;</code></li>
<li>重命名文件： <code>adb shell rename path/oldfilename path/newfilename</code></li>
<li>删除system/avi.apk： <code>adb shell rm /system/avi.apk</code></li>
<li>删除文件夹及其下面所有文件：<code>adb shell rm -r &lt;folder&gt;</code></li>
<li>移动文件：<code>adb shell mv path/file newpath/file</code></li>
<li>设置文件权限：<code>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</code></li>
<li>新建文件夹：<code>adb shell mkdir path/foldelname</code></li>
<li>查看文件内容：<code>adb shell cat &lt;file&gt;</code></li>
<li>查看wifi密码：<code>adb shell cat /data/misc/wifi/*.conf</code></li>
<li>清除log缓存：<code>adb logcat -c</code></li>
<li>查看bug报告：<code>adb bugreport</code></li>
<li>获取设备名称：<code>adb shell cat /system/build.prop</code></li>
<li>查看ADB帮助：<code>adb help</code></li>
<li>跑monkey：
<ul>
<li><code>adb shell monkey -v -p your.package.name 500</code></li>
<li><code>adb -s 192.168.244.151:5555 shell monkey -v -p com.bolexim 500</code></li>
</ul></li>
</ul>

<h2 id="toc_8">附表</h2>

<p>下表中， 箭头左边为keycode值，箭头右边为keycode的含义，部分用中文标注</p>

<table>
<thead>
<tr>
<th style="text-align: left">KeyCode</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">0</td>
<td style="text-align: left">KEYCODE_UNKNOWN</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">1</td>
<td style="text-align: left">KEYCODE_MENU</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">2</td>
<td style="text-align: left">KEYCODE_SOFT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">3</td>
<td style="text-align: left">KEYCODE_HOME</td>
<td style="text-align: left">Home键</td>
</tr>
<tr>
<td style="text-align: left">4</td>
<td style="text-align: left">KEYCODE_BACK</td>
<td style="text-align: left">返回键</td>
</tr>
<tr>
<td style="text-align: left">5</td>
<td style="text-align: left">KEYCODE_CALL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6</td>
<td style="text-align: left">KEYCODE_ENDCALL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">7</td>
<td style="text-align: left">KEYCODE_0</td>
<td style="text-align: left">数字键0</td>
</tr>
<tr>
<td style="text-align: left">8</td>
<td style="text-align: left">KEYCODE_1</td>
<td style="text-align: left">数字键1</td>
</tr>
<tr>
<td style="text-align: left">9</td>
<td style="text-align: left">KEYCODE_2</td>
<td style="text-align: left">数字键2</td>
</tr>
<tr>
<td style="text-align: left">10</td>
<td style="text-align: left">KEYCODE_3</td>
<td style="text-align: left">数字键3</td>
</tr>
<tr>
<td style="text-align: left">11</td>
<td style="text-align: left">KEYCODE_4</td>
<td style="text-align: left">数字键4</td>
</tr>
<tr>
<td style="text-align: left">12</td>
<td style="text-align: left">KEYCODE_5</td>
<td style="text-align: left">数字键5</td>
</tr>
<tr>
<td style="text-align: left">13</td>
<td style="text-align: left">KEYCODE_6</td>
<td style="text-align: left">数字键6</td>
</tr>
<tr>
<td style="text-align: left">14</td>
<td style="text-align: left">KEYCODE_7</td>
<td style="text-align: left">数字键7</td>
</tr>
<tr>
<td style="text-align: left">15</td>
<td style="text-align: left">KEYCODE_8</td>
<td style="text-align: left">数字键8</td>
</tr>
<tr>
<td style="text-align: left">16</td>
<td style="text-align: left">KEYCODE_9</td>
<td style="text-align: left">数字键9</td>
</tr>
<tr>
<td style="text-align: left">17</td>
<td style="text-align: left">KEYCODE_STAR</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">18</td>
<td style="text-align: left">KEYCODE_POUND</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">19</td>
<td style="text-align: left">KEYCODE_DPAD_UP</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">20</td>
<td style="text-align: left">KEYCODE_DPAD_DOWN</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">21</td>
<td style="text-align: left">KEYCODE_DPAD_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">22</td>
<td style="text-align: left">KEYCODE_DPAD_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">23</td>
<td style="text-align: left">KEYCODE_DPAD_CENTER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">24</td>
<td style="text-align: left">KEYCODE_VOLUME_UP</td>
<td style="text-align: left">音量键+</td>
</tr>
<tr>
<td style="text-align: left">25</td>
<td style="text-align: left">KEYCODE_VOLUME_DOWN</td>
<td style="text-align: left">音量键-</td>
</tr>
<tr>
<td style="text-align: left">26</td>
<td style="text-align: left">KEYCODE_POWER</td>
<td style="text-align: left">Power键</td>
</tr>
<tr>
<td style="text-align: left">27</td>
<td style="text-align: left">KEYCODE_CAMERA</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">28</td>
<td style="text-align: left">KEYCODE_CLEAR</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">29</td>
<td style="text-align: left">KEYCODE_A</td>
<td style="text-align: left">字母键A</td>
</tr>
<tr>
<td style="text-align: left">30</td>
<td style="text-align: left">KEYCODE_B</td>
<td style="text-align: left">字母键B</td>
</tr>
<tr>
<td style="text-align: left">31</td>
<td style="text-align: left">KEYCODE_C</td>
<td style="text-align: left">字母键C</td>
</tr>
<tr>
<td style="text-align: left">32</td>
<td style="text-align: left">KEYCODE_D</td>
<td style="text-align: left">字母键D</td>
</tr>
<tr>
<td style="text-align: left">33</td>
<td style="text-align: left">KEYCODE_E</td>
<td style="text-align: left">字母键E</td>
</tr>
<tr>
<td style="text-align: left">34</td>
<td style="text-align: left">KEYCODE_F</td>
<td style="text-align: left">字母键F</td>
</tr>
<tr>
<td style="text-align: left">35</td>
<td style="text-align: left">KEYCODE_G</td>
<td style="text-align: left">字母键G</td>
</tr>
<tr>
<td style="text-align: left">36</td>
<td style="text-align: left">KEYCODE_H</td>
<td style="text-align: left">字母键H</td>
</tr>
<tr>
<td style="text-align: left">37</td>
<td style="text-align: left">KEYCODE_I</td>
<td style="text-align: left">字母键I</td>
</tr>
<tr>
<td style="text-align: left">38</td>
<td style="text-align: left">KEYCODE_J</td>
<td style="text-align: left">字母键J</td>
</tr>
<tr>
<td style="text-align: left">39</td>
<td style="text-align: left">KEYCODE_K</td>
<td style="text-align: left">字母键K</td>
</tr>
<tr>
<td style="text-align: left">40</td>
<td style="text-align: left">KEYCODE_L</td>
<td style="text-align: left">字母键L</td>
</tr>
<tr>
<td style="text-align: left">41</td>
<td style="text-align: left">KEYCODE_M</td>
<td style="text-align: left">字母键M</td>
</tr>
<tr>
<td style="text-align: left">42</td>
<td style="text-align: left">KEYCODE_N</td>
<td style="text-align: left">字母键N</td>
</tr>
<tr>
<td style="text-align: left">43</td>
<td style="text-align: left">KEYCODE_O</td>
<td style="text-align: left">字母键O</td>
</tr>
<tr>
<td style="text-align: left">44</td>
<td style="text-align: left">KEYCODE_P</td>
<td style="text-align: left">字母键P</td>
</tr>
<tr>
<td style="text-align: left">45</td>
<td style="text-align: left">KEYCODE_Q</td>
<td style="text-align: left">字母键Q</td>
</tr>
<tr>
<td style="text-align: left">46</td>
<td style="text-align: left">KEYCODE_R</td>
<td style="text-align: left">字母键R</td>
</tr>
<tr>
<td style="text-align: left">47</td>
<td style="text-align: left">KEYCODE_S</td>
<td style="text-align: left">字母键S</td>
</tr>
<tr>
<td style="text-align: left">48</td>
<td style="text-align: left">KEYCODE_T</td>
<td style="text-align: left">字母键T</td>
</tr>
<tr>
<td style="text-align: left">49</td>
<td style="text-align: left">KEYCODE_U</td>
<td style="text-align: left">字母键U</td>
</tr>
<tr>
<td style="text-align: left">50</td>
<td style="text-align: left">KEYCODE_V</td>
<td style="text-align: left">字母键V</td>
</tr>
<tr>
<td style="text-align: left">51</td>
<td style="text-align: left">KEYCODE_W</td>
<td style="text-align: left">字母键W</td>
</tr>
<tr>
<td style="text-align: left">52</td>
<td style="text-align: left">KEYCODE_X</td>
<td style="text-align: left">字母键X</td>
</tr>
<tr>
<td style="text-align: left">53</td>
<td style="text-align: left">KEYCODE_Y</td>
<td style="text-align: left">字母键Y</td>
</tr>
<tr>
<td style="text-align: left">54</td>
<td style="text-align: left">KEYCODE_Z</td>
<td style="text-align: left">字母键Z</td>
</tr>
<tr>
<td style="text-align: left">55</td>
<td style="text-align: left">KEYCODE_COMMA</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">56</td>
<td style="text-align: left">KEYCODE_PERIOD</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">57</td>
<td style="text-align: left">KEYCODE_ALT_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">58</td>
<td style="text-align: left">KEYCODE_ALT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">59</td>
<td style="text-align: left">KEYCODE_SHIFT_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">60</td>
<td style="text-align: left">KEYCODE_SHIFT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">61</td>
<td style="text-align: left">KEYCODE_TAB</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">62</td>
<td style="text-align: left">KEYCODE_SPACE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">63</td>
<td style="text-align: left">KEYCODE_SYM</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">64</td>
<td style="text-align: left">KEYCODE_EXPLORER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">65</td>
<td style="text-align: left">KEYCODE_ENVELOPE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">66</td>
<td style="text-align: left">KEYCODE_ENTER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">67</td>
<td style="text-align: left">KEYCODE_DEL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">68</td>
<td style="text-align: left">KEYCODE_GRAVE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">69</td>
<td style="text-align: left">KEYCODE_MINUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">70</td>
<td style="text-align: left">KEYCODE_EQUALS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">71</td>
<td style="text-align: left">KEYCODE_LEFT_BRACKET</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">72</td>
<td style="text-align: left">KEYCODE_RIGHT_BRACKET</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">73</td>
<td style="text-align: left">KEYCODE_BACKSLASH</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">74</td>
<td style="text-align: left">KEYCODE_SEMICOLON</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">75</td>
<td style="text-align: left">KEYCODE_APOSTROPHE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">76</td>
<td style="text-align: left">KEYCODE_SLASH</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">77</td>
<td style="text-align: left">KEYCODE_AT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">78</td>
<td style="text-align: left">KEYCODE_NUM</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">79</td>
<td style="text-align: left">KEYCODE_HEADSETHOOK</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">80</td>
<td style="text-align: left">KEYCODE_FOCUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">81</td>
<td style="text-align: left">KEYCODE_PLUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">82</td>
<td style="text-align: left">KEYCODE_MENU</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">83</td>
<td style="text-align: left">KEYCODE_NOTIFICATION</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">84</td>
<td style="text-align: left">KEYCODE_SEARCH</td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/3/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869006.html">
                
                  <h1>Mac安装配置appium</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。</p>

<h2 id="toc_1">一、安装Appium</h2>

<h3 id="toc_2">(二) 安装Homebrew</h3>

<ul>
<li><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;  #下载</code></li>
<li><code>$ brew update #更新</code></li>
<li><code>$ brew -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_3">(三) 安装Node.js</h3>

<p>使用homebrew来安装Node.js </p>

<ul>
<li><code>$ brew install node #安装</code></li>
<li><code>$ node -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_4">(四) 安装npm</h3>

<ul>
<li><code>$ brew install npm</code></li>
</ul>

<h3 id="toc_5">(五) 安装appium服务端</h3>

<p>推荐使用cnpm来安装：<a href="https://npm.taobao.org/">淘宝 NPM 镜像</a> 10分钟同步npmjs.org镜像，使用方式和npm完全一致</p>

<ul>
<li><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li><code>$ npm view appium versions #查看appium所有的版本号</code></li>
<li><code>$ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor</code></li>
</ul>

<h3 id="toc_6">(六) 检查appium环境检测</h3>

<p>在环境监测中打叉的就是没安装成功或者环境没有配置完全的</p>

<ul>
<li><code>appium-doctor</code></li>
</ul>

<h4 id="toc_7">1、appium环境常见问题解决</h4>

<h5 id="toc_8">(1) Xcode Command Line Tools are NOT installed!</h5>

<pre class="line-numbers"><code class="language-text">- `xcode-select --install   #按照提示安装即可`
</code></pre>

<h5 id="toc_9">(2) Carthage was NOT found</h5>

<pre class="line-numbers"><code class="language-text">- `$ brew install carthage       #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上`
</code></pre>

<h5 id="toc_10">(3) ANDROID_HOME is NOT set!</h5>

<pre class="line-numbers"><code class="language-text">- 使用最新版本Java
- 修改Mac的开发环境
- `vi .bash_profile`
- `export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home`
- `export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk`
- `export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin`
- 修改完配置文件记得保存退出，然后`source .bash_profile`
- 如果有问题记得修改在终端的Shall打开方式，调整为命令
</code></pre>

<h3 id="toc_11">(七) 安装appium客户端（Python为例）</h3>

<ul>
<li><code>brew search python   #查看可安装的python版本</code></li>
<li><code>brew install python3     #安装python3</code></li>
<li><code>pip install Appium-Python-Client   #安装python客户端</code>  </li>
</ul>

<h3 id="toc_12">(八) 安装支持iOS测试的插件</h3>

<ul>
<li><code>$ brew install libimobiledevice --HEAD  # install from HEAD to get important updates</code></li>
<li><code>$ brew install ideviceinstaller         # 只是对iOS9有用</code></li>
<li><code>$ npm install -g ios-deploy                # iOS10 以后的版本安装ios-deploy</code></li>
<li><code>$ sudo gem install xcpretty            # 真机需要安装 xcpretty</code></li>
</ul>

<h2 id="toc_13">二、Appium测试</h2>

<h3 id="toc_14">(一) iOS模拟器测试</h3>

<ul>
<li><code>xcodebuild -sdk iphonesimulator   #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件</code></li>
<li><code>npm install -g authorize-ios   #安装iOS模拟器启动器</code> </li>
<li><code>sudo authorize-ios   #启动iOS模拟器</code> </li>
<li><code>appium &amp;    #启动appium服务器</code> </li>
<li><code>python ***.py     #另开一个终端执行python脚本</code> </li>
<li>iOS模拟器自动开启，安装应用并开始执行测试脚本</li>
</ul>

<h3 id="toc_15">(二) Android模拟器测试</h3>

<ul>
<li><code>appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset</code></li>
</ul>

<h2 id="toc_16">三、Appium命令</h2>

<h3 id="toc_17">(一) 服务端启动命令</h3>

<p><strong>服务器标志</strong><br/>
所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>--shell</td>
<td>null</td>
<td>进入 REPL 模式</td>
<td></td>
</tr>
<tr>
<td>--localizable-strings-dir</td>
<td>en.lproj</td>
<td>IOS only: 定位 .strings所在目录的相对路径</td>
<td>--localizable-strings-dir en.lproj</td>
</tr>
<tr>
<td>--app</td>
<td>null</td>
<td>iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径--app /abs/path/to/my.app</td>
<td></td>
</tr>
<tr>
<td>--ipa</td>
<td>null</td>
<td>(IOS-only) .ipa 文件的绝对路径</td>
<td>--ipa /abs/path/to/my.ipa</td>
</tr>
<tr>
<td>-U, --udid</td>
<td>null</td>
<td>连接物理设备的唯一设备标识符</td>
<td>--udid 1adsf-sdfas-asdf-123sdf</td>
</tr>
<tr>
<td>-a, --address</td>
<td>0.0.0.0</td>
<td>监听的 ip 地址</td>
<td>--address 0.0.0.0</td>
</tr>
<tr>
<td>-p, --port</td>
<td>4723</td>
<td>监听的端口</td>
<td>--port 4723</td>
</tr>
<tr>
<td>-ca, --callback-address</td>
<td>null</td>
<td>回调IP地址 (默认: 相同的IP地址)</td>
<td>--callback-address 127.0.0.1</td>
</tr>
<tr>
<td>-cp, --callback-port</td>
<td>null</td>
<td>回调端口号 (默认: 相同的端口号)</td>
<td>--callback-port 4723</td>
</tr>
<tr>
<td>-bp, --bootstrap-port</td>
<td>4724</td>
<td>(Android-only) 连接设备的端口号</td>
<td>--bootstrap-port 4724</td>
</tr>
<tr>
<td>-k, --keep-artifacts</td>
<td>false</td>
<td>弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。</td>
<td></td>
</tr>
<tr>
<td>-r, --backend-retries</td>
<td>3</td>
<td>(iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。</td>
<td>--backend-retries 3</td>
</tr>
<tr>
<td>--session-override</td>
<td>false</td>
<td>允许 session 被覆盖 (冲突的话)</td>
<td></td>
</tr>
<tr>
<td>--full-reset</td>
<td>false</td>
<td>(iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。</td>
<td></td>
</tr>
<tr>
<td>--no-reset</td>
<td>false</td>
<td>session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。)</td>
<td></td>
</tr>
<tr>
<td>-l, --pre-launch</td>
<td>false</td>
<td>在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity)</td>
<td></td>
</tr>
<tr>
<td>-lt, --launch-timeout  90000   (iOS-only) 等待 Instruments 启动的时间</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g, --log</td>
<td>null</td>
<td>将日志输出到指定文件</td>
<td>--log /path/to/appium.log</td>
</tr>
<tr>
<td>--log-level</td>
<td>debug</td>
<td>日志级别; 默认 (console[:file]): debug[:debug]</td>
<td>--log-level debug</td>
</tr>
<tr>
<td>--log-timestamp</td>
<td>false</td>
<td>在终端输出里显示时间戳</td>
<td></td>
</tr>
<tr>
<td>--local-timezone</td>
<td>false</td>
<td>使用本地时间戳</td>
<td></td>
</tr>
<tr>
<td>--log-no-colors</td>
<td>false</td>
<td>不在终端输出中显示颜色</td>
<td></td>
</tr>
<tr>
<td>-G, --webhook</td>
<td>null</td>
<td>同时发送日志到 HTTP 监听器</td>
<td>--webhook localhost:9876</td>
</tr>
<tr>
<td>--native-instruments-lib</td>
<td>false</td>
<td>(IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。</td>
<td></td>
</tr>
<tr>
<td>--app-pkg</td>
<td>null</td>
<td>(Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp)</td>
<td>--app-pkg com.example.android.myApp</td>
</tr>
<tr>
<td>--app-activity</td>
<td>null</td>
<td>(Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity)</td>
<td>--app-activity MainActivity</td>
</tr>
<tr>
<td>--app-wait-package</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp)</td>
<td>--app-wait-package com.example.android.myApp</td>
</tr>
<tr>
<td>--app-wait-activity</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 名字(比如， SplashActivity)</td>
<td>--app-wait-activity SplashActivity</td>
</tr>
<tr>
<td>--android-coverage</td>
<td>false</td>
<td>(Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数</td>
<td>--android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td>
</tr>
<tr>
<td>--avd</td>
<td>null</td>
<td>(Android-only) 要启动的 avd 的名字</td>
<td></td>
</tr>
<tr>
<td>--avd-args</td>
<td>null</td>
<td>(Android-only) 添加额外的参数给要启动avd</td>
<td>--avd-args -no-snapshot-load</td>
</tr>
<tr>
<td>--device-ready-timeout</td>
<td>5</td>
<td>(Android-only) 等待设备准备好的时间，以秒为单位</td>
<td>--device-ready-timeout 5</td>
</tr>
<tr>
<td>--safari</td>
<td>false</td>
<td>(IOS-Only) 使用 Safari 应用</td>
<td></td>
</tr>
<tr>
<td>--device-name</td>
<td>null</td>
<td>待使用的移动设备名字</td>
<td>--device-name iPhone Retina (4-inch), Android Emulator</td>
</tr>
<tr>
<td>--platform-name</td>
<td>null</td>
<td>移动平台的名称: iOS, Android, or FirefoxOS</td>
<td>--platform-name iOS</td>
</tr>
<tr>
<td>--platform-version</td>
<td>null</td>
<td>移动平台的版本</td>
<td>--platform-version 7.1</td>
</tr>
<tr>
<td>--automation-name</td>
<td>null</td>
<td>自动化工具的名称: Appium or Selendroid</td>
<td>--automation-name Appium</td>
</tr>
<tr>
<td>--browser-name</td>
<td>null</td>
<td>移动浏览器的名称: Safari or Chrome</td>
<td>--browser-name Safari</td>
</tr>
<tr>
<td>--default-device, -dd</td>
<td>false</td>
<td>(IOS-Simulator-only) 使用instruments自己启动的默认模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-iphone</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-ipad</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器</td>
<td></td>
</tr>
<tr>
<td>--language</td>
<td>null</td>
<td>iOS / Android 模拟器的语言</td>
<td>--language en</td>
</tr>
<tr>
<td>--locale</td>
<td>null</td>
<td>Locale for the iOS simulator / Android Emulator</td>
<td>--locale en_US</td>
</tr>
<tr>
<td>--calendar-format</td>
<td>null</td>
<td>(IOS-only) iOS 模拟器的日历格式</td>
<td>--calendar-format gregorian</td>
</tr>
<tr>
<td>--orientation</td>
<td>null</td>
<td>(IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏)</td>
<td>--orientation LANDSCAPE</td>
</tr>
<tr>
<td>--tracetemplate</td>
<td>null</td>
<td>(IOS-only) 指定 Instruments 使用的 tracetemplate 文件</td>
<td>--tracetemplate /Users/me/Automation.tracetemplate</td>
</tr>
<tr>
<td>--show-sim-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--show-ios-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 系统的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--nodeconfig</td>
<td>null</td>
<td>指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd</td>
<td>--nodeconfig /abs/path/to/nodeconfig.json</td>
</tr>
<tr>
<td>-ra, --robot-address</td>
<td>0.0.0.0</td>
<td>robot 的 ip 地址</td>
<td>--robot-address 0.0.0.0</td>
</tr>
<tr>
<td>-rp, --robot-port</td>
<td>-1</td>
<td>robot 的端口地址</td>
<td>--robot-port 4242</td>
</tr>
<tr>
<td>--selendroid-port</td>
<td>8080</td>
<td>用来和 Selendroid 交互的本地端口</td>
<td>--selendroid-port 8080</td>
</tr>
<tr>
<td>--chromedriver-port</td>
<td>9515</td>
<td>ChromeDriver运行的端口</td>
<td>--chromedriver-port 9515</td>
</tr>
<tr>
<td>--chromedriver-executable</td>
<td>null</td>
<td>ChromeDriver 可执行文件的完整路径</td>
<td></td>
</tr>
<tr>
<td>--use-keystore</td>
<td>false</td>
<td>(Android-only) 设置签名 apk 的 keystore</td>
<td></td>
</tr>
<tr>
<td>--keystore-path</td>
<td>(Android-only) keystore 的路径</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--keystore-password</td>
<td>android</td>
<td>(Android-only) keystore 的密码</td>
<td></td>
</tr>
<tr>
<td>--key-alias</td>
<td>androiddebugkey</td>
<td>(Android-only) Key 的别名</td>
<td></td>
</tr>
<tr>
<td>--key-password</td>
<td>android</td>
<td>(Android-only) Key 的密码</td>
<td></td>
</tr>
<tr>
<td>--show-config</td>
<td>false</td>
<td>打印 Appium 服务器的配置信息，然后退出</td>
<td></td>
</tr>
<tr>
<td>--no-perms-check</td>
<td>false</td>
<td>跳过Appium对是否可以读/写必要文件的检查</td>
<td></td>
</tr>
<tr>
<td>--command-timeout</td>
<td>60</td>
<td>默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖</td>
<td></td>
</tr>
<tr>
<td>--keep-keychains</td>
<td>false</td>
<td>(iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains)</td>
<td></td>
</tr>
<tr>
<td>--strict-caps</td>
<td>false</td>
<td>如果所选设备是appium不承认的有效设备，会导致会话失败</td>
<td></td>
</tr>
<tr>
<td>--isolate-sim-device</td>
<td>false  Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--tmp</td>
<td>null</td>
<td>可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。</td>
<td></td>
</tr>
<tr>
<td>--trace-dir</td>
<td>null</td>
<td>用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments</td>
<td></td>
</tr>
<tr>
<td>--intent-action</td>
<td>android.intent.action.MAIN</td>
<td>(Android-only) 用于启动 activity 的intent action</td>
<td>--intent-action android.intent.action.MAIN</td>
</tr>
<tr>
<td>--intent-category</td>
<td>android.intent.category.LAUNCHER</td>
<td>(Android-only) 用于启动 activity 的intent category</td>
<td>--intent-category android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>--intent-flags</td>
<td>0x10200000</td>
<td>(Android-only) 启动 activity 的标志</td>
<td>--intent-flags 0x10200000</td>
</tr>
<tr>
<td>--intent-args</td>
<td>null</td>
<td>(Android-only) 启动 activity 时附带额外的 intent 参数</td>
<td>--intent-args 0x10200000</td>
</tr>
<tr>
<td>--suppress-adb-kill-server</td>
<td>false</td>
<td>(Android-only) 如果被设定，阻止Appium杀掉adb实例。</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_18">(二) Android测试用例编写</h3>

<h4 id="toc_19">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import os

import unittest
from appium import webdriver
from time import sleep

PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuAndroidTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;  #adb devices查到的设备名
        desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;4.4&#39;
        desired_caps[&#39;app&#39;] = PATH(
            &#39;../../../Users/jiangruoming/Desktop/***.apk&#39;
        )
        desired_caps[&#39;appPackage&#39;] = &#39;com.***.***&#39;  #被测App的包名
        desired_caps[&#39;appActivity&#39;] = &#39;.****&#39; #启动时的Activity

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出
    def tearDown(self):
        self.driver.quit()

    #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。
    def test_add_contacts(self):
        el = self.driver.find_element_by_id(&quot;com.***.***:id/sign_phone&quot;)
        el.click()

        phone_number = self.driver.find_element_by_id(&quot;com.***.***:id/et_user_phone&quot;)
        code = self.driver.find_element_by_id(&quot;com.***.***:id/et_smscode&quot;)
        phone_number.send_keys(&quot;*********&quot;)
        code.send_keys(&quot;****&quot;)

        btn = self.driver.find_element_by_id(&quot;com.***.***:id/btn_finish&quot;)
        btn.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_20">2、测试流程</h4>

<h5 id="toc_21">(1) 启动Appium</h5>

<p><code>appium -a 127.0.0.1 -p 4723 --log /path/to/appium.log</code></p>

<h5 id="toc_22">(2) 启动Android模拟器</h5>

<p>由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。</p>

<h6 id="toc_23">a、adb配置</h6>

<p>在Mac环境中加入adb的环境变量<br/><br/>
<code>vi .bash_profile</code><br/><br/>
<code>export PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATH</code><br/><br/>
<code>source .bash_profile</code>  </p>

<h6 id="toc_24">b、adb连接</h6>

<p>之后进入夜神的包内容中在adb所在文件夹运行adb连接命令<br/><br/>
<code>adb connect 127.0.0.1:62001</code><br/>
这样<code>adb devices</code>就能显示夜神模拟器的Device ID</p>

<h5 id="toc_25">(3) 运行脚本</h5>

<h3 id="toc_26">(三) iOS测试用例编写</h3>

<h4 id="toc_27">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import unittest
import os
from appium import webdriver
from time import sleep


PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuiOSTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;platformName&#39;] = &#39;iOS&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;10.2&#39;
        desired_caps[&#39;deviceName&#39;] = &#39;iPhone Simulator&#39;
        desired_caps[&#39;app&#39;] = PATH(&#39;../../../Users/jiangruoming/Desktop/***.app&#39;)

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #def tearDown(self):
        #self.driver.quit()

    def test_add_contacts(self):

        el2 = self.driver.find_elements_by_accessibility_id(&#39;Allow&#39;)

        if el2:
            el2[0].click()

        el3 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el3.click()

        el4 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[0]
        el4.send_keys(&quot;15088678313&quot;)

        el5 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[1]
        el5.send_keys(&quot;1234&quot;)

        el6 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el6.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_28">2、XCUIElementType</h4>

<pre class="line-numbers"><code class="language-python">XCUIElementTypeAny,
    XCUIElementTypeUnknown,
    XCUIElementTypeApplication,
    XCUIElementTypeGroup,
    XCUIElementTypeWindow,
    XCUIElementTypeSheet,
    XCUIElementTypeDrawer,
    XCUIElementTypeAlert,
    XCUIElementTypeDialog,
    XCUIElementTypeButton,
    XCUIElementTypeRadioButton,
    XCUIElementTypeRadioGroup,
    XCUIElementTypeCheckBox,
    XCUIElementTypeDisclosureTriangle,
    XCUIElementTypePopUpButton,
    XCUIElementTypeComboBox,
    XCUIElementTypeMenuButton,
    XCUIElementTypeToolbarButton,
    XCUIElementTypePopover,
    XCUIElementTypeKeyboard,
    XCUIElementTypeKey,
    XCUIElementTypeNavigationBar,
    XCUIElementTypeTabBar,
    XCUIElementTypeTabGroup,
    XCUIElementTypeToolbar,
    XCUIElementTypeStatusBar,
    XCUIElementTypeTable,
    XCUIElementTypeTableRow,
    XCUIElementTypeTableColumn,
    XCUIElementTypeOutline,
    XCUIElementTypeOutlineRow,
    XCUIElementTypeBrowser,
    XCUIElementTypeCollectionView,
    XCUIElementTypeSlider,
    XCUIElementTypePageIndicator,
    XCUIElementTypeProgressIndicator,
    XCUIElementTypeActivityIndicator,
    XCUIElementTypeSegmentedControl,
    XCUIElementTypePicker,
    XCUIElementTypePickerWheel,
    XCUIElementTypeSwitch,
    XCUIElementTypeToggle,
    XCUIElementTypeLink,
    XCUIElementTypeImage,
    XCUIElementTypeIcon,
    XCUIElementTypeSearchField,
    XCUIElementTypeScrollView,
    XCUIElementTypeScrollBar,
    XCUIElementTypeStaticText,
    XCUIElementTypeTextField,
    XCUIElementTypeDateField,
    XCUIElementTypeTimeField,
    XCUIElementTypeTextView,
    XCUIElementTypeMenu,
    XCUIElementTypeMenuItem,
    XCUIElementTypeMenuBar,
    XCUIElementTypeMenuBarItem,
    XCUIElementTypeMap,
    XCUIElementTypeWebView,
    XCUIElementTypeIncrementArrow,
    XCUIElementTypeDecrementArrow,
    XCUIElementTypeTimeline,
    XCUIElementTypeRatingIndicator,
    XCUIElementTypeValueIndicator,
    XCUIElementTypeSplitGroup,
    XCUIElementTypeSplitter,
    XCUIElementTypeRelevanceIndicator,
    XCUIElementTypeColorWell,
    XCUIElementTypeHelpTag,
    XCUIElementTypeMatte,
    XCUIElementTypeDockItem,
    XCUIElementTypeRuler,
    XCUIElementTypeRulerMarker,
    XCUIElementTypeGrid,
    XCUIElementTypeLevelIndicator,
    XCUIElementTypeCell,
    XCUIElementTypeLayoutArea,
    XCUIElementTypeLayoutItem,
    XCUIElementTypeHandle,
</code></pre>

<h4 id="toc_29">3、Appium Python API</h4>

<h5 id="toc_30">(1) contexts</h5>

<p><code>contexts(self)</code>:<br/><br/>
Returns the contexts within the current session.<br/>
返回当前会话中的上下文，使用后可以识别H5页面的控件<br/>
Usage:<br/><br/>
    <code>driver.contexts</code><br/><br/>
用法:<br/><br/>
    <code>driver.contexts</code></p>

<h5 id="toc_31">(2) current_context</h5>

<p><code>current_context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文<br/><br/>
Usage:<br/><br/>
    <code>driver.current_context</code><br/><br/>
用法:<br/><br/>
    <code>driver. current_context</code></p>

<h5 id="toc_32">(3) context</h5>

<p><code>context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文。<br/><br/>
Usage:<br/><br/>
    <code>driver.context</code><br/><br/>
用法:<br/><br/>
    <code>driver. Context</code></p>

<h5 id="toc_33">(4) find_element_by_ios_uiautomation</h5>

<p><code>find_element_by_ios_uiautomation(self, uia_string)</code>:<br/><br/>
Finds an element by uiautomation in iOS.<br/><br/>
通过iOS uiautomation查找元素<br/><br/>
Args:  </p>

<ul>
<li>uia_string - The element name in the iOS UIAutomation library<br/>
Usage:<br/>
<code>driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)</code>
用法:<br/>
<code>dr. find_element_by_ios_uiautomation(‘elements’)</code></li>
</ul>

<h5 id="toc_34">(5) find_element_by_accessibility_id</h5>

<p><code>find_element_by_accessibility_id(self, id)</code>:<br/><br/>
Finds an element by accessibility id.<br/><br/>
通过accessibility id查找元素<br/><br/>
Args:<br/><br/>
    - id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize<br/><br/>
Usage:<br/><br/>
    <code>driver.find_element_by_accessibility_id()</code><br/><br/>
用法:<br/><br/>
    <code>driver.find_element_by_accessibility_id(‘id’)</code></p>

<h5 id="toc_35">(6) scroll</h5>

<p><code>scroll(self, origin_el, destination_el)</code>:<br/>
Scrolls from one element to another<br/><br/>
从元素origin_el滚动至元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originalEl - the element from which to being scrolling</li>
<li>destinationEl - the element to scroll to<br/>
Usage:<br/>
<code>driver.scroll(el1, el2)</code>
用法:<br/>
<code>driver.scroll(el1,el2)</code></li>
</ul>

<h5 id="toc_36">(7) drag_and_drop</h5>

<p><code>drag_and_drop(self, origin_el, destination_el)</code>:<br/><br/>
Drag the origin element to the destination element<br/><br/>
将元素origin_el拖到目标元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originEl - the element to drag</li>
<li>destinationEl - the element to drag to<br/>
用法:<br/>
<code>driver.drag_and_drop(el1,el2)</code></li>
</ul>

<h5 id="toc_37">(8) tap</h5>

<p><code>tap(self, positions, duration=None)</code>:<br/><br/>
Taps on an particular place with up to five fingers, holding for a certain time<br/><br/>
模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）<br/><br/>
Args:</p>

<ul>
<li>positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five.</li>
<li>duration - (optional) length of time to tap, in ms<br/>
Usage:<br/>
<code>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</code>
用法:<br/>
<code>driver.tap([(x,y),(x1,y1)],500)</code></li>
</ul>

<h5 id="toc_38">(9) swipe</h5>

<p><code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>:<br/><br/>
Swipe from one point to another point, for an optional duration.<br/><br/>
从A点滑动至B点，滑动时间为毫秒<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/>
    - duration - (optional) time to take the swipe, in ms.  </p>

<p>Usage:<br/><br/>
    <code>driver.swipe(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.swipe(x1,y1,x2,y2,500)</code></p>

<h5 id="toc_39">(10) flick</h5>

<p><code>flick(self, start_x, start_y, end_x, end_y)</code>:<br/><br/>
Flick from one point to another point.<br/><br/>
按住A点后快速滑动至B点<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/><br/>
Usage:<br/><br/>
    <code>driver.flick(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.flick(x1,y1,x2,y2)</code></p>

<h5 id="toc_40">(11) pinch</h5>

<p><code>pinch(self, element=None, percent=200, steps=50)</code>:<br/><br/>
Pinch on an element a certain amount<br/><br/>
在元素上执行模拟双指捏（缩小操作）<br/><br/>
Args:  </p>

<ul>
<li>element - the element to pinch</li>
<li>percent - (optional) amount to pinch. Defaults to 200%</li>
<li>steps - (optional) number of steps in the pinch action</li>
</ul>

<p>Usage:<br/><br/>
    <code>driver.pinch(element)</code><br/>
用法:<br/>
    <code>driver.pinch(element)</code></p>

<h5 id="toc_41">(12) zoom</h5>

<p><code>zoom(self, element=None, percent=200, steps=50)</code>:<br/>
Zooms in on an element a certain amount<br/><br/>
在元素上执行放大操作<br/><br/>
Args:  </p>

<ul>
<li>element - the element to zoom</li>
<li>percent - (optional) amount to zoom. Defaults to 200%</li>
<li>steps - (optional) number of steps in the zoom action</li>
</ul>

<p>Usage:<br/>
    <code>driver.zoom(element)</code><br/>
用法: <br/>
    <code>driver.zoom(element)</code></p>

<h5 id="toc_42">(13) reset</h5>

<p><code>reset(self)</code>:<br/><br/>
Resets the current application on the device.<br/><br/>
重置应用(类似删除应用数据)<br/><br/>
用法:<br/>
<code>driver.reset()</code></p>

<h5 id="toc_43">(14) hide_keyboard</h5>

<p><code>hide_keyboard(self, key_name=None, key=None, strategy=None)</code>:<br/>
Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.<br/>
隐藏键盘,iOS使用key_name隐藏，安卓不使用参数<br/>
Args:  </p>

<ul>
<li>key_name - key to press</li>
<li>strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</li>
</ul>

<p><code>driver.hide_keyboard()</code></p>

<h5 id="toc_44">(15) keyevent</h5>

<p><code>keyevent(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/><br/>
Args:  </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法:<br/>
<code>dr.keyevent(‘4’)</code></p>

<h5 id="toc_45">(16) press_keycode</h5>

<p><code>press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法: <br/>
<code>driver.press_ keycode(‘4’)</code>  </p>

<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>

<h5 id="toc_46">(17) long_press_keycode</h5>

<p><code>long_press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a long press of keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送一个长按的按键码（长按某键）<br/><br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent<br/>
用法:<br/>
<code>driver.long_press_keycode(‘4’)</code></li>
</ul>

<h5 id="toc_47">(18) current_activity</h5>

<p><code>current_activity(self)</code>:<br/><br/>
Retrieves the current activity on the device.<br/><br/>
获取当前的activity<br/><br/>
用法:<br/>
<code>print(driver.current_activity())</code></p>

<h5 id="toc_48">(19) wait_activity</h5>

<p><code>wait_activity(self, activity, timeout, interval=1)</code>:<br/><br/>
Wait for an activity: block until target activity presents or time out.<br/><br/>
This is an Android-only method.<br/><br/>
等待指定的activity出现直到超时，interval为扫描间隔1秒<br/><br/>
即每隔几秒获取一次当前的activity<br/><br/>
返回的True 或 False<br/><br/>
Agrs:</p>

<ul>
<li>activity - target activity</li>
<li>timeout - max wait time, in seconds</li>
<li>interval - sleep interval between retries, in seconds</li>
</ul>

<p>用法:<br/>
    <code>driver.wait_activity(‘.activity.xxx’,5,2)</code></p>

<h5 id="toc_49">(20) background_app</h5>

<p><code>background_app(self, seconds)</code>:<br/>
Puts the application in the background on the device for a certain duration.<br/><br/>
后台运行app多少秒<br/><br/>
Args:  </p>

<ul>
<li>seconds - the duration for the application to remain in the background<br/>
用法:
<code>driver.background_app(5)</code><br/>
置后台5秒后再运行</li>
</ul>

<h5 id="toc_50">(21) is_app_installed</h5>

<p><code>is_app_installed(self, bundle_id)</code>:<br/><br/>
Checks whether the application specified by <code>bundle_id</code> is installed on the device.<br/><br/>
检查app是否有安装<br/><br/>
返回 True or False<br/><br/>
Args:  </p>

<ul>
<li>bundle_id - the id of the application to query<br/></li>
</ul>

<p>用法: <br/>
<code>driver.is_app_installed(“com.xxxx”)</code></p>

<h5 id="toc_51">(22) install_app</h5>

<p><code>install_app(self, app_path)</code>:<br/><br/>
Install the application found at <code>app_path</code> on the device.<br/><br/>
安装app,app_path为安装包路径<br/><br/>
Args:  </p>

<ul>
<li>app_path - the local or remote path to the application to install</li>
</ul>

<p>用法:<br/><br/>
<code>driver.install_app(app_path)</code></p>

<h5 id="toc_52">(23) remove_app</h5>

<p><code>remove_app(self, app_id)</code>:<br/><br/>
Remove the specified application from the device.<br/><br/>
删除app<br/><br/>
Args:  </p>

<ul>
<li>app_id - the application id to be removed<br/></li>
</ul>

<p>用法: <br/>
<code>driver.remove_app(“com.xxx.”)</code></p>

<h5 id="toc_53">(24) launch_app</h5>

<p><code>launch_app(self)</code>:<br/><br/>
Start on the device the application specified in the desired capabilities.<br/><br/>
启动app<br/><br/>
用法:<br/><br/>
<code>driver.launch_app()</code></p>

<h5 id="toc_54">(25) close_app</h5>

<p><code>close_app(self)</code>:<br/><br/>
Stop the running application, specified in the desired capabilities, on the device.<br/><br/>
关闭app<br/><br/>
用法:<br/><br/>
<code>driver.close_app()</code><br/><br/>
启动和关闭app运行好像会出错</p>

<h5 id="toc_55">(26) start_activity</h5>

<p><code>start_activity(self, app_package, app_activity, **opts)</code>:<br/><br/>
Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.<br/><br/>
This is an Android-only method.<br/><br/>
在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。<br/><br/>
这是一个安卓的方法<br/><br/>
Args:</p>

<ul>
<li>app_package - The package containing the activity to start.</li>
<li>app_activity - The activity to start.</li>
<li>app_wait_package - Begin automation after this package starts (optional).</li>
<li>app_wait_activity - Begin automation after this activity starts (optional).</li>
<li>intent_action - Intent to start (optional).</li>
<li>intent_category - Intent category to start (optional).</li>
<li>intent_flags - Flags to send to the intent (optional).</li>
<li>optional_intent_arguments - Optional arguments to the intent (optional).</li>
<li>stop_app_on_reset - Should the app be stopped on reset (optional)?</li>
</ul>

<p>用法:<br/><br/>
<code>driver.start_activity(app_package, app_activity)</code></p>

<h5 id="toc_56">(27) lock</h5>

<p><code>lock(self, seconds)</code>:<br/><br/>
Lock the device for a certain period of time. iOS only.<br/><br/>
锁屏一段时间  iOS专有<br/><br/>
Args:  </p>

<ul>
<li>the duration to lock the device, in seconds</li>
</ul>

<p>用法:<br/><br/>
<code>driver.lock()</code></p>

<h5 id="toc_57">(28) shake</h5>

<p><code>shake(self)</code>:<br/><br/>
Shake the device.<br/><br/>
摇一摇手机<br/><br/>
用法:<br/><br/>
<code>driver.shake()</code></p>

<h5 id="toc_58">(29) open_notifications</h5>

<p><code>open_notifications(self)</code>:<br/><br/>
Open notification shade in Android (API Level 18 and above)<br/><br/>
打系统通知栏（仅支持API 18 以上的安卓系统）<br/><br/>
用法:<br/><br/>
<code>driver.open_notifications()</code></p>

<h5 id="toc_59">(30) network_connection</h5>

<p><code>network_connection(self)</code>:<br/><br/>
Returns an integer bitmask specifying the network connection type.<br/><br/>
Android only.<br/><br/>
返回网络类型  数值<br/><br/>
Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code><br/><br/>
用法:<br/><br/>
<code>driver.network_connection</code>  </p>

<h5 id="toc_60">(31) set_network_connection</h5>

<p><code>set_network_connection(self, connectionType)</code>:<br/><br/>
Sets the network connection type. Android only.<br/><br/>
Possible values:  </p>

<table>
<thead>
<tr>
<th>Value (Alias)</th>
<th>Data</th>
<th>Wifi</th>
<th>Airplane Mode</th>
</tr>
</thead>

<tbody>
<tr>
<td>0 (None)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 (Airplane Mode)</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 (Wifi only)</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4 (Data only)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6 (All network on)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<p>These are available through the enumeration appium.webdriver.ConnectionType`</p>

<p>设置网络类型<br/><br/>
Args:  </p>

<ul>
<li>connectionType - a member of the enum appium.webdriver.ConnectionType</li>
</ul>

<p>用法:<br/><br/>
先加载from appium.webdriver.connectiontype import ConnectionType<br/><br/>
<code>dr.set_network_connection(ConnectionType.WIFI_ONLY)</code><br/><br/>
ConnectionType的类型有<br/><br/>
NO_CONNECTION = 0<br/><br/>
AIRPLANE_MODE = 1<br/><br/>
WIFI_ONLY = 2<br/><br/>
DATA_ONLY = 4<br/><br/>
ALL_NETWORK_ON = 6  </p>

<h5 id="toc_61">(32) available_ime_engines</h5>

<p><code>available_ime_engines(self)</code>:<br/><br/>
Get the available input methods for an Android device. Package and activity are returned (e.g., [&#39;com.android.inputmethod.latin/.LatinIME&#39;])<br/><br/>
Android only.<br/><br/>
返回安卓设备可用的输入法<br/><br/>
用法:<br/><br/>
<code>print(driver.available_ime_engines)</code></p>

<h5 id="toc_62">(33) is_ime_active</h5>

<p><code>is_ime_active(self)</code>:<br/><br/>
Checks whether the device has IME service active. Returns True/False.<br/><br/>
Android only.<br/><br/>
检查设备是否有输入法服务活动。返回真/假。<br/><br/>
安卓<br/><br/>
用法: <br/>
    <code>print(driver.is_ime_active())</code></p>

<h5 id="toc_63">(34) activate_ime_engine</h5>

<p><code>activate_ime_engine(self, engine)</code>:<br/><br/>
Activates the given IME engine on the device.<br/><br/>
Android only.<br/><br/>
激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取<br/><br/>
Args:  </p>

<ul>
<li>engine - the package and activity of the IME engine to activate (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;)<br/></li>
</ul>

<p>用法:<br/><br/>
    <code>driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</code></p>

<h5 id="toc_64">(35) deactivate_ime_engine</h5>

<p><code>deactivate_ime_engine(self)</code>:<br/><br/>
Deactivates the currently active IME engine on the device.<br/><br/>
Android only.<br/><br/>
关闭安卓设备当前的输入法<br/><br/>
用法:<br/>
    <code>driver.deactivate_ime_engine()</code></p>

<h5 id="toc_65">(36) active_ime_engine</h5>

<p><code>active_ime_engine(self)</code>:<br/><br/>
Returns the activity and package of the currently active IME engine (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;).<br/><br/>
Android only.<br/><br/>
返回当前输入法的包名<br/><br/>
用法:<br/><br/>
<code>driver.active_ime_engine</code>  </p>

<h5 id="toc_66">(37) toggle_location_services</h5>

<p><code>toggle_location_services(self)</code>:<br/><br/>
Toggle the location services on the device. Android only.<br/><br/>
打开安卓设备上的位置定位设置<br/><br/>
用法:<br/>
<code>driver.toggle_location_services()</code></p>

<h5 id="toc_67">(38) set_location</h5>

<p><code>set_location(self, latitude, longitude, altitude)</code>:<br/><br/>
Set the location of the device<br/><br/>
设置设备的经纬度<br/><br/>
Args:  </p>

<ul>
<li>latitude纬度 - String or numeric value between -90.0 and 90.00</li>
<li>longitude经度 - String or numeric value between -180.0 and 180.0</li>
<li>altitude海拔高度- String or numeric value</li>
</ul>

<p>用法:<br/><br/>
<code>driver.set_location(纬度，经度，高度)</code></p>

<h5 id="toc_68">(39) tag_name</h5>

<p><code>tag_name(self)</code>:<br/><br/>
This element&#39;s <code>tagName</code> property.<br/><br/>
返回元素的tagName属性<br/><br/>
经实践返回的是class name<br/><br/>
用法:<br/><br/>
<code>element.tag_name()</code></p>

<h5 id="toc_69">(40) text</h5>

<p><code>text(self)</code>:<br/><br/>
The text of the element.<br/><br/>
返回元素的文本值<br/><br/>
用法:<br/><br/>
<code>element.text()</code></p>

<h5 id="toc_70">(41) click</h5>

<p><code>click(self)</code>:<br/><br/>
Clicks the element.<br/><br/>
点击元素<br/><br/>
用法:<br/><br/>
<code>element.click()</code></p>

<h5 id="toc_71">(42) submit</h5>

<p><code>submit(self)</code>:<br/><br/>
Submits a form.<br/><br/>
提交表单<br/><br/>
用法:<br/><br/>
暂无</p>

<h5 id="toc_72">(43) clear</h5>

<p><code>clear(self)</code>:<br/><br/>
Clears the text if it&#39;s a text entry element.<br/><br/>
清除输入的内容<br/><br/>
用法:<br/><br/>
<code>element.clear()</code></p>

<h5 id="toc_73">(44) get_attribute</h5>

<p><code>get_attribute(self, name)</code>:<br/><br/>
详见@chenhengjie123 的超级链接<br/><br/>
Gets the given attribute or property of the element.  </p>

<pre class="line-numbers"><code class="language-text">1. 获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值）  
2. get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)
可获取的：
字符串类型：
    `name(返回 content-desc 或 text)`
    `text(返回 text)`
    `className(返回 class，只有 API=&gt;18 才能支持)`
    `resourceId(返回 resource-id，只有 API=&gt;18 才能支持)`
</code></pre>

<p>This method will first try to return the value of a property with the given name. If a property with that name doesn&#39;t exist, it returns the value of the attribute with the same name. If there&#39;s no attribute with that name, <code>None</code> is returned.Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,are returned as booleans.  All other non-<code>None</code> values are returned as strings.  For attributes or properties which do not exist, <code>None</code> is returned.</p>

<p>Args:</p>

<ul>
<li>name - Name of the attribute/property to retrieve.</li>
</ul>

<p>Example:<br/>
    # Check if the &quot;active&quot; CSS class is applied to an element.</p>

<p><code>is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</code></p>

<p>用法:<br/><br/>
暂无</p>

<h5 id="toc_74">(45) is_selected</h5>

<p><code>is_selected(self)</code>:<br/><br/>
Returns whether the element is selected.<br/><br/>
Can be used to check if a checkbox or radio button is selected.<br/><br/>
返回元素是否选择。<br/><br/>
可以用来检查一个复选框或单选按钮被选中。<br/><br/>
用法:<br/><br/>
<code>element.is_slected()</code></p>

<h5 id="toc_75">(46) is_enabled</h5>

<p><code>is_enabled(self)</code>:<br/><br/>
Returns whether the element is enabled.<br/><br/>
返回元素是否可用True of False<br/><br/>
用法:<br/><br/>
<code>element.is_enabled()</code></p>

<h5 id="toc_76">(47) find_element_by_id</h5>

<p><code>find_element_by_id(self, id_)</code>:<br/><br/>
Finds element within this element&#39;s children by ID.<br/><br/>
通过元素的ID定位元素<br/><br/>
Args:  </p>

<ul>
<li>id_ - ID of child element to locate.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_id(“id”)</code></p>

<h5 id="toc_77">(48) find_elements_by_id</h5>

<p><code>find_elements_by_id(self, id_)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by ID.<br/><br/>
通过元素ID定位,含有该属性的所有元素<br/><br/>
Args:   </p>

<ul>
<li>id_ - Id of child element to find.</li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_id(“id”)</code></p>

<h5 id="toc_78">(49) find_element_by_name</h5>

<p><code>find_element_by_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text）. <br/>
Args:  </p>

<ul>
<li>name - name property of the element to find.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_79">(50) find_elements_by_name</h5>

<p><code>find_elements_by_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text），含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>name - name property to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_80">(51) find_element_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by visible link text.<br/><br/>
通过元素可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_link_text(“text”)</code></p>

<h5 id="toc_81">(52) find_elements_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by visible link text. <br/>
通过元素可见链接文本定位,含有该属性的所有元素. <br/>
Args:    </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法: <br/>
<code>driver.find_elements_by_link_text(“text”)</code></p>

<h5 id="toc_82">(53) find_element_by_partial_link_text</h5>

<p><code>find_element_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by partially visible link text.<br/><br/>
通过元素部分可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_element_by_partial_link_text(“text”)</code></p>

<h5 id="toc_83">(54) find_elements_by_partial_link_text</h5>

<p><code>find_elements_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by link text.<br/><br/>
通过元素部分可见链接文本定位,含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_elements_by_partial_link_text(“text”)</code></p>

<h5 id="toc_84">(55) find_element_by_tag_name</h5>

<p><code>find_element_by_tag_name(self, name)</code>:<br/>
Finds element within this element&#39;s children by tag name.<br/><br/>
通过查找html的标签名称定位元素<br/><br/>
Args:</p>

<ul>
<li>name - name of html tag (eg: h1, a, span)</li>
</ul>

<p>用法:<br/><br/>
    <code>driver.find_element_by_tag_name(“name”)</code></p>

<h5 id="toc_85">(56) find_elements_by_tag_name</h5>

<p><code>find_elements_by_tag_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by tag name.<br/>
通过查找html的标签名称定位所有元素<br/><br/>
Args:  </p>

<ul>
<li>name - name of html tag (eg: h1, a, span). </li>
</ul>

<p>用法:<br/>
    <code>driver.find_elements_by_tag_name(“name”)</code></p>

<h5 id="toc_86">(57) find_element_by_xpath</h5>

<p><code>find_element_by_xpath(self, xpath)</code>:<br/><br/>
Finds element by xpath.<br/><br/>
通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/">http://www.w3school.com.cn/xpath/</a><br/>
Args:<br/>
    xpath - xpath of element to locate.  &quot;//input[@class=&#39;myelement&#39;]&quot;<br/>
    Note: The base path will be relative to this element&#39;s location.<br/>
    This will select the first link under this element.<br/>
    <code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code><br/>
    However, this will select the first link on the page.<br/>
    <code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>  </p>

<p>用法 <code>find_element_by_xpath(“//*”)</code></p>

<h5 id="toc_87">(58) find_elements_by_xpath</h5>

<p><code>find_elements_by_xpath(self, xpath)</code>:<br/>
Finds elements within the element by xpath.<br/><br/>
Args:</p>

<ul>
<li>xpath - xpath locator string.</li>
</ul>

<p>Note: The base path will be relative to this element&#39;s location.<br/><br/>
This will select all links under this element.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code>. <br/>
However, this will select all links in the page itself.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>. </p>

<p>用法:<br/><br/>
<code>find_elements_by_xpath(“//*”)</code></p>

<h5 id="toc_88">(59) find_element_by_class_name</h5>

<p><code>find_element_by_class_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位元素.<br/><br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_class_name(“android.widget.LinearLayout”)</code></p>

<h5 id="toc_89">(60) find_elements_by_class_name</h5>

<p><code>find_elements_by_class_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位所有含有该属性的元素. <br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_class_name(“android.widget.LinearLayout”)</code>. </p>

<h5 id="toc_90">(61) find_element_by_css_selector</h5>

<p><code>find_element_by_css_selector(self, css_selector)</code>:<br/><br/>
Finds element within this element&#39;s children by CSS selector.<br/><br/>
通过CSS选择器定位元素. <br/>
Args:  </p>

<ul>
<li>css_selector - CSS selctor string, ex: &#39;a.nav#home&#39;</li>
</ul>

<h5 id="toc_91">(62) send_keys</h5>

<p><code>send_keys(self, *value)</code>:<br/><br/>
Simulates typing into the element.<br/><br/>
在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）. <br/>
Args:</p>

<ul>
<li>value - A string for typing, or setting form fields.  For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:<br/>
<code>form_textfield = driver.find_element_by_name(&#39;username&#39;)</code><br/>
<code>form_textfield.send_keys(&quot;admin&quot;)</code><br/>
This can also be used to set file inputs.<br/>
<code>file_input = driver.find_element_by_name(&#39;profilePic&#39;)</code><br/>
<code>file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</code><br/>
<code># Generally it&#39;s better to wrap the file path in one of the methods</code><br/>
<code># in os.path to return the actual path to support cross OS testing.</code><br/>
<code># file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</code><br/>
<code>driver.element.send_keys(“中英”)</code></li>
</ul>

<h5 id="toc_92">(63) is_displayed</h5>

<p><code>is_displayed(self)</code>:<br/><br/>
Whether the element is visible to a user.<br/><br/>
此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False. <br/>
用法:<br/><br/>
<code>driver.element.is_displayed()</code></p>

<h5 id="toc_93">(64) location_once_scrolled_into_view</h5>

<p><code>location_once_scrolled_into_view(self)</code>:<br/><br/>
 &quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or <code>None</code> if the element is not visible.</p>

<p>暂不知道用法</p>

<h5 id="toc_94">(65) size</h5>

<p><code>size(self)</code>:<br/><br/>
The size of the element.<br/><br/>
获取元素的大小（高和宽）.<br/><br/>
<code>new_size[&quot;height&quot;] = size[&quot;height&quot;]</code><br/><br/>
<code>new_size[&quot;width&quot;] = size[&quot;width&quot;]</code>   </p>

<p>用法:<br/><br/>
<code>driver.element.size</code></p>

<h5 id="toc_95">(66) value_of_css_property</h5>

<p><code>value_of_css_property(self, property_name)</code>:<br/><br/>
The value of a CSS property.<br/><br/>
CSS属性<br/><br/>
用法 暂不知  </p>

<h5 id="toc_96">(67) location</h5>

<p><code>location(self)</code>:<br/><br/>
The location of the element in the renderable canvas.<br/><br/>
获取元素左上角的坐标<br/><br/>
用法:<br/><br/>
<code>driver.element.location</code><br/><br/>
返回element的x坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;x&#39;)</code><br/><br/>
返回element的y坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;y&#39;)</code></p>

<h5 id="toc_97">(68) rect</h5>

<p><code>rect(self)</code>:<br/><br/>
A dictionary with the size and location of the element.<br/><br/>
元素的大小和位置的字典  </p>

<h5 id="toc_98">(69) screenshot_as_base64</h5>

<p><code>screenshot_as_base64(self)</code>:<br/><br/>
Gets the screenshot of the current element as a base64 encoded string.<br/><br/>
获取当前元素的截图为Base64编码的字符串<br/><br/>
Usage:<br/><br/>
<code>img_b64 = element.screenshot_as_base64</code></p>

<h5 id="toc_99">(70) execute_script</h5>

<p><code>execute_script(self, script, *args)</code>:<br/><br/>
Synchronously Executes JavaScript in the current window/frame.<br/><br/>
在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.<br/>
Usage:<br/>
<code>driver.execute_script(&#39;document.title&#39;)</code></li>
</ul>

<h5 id="toc_100">(71) execute_async_script</h5>

<p><code>execute_async_script(self, script, *args)</code>:<br/><br/>
Asynchronously Executes JavaScript in the current window/frame.<br/><br/>
插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.</li>
</ul>

<p>Usage:<br/><br/>
<code>driver.execute_async_script(&#39;document.title&#39;)</code></p>

<h5 id="toc_101">(72) current_url</h5>

<p><code>current_url(self)</code>:<br/><br/>
Gets the URL of the current page.<br/><br/>
获取当前页面的网址。<br/><br/>
Usage:<br/><br/>
<code>driver.current_url</code><br/>
用法<br/><br/>
<code>driver.current_url</code></p>

<h5 id="toc_102">(73) page_source</h5>

<p><code>page_source(self)</code>:<br/><br/>
Gets the source of the current page.<br/><br/>
获取当前页面的源<br/><br/>
Usage:<br/><br/>
<code>driver.page_source</code></p>

<h5 id="toc_103">(74) close</h5>

<p><code>close(self)</code>:<br/>
Closes the current window.<br/><br/>
关闭当前窗口<br/><br/>
Usage:<br/><br/>
<code>driver.close()</code></p>

<h5 id="toc_104">(75) quit</h5>

<p><code>quit(self)</code>:<br/><br/>
Quits the driver and closes every associated window.<br/><br/>
退出脚本运行并关闭每个相关的窗口连接<br/><br/>
Usage:<br/><br/>
<code>driver.quit()</code></p>

<p>参考资料:<br/><br/>
<a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">打造心目中理想的自动化测试框(AppiumBooster)</a>   </p>

<p><a href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>  </p>

<p><a href="https://github.com/appium/python-client">Python-Client的github文档地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868936.html">
                
                  <h1>LaTeX表示方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、指数和下标可以用<sup>和_后加相应字符来实现。</sup></h2>

<p><figure><img src="media/15561207868936/15713264075302.png" alt=""/></figure></p>

<h2 id="toc_1">二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。</h2>

<p><figure><img src="media/15561207868936/15713264213005.png" alt=""/></figure></p>

<h2 id="toc_2">三、命令\overline 和\underline 在表达式的上、下方画出水平线。</h2>

<p><figure><img src="media/15561207868936/15713264358808.png" alt=""/></figure></p>

<h2 id="toc_3">四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</h2>

<p><figure><img src="media/15561207868936/15713264468658.png" alt=""/></figure></p>

<h2 id="toc_4">五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</h2>

<p><figure><img src="media/15561207868936/15713264649982.png" alt=""/></figure></p>

<h2 id="toc_5">六、分数（fraction）使用\frac{...}{...} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</h2>

<p><figure><img src="media/15561207868936/15713264772357.png" alt=""/></figure></p>

<h2 id="toc_6">七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</h2>

<p><figure><img src="media/15561207868936/15713264928671.png" alt=""/></figure></p>

<h2 id="toc_7">以下提供一些常用符号的表示方法</h2>

<p><figure><img src="media/15561207868936/15713265151036.png" alt=""/></figure> <br/>
<figure><img src="media/15561207868936/15713265355830.png" alt=""/></figure><br/>
<figure><img src="media/15561207868936/15713265726366.png" alt=""/></figure> <br/>
<figure><img src="media/15561207868936/15713265959249.png" alt=""/></figure> <br/>
<figure><img src="media/15561207868936/15713266129558.png" alt=""/></figure> <br/>
<figure><img src="media/15561207868936/15713266264578.png" alt=""/></figure><br/>
<figure><img src="media/15561207868936/15713266364253.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868901.html">
                
                  <h1>Android Matrix</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Matrix的数学原理</h2>

<p>在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下：  </p>

<p><figure><img src="media/15561207868901/15713248709988.png" alt=""/></figure></p>

<p>Matrix的对图像的处理可分为四类基本变换：</p>

<ul>
<li>Translate ————    平移变换</li>
<li>Rotate        ————    旋转变换</li>
<li>Scale     ————    缩放变换</li>
<li>Skew          ————    错切变换</li>
</ul>

<p>从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块：</p>

<p><figure><img src="media/15561207868901/15713248828132.png" alt=""/></figure></p>

<p>如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系：</p>

<p><figure><img src="media/15561207868901/15713248932789.png" alt=""/></figure></p>

<p>看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。</p>

<p><figure><img src="media/15561207868901/15713249060997.png" alt=""/></figure></p>

<p>x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。</p>

<p>针对每种变换，Android提供了pre、set和post三种操作方式。其中</p>

<ul>
<li>set用于设置Matrix中的值。</li>
<li>pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。</li>
<li>post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</li>
</ul>

<p>除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>

<p>下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。</p>

<h3 id="toc_1">平移变换</h3>

<p>假定有一个点的坐标是 P(\(x_{0}\),\(y_{0}\)) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: \(\Delta\)x = x - \(x_{0}\) and \(\Delta\)y = y - \(y_{0}\)   </p>

<p>如下图所示：<br/><br/>
<figure><img src="media/15561207868901/15713249283962.png" alt=""/></figure></p>

<p>不难知道：<br/><br/>
x = \(x_{0}\) + \(\Delta\)x<br/><br/>
y = \(y_{0}\) + \(\Delta\)y    </p>

<p>如果用矩阵来表示的话，就可以写成：  </p>

<p><figure><img src="media/15561207868901/15713249413361.png" alt=""/></figure></p>

<h3 id="toc_2">旋转变换</h3>

<h4 id="toc_3">围绕坐标原点旋转：</h4>

<p>假定有一个点 P(\(x_{0}\),\(y_{0}\)) ，相对坐标原点 \(\theta\) 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图：<br/><br/>
<figure><img src="media/15561207868901/15713249564812.png" alt=""/></figure></p>

<p>那么，<br/><br/>
<figure><img src="media/15561207868901/15713249686768.png" alt=""/></figure></p>

<p>如果用矩阵，就可以表示为：<br/><br/>
<figure><img src="media/15561207868901/15713249863150.png" alt=""/></figure></p>

<h4 id="toc_4">围绕某个点旋转</h4>

<p>如果是围绕某个点 P(\(x_{p}\),\(y_{p}\)) 顺时针旋转 \(\theta\) ，那么可以用矩阵表示为：<br/><br/>
<figure><img src="media/15561207868901/15713250115345.png" alt=""/></figure></p>

<p>可以化为：<br/><br/>
<figure><img src="media/15561207868901/15713250256435.png" alt=""/></figure></p>

<p>很显然<br/><br/>
1、<br/><br/>
<figure><img src="media/15561207868901/15713250519935.png" alt=""/></figure><br/>
是将坐标原点移动到点 P(\(x_{p}\),\(y_{p}\)) 后， P(\(x_{0}\),\(y_{0}\)) 的新坐标。  </p>

<p>2、<br/><br/>
<figure><img src="media/15561207868901/15713250777326.png" alt=""/></figure><br/>
是将上一步变换后的 P(\(x_{0}\),\(y_{0}\)) ，围绕新的坐标原点顺时针旋转 \(\theta\) 。<br/><br/>
3、<br/><br/>
<figure><img src="media/15561207868901/15713250884005.png" alt=""/></figure> <br/>
经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。<br/><br/>
所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。  </p>

<p>同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。</p>

<h3 id="toc_5">缩放变换</h3>

<p>理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即<br/><br/>
x = \(k_{1}\)\(x_{0}\)<br/><br/>
y = \(k_{2}\)\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713251037672.png" alt=""/></figure></p>

<p>缩放变换比较好理解，就不多说了。 </p>

<h3 id="toc_6">错切变换</h3>

<p>错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。<br/><br/>
比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。  </p>

<p><figure><img src="media/15561207868901/15713251203786.png" alt=""/></figure><br/><br/>
下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。  </p>

<p><figure><img src="media/15561207868901/15713251468299.png" alt=""/></figure></p>

<p>假定一个点 P(\(x_{0}\),\(y_{0}\)) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：<br/><br/>
x = \(x_{0}\) + k\(y_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713251590706.png" alt=""/></figure></p>

<p>扩展到3 x 3的矩阵就是下面这样的形式：<br/><br/>
<figure><img src="media/15561207868901/15713251743273.png" alt=""/></figure></p>

<p>同理，对于垂直错切，可以有：<br/><br/>
<figure><img src="media/15561207868901/15713251847214.png" alt=""/></figure></p>

<p>在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是：<br/><br/>
<figure><img src="media/15561207868901/15713252015750.png" alt=""/></figure></p>

<h3 id="toc_7">对称变换</h3>

<p>除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P(\(x_{0}\),\(y_{0}\)) 经过对称变换后得到 P(x,y) ，</p>

<p>如果对称轴是x轴，那么，<br/><br/>
x = \(x_{0}\)<br/><br/>
y = -\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713252182944.png" alt=""/></figure></p>

<p>如果对称轴是y轴，那么，<br/><br/>
x = -\(x_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713252341566.png" alt=""/></figure></p>

<p>如果对称轴是y = x，如图：<br/><br/>
<figure><img src="media/15561207868901/15713252502644.png" alt=""/></figure></p>

<p>那么，<br/><br/>
<figure><img src="media/15561207868901/15713252657933.png" alt=""/></figure></p>

<p>很容易可以解得：<br/><br/>
x = \(y_{0}\)<br/><br/>
y = \(x_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713252863119.png" alt=""/></figure></p>

<p>同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713252991340.png" alt=""/></figure></p>

<p>特殊地，如果对称轴是y = kx，如下图：<br/><br/>
<figure><img src="media/15561207868901/15713253168019.png" alt=""/></figure></p>

<p>那么，<br/><br/>
<figure><img src="media/15561207868901/15713253302288.png" alt=""/></figure><br/>
很容易可解得：<br/><br/>
<figure><img src="media/15561207868901/15713253484332.png" alt=""/></figure> <br/>
用矩阵表示就是：<br/><br/>
<figure><img src="media/15561207868901/15713253636451.png" alt=""/></figure></p>

<p>当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。<br/><br/>
如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br/><br/>
<figure><img src="media/15561207868901/15713253775468.png" alt=""/></figure> <br/>
需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：<br/><br/>
<figure><img src="media/15561207868901/15713253966057.png" alt=""/></figure><br/>
要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：<br/><br/>
<figure><img src="media/15561207868901/15713254081479.png" alt=""/></figure><br/>
关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。</p>

<h3 id="toc_8">三角函数</h3>

<pre class="line-numbers"><code class="language-text">public void setSinCos(float sinValue, float cosValue, float px, float py)
public void setSinCos(float sinValue, float cosValue)
</code></pre>

<p>这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的：</p>

<p><figure><img src="media/15561207868901/15713254234720.jpg" alt=""/></figure></p>

<p>其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。<br/><br/>
sinValue：对应图中的sin值<br/><br/>
cosValue：对应cos值<br/><br/>
px:中心的x坐标<br/><br/>
py：中心的y坐标<br/><br/>
看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。  </p>

<p><figure><img src="media/15561207868901/15713254372635.png" alt=""/></figure></p>

<p>看代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrixmatrix = new Matrix();
matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
canvas.drawBitmap(bitmap, matrix, paint);123123
</code></pre>

<h3 id="toc_9">数值操作</h3>

<p>数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。</p>

<h4 id="toc_10">set</h4>

<p><code>void set (Matrix src)</code>没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于<code>reset()</code></p>

<h4 id="toc_11">reset</h4>

<p><code>void reset ()</code>重置当前Matrix(将当前Matrix重置为单位矩阵)。</p>

<h4 id="toc_12">setValues</h4>

<p><code>void setValues (float[] values)</code>setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</p>

<h4 id="toc_13">getValues</h4>

<p><code>void getValues (float[] values)</code>很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。</p>

<h2 id="toc_14">基本方法解析</h2>

<p>讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。</p>

<pre class="line-numbers"><code class="language-java">public Matrix()
public Matrix(Matrix src)
</code></pre>

<p>构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）<br/>
单位矩阵如下：</p>

<p><figure><img src="media/15561207868901/15713254491671.png" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-java">public boolean isIdentity()//判断是否是单位矩阵
public boolean isAffine()//判断是否是仿射矩阵
</code></pre>

<p>是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。<br/>
首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。<code>public boolean rectStaysRect()</code>判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。<code>public void reset()</code>重置矩阵为单位矩阵。<br/>
<code>public void setTranslate(float dx, float dy)</code>设置平移效果，参数分别是x，y上的平移量。<br/>
效果图如下：</p>

<p><figure><img src="media/15561207868901/15713254610428.png" alt=""/></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
canvas.drawBitmap(bitmap, matrix, paint);

matrix.setTranslate(100, 1000);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h2 id="toc_15">代码验证</h2>

<p>在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：<br/><br/>
<figure><img src="media/15561207868901/15713254713068.png" alt=""/></figure><br/><br/>
其尺寸为162 x 251。  </p>

<p>每种变换的结果，请见代码之后的说明。</p>

<pre class="line-numbers"><code class="language-java">import android.app.Activity;  
import android.content.Context;  
import android.graphics.Bitmap;  
import android.graphics.BitmapFactory;  
import android.graphics.Canvas;  
import android.graphics.Matrix;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.MotionEvent;  
import android.view.View;  
import android.view.Window;  
import android.view.WindowManager;  
import android.view.View.OnTouchListener;  
import android.widget.ImageView;  
  
public class TestTransformMatrixActivity extends Activity  
implements  
OnTouchListener  
{  
    private TransformMatrixView view;  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);  
  
        view = new TransformMatrixView(this);  
        view.setScaleType(ImageView.ScaleType.MATRIX);  
        view.setOnTouchListener(this);  
          
        setContentView(view);  
    }  
      
    class TransformMatrixView extends ImageView  
    {  
        private Bitmap bitmap;  
        private Matrix matrix;  
        public TransformMatrixView(Context context)  
        {  
            super(context);  
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);  
            matrix = new Matrix();  
        }  
  
        @Override  
        protected void onDraw(Canvas canvas)  
        {  
            // 画出原图像  
            canvas.drawBitmap(bitmap, 0, 0, null);  
            // 画出变换后的图像  
            canvas.drawBitmap(bitmap, matrix, null);  
            super.onDraw(canvas);  
        }  
  
        @Override  
        public void setImageMatrix(Matrix matrix)  
        {  
            this.matrix.set(matrix);  
            super.setImageMatrix(matrix);  
        }  
          
        public Bitmap getImageBitmap()  
        {  
            return bitmap;  
        }  
    }  
  
    public boolean onTouch(View v, MotionEvent e)  
    {  
        if(e.getAction() == MotionEvent.ACTION_UP)  
        {  
            Matrix matrix = new Matrix();  
            // 输出图像的宽度和高度(162 x 251)  
            Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; +  view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight());  
            // 1. 平移  
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()  
            view.setImageMatrix(matrix);  
              
            // 下面的代码是为了查看matrix中的元素  
            float[] matrixValues = new float[9];  
            matrix.getValues(matrixValues);  
            for(int i = 0; i &lt; 3; ++i)  
            {  
                String temp = new String();  
                for(int j = 0; j &lt; 3; ++j)  
                {  
                    temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
                }  
                Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
            }  
              
  
//          // 2. 旋转(围绕图像的中心点)  
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
              
//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)  
//          matrix.setRotate(45f);  
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 4. 缩放  
//          matrix.setScale(2f, 2f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 5. 错切 - 水平  
//          matrix.setSkew(0.5f, 0f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠           
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 6. 错切 - 垂直  
//          matrix.setSkew(0f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          7. 错切 - 水平 + 垂直  
//          matrix.setSkew(0.5f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 8. 对称 (水平对称)  
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 9. 对称 - 垂直  
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }     
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 10. 对称(对称轴为直线y = x)  
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(),   
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
            view.invalidate();  
        }  
        return true;  
    }  
}
</code></pre>

<p>下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵</p>

<h3 id="toc_16">平移</h3>

<p><figure><img src="media/15561207868901/15713255048295.png" alt=""/></figure></p>

<p>输出的结果：<br/><br/>
<figure><img src="media/15561207868901/15713255317624.png" alt=""/></figure><br/>
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。</p>

<h3 id="toc_17">旋转(围绕图像的中心点)</h3>

<p><figure><img src="media/15561207868901/15713255559491.png" alt=""/></figure><br/>
输出的结果：<br/><br/>
<figure><img src="media/15561207868901/15713255740404.png" alt=""/></figure></p>

<p><strong>它实际上是</strong> <br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code><br/><br/>
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
所产生的转换矩阵就是：<br/><br/>
<figure><img src="media/15561207868901/15713256131000.png" alt=""/></figure><br/><br/>
而<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code>的意思就是在上述矩阵的左边再乘以下面的矩阵：<br/><br/>
<figure><img src="media/15561207868901/15713256421295.png" alt=""/></figure><br/><br/>
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。<br/><br/>
所以它实际上就是：<br/><br/>
<figure><img src="media/15561207868901/15713256698915.png" alt=""/></figure><br/><br/>
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。</p>

<h3 id="toc_18">旋转(围绕坐标原点旋转，在加上两次平移，效果同2)</h3>

<p><figure><img src="media/15561207868901/15713257012996.png" alt=""/></figure><br/><br/>
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：<br/><br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
等价于<br/><br/>
<code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
其中matrix.setRotate(45f)对应的矩阵是：<br/><br/>
<figure><img src="media/15561207868901/15713257206041.png" alt=""/></figure> </p>

<p>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是：<br/><br/>
<figure><img src="media/15561207868901/15713257493590.png" alt=""/></figure> </p>

<p>由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。  </p>

<p><code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)</code>对应的矩阵是：<br/><br/>
<figure><img src="media/15561207868901/15713257674729.png" alt=""/></figure><br/>
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。  </p>

<p>所以综合起来，  </p>

<p><code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
对应的矩阵就是：<br/><br/>
<figure><img src="media/15561207868901/15713257931706.png" alt=""/></figure><br/><br/>
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：<br/><br/>
<figure><img src="media/15561207868901/15713258177142.png" alt=""/></figure> <br/>
因此，此处变换后的图像和2中变换后的图像时一样的。  </p>

<h3 id="toc_19">缩放变换</h3>

<p><figure><img src="media/15561207868901/15713258356499.png" alt=""/></figure> <br/>
程序所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713258542458.png" alt=""/></figure> <br/>
其中第二个矩阵，其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713258728624.png" alt=""/></figure><br/><br/>
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。  </p>

<h3 id="toc_20">错切变换(水平错切)</h3>

<p><figure><img src="media/15561207868901/15713258942846.png" alt=""/></figure> <br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713259115863.png" alt=""/></figure><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713259256014.png" alt=""/></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_21">错切变换(垂直错切)</h3>

<p><figure><img src="media/15561207868901/15713259832463.png" alt=""/></figure></p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713260044895.png" alt=""/></figure><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713260301125.png" alt=""/></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_22">错切变换(水平+垂直错切)</h3>

<p><figure><img src="media/15561207868901/15713260482967.png" alt=""/></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713260676666.png" alt=""/></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713260811688.png" alt=""/></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。    </p>

<h3 id="toc_23">对称变换(水平对称)</h3>

<p><figure><img src="media/15561207868901/15713260984021.png" alt=""/></figure></p>

<p>代码所输出的两个各矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713261164699.png" alt=""/></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713261300378.png" alt=""/></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_24">对称变换(垂直对称)</h3>

<p><figure><img src="media/15561207868901/15713261500866.png" alt=""/></figure></p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713261643062.png" alt=""/></figure><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713261752857.png" alt=""/></figure> <br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_25">对称变换(对称轴为直线y = x)</h3>

<p><figure><img src="media/15561207868901/15713261858584.png" alt=""/></figure><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="media/15561207868901/15713262032070.png" alt=""/></figure> <br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="media/15561207868901/15713262168197.png" alt=""/></figure><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_26">关于先乘和后乘的问题</h3>

<p>由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：<br/><br/>
<figure><img src="media/15561207868901/15713262336274.png" alt=""/></figure><br/>
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。  </p>

<p>当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate(\(\theta\))，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。  </p>

<h2 id="toc_27">进阶方法解析</h2>

<p>上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：<br/>
preXXXX:以pre开头，例如preTranslate<br/>
postXXXX:以post开头，例如postScale<br/>
他们分别代表了前乘，和后乘。看一段代码：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
matrix.setTranslate(100, 1000);
matrix.preScale(0.5f, 0.5f);
</code></pre>

<p>这里matrix前乘了一个scale矩阵，换算成数学式如下：</p>

<p><figure><img src="media/15561207868901/15713262495575.png" alt=""/></figure><br/>
从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。<br/>
后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果：</p>

<p><figure><img src="media/15561207868901/15713262725570.png" alt=""/></figure><br/>
可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。<br/>
来看看他们对应的效果图：<br/><br/>
<strong>前乘：</strong></p>

<p><figure><img src="media/15561207868901/15713262951235.png" alt=""/></figure></p>

<p><strong>后乘：</strong></p>

<p><figure><img src="media/15561207868901/15713263078376.png" alt=""/></figure></p>

<p>可以明显看到，后乘的平移距离受了影响。<br/>
了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。</p>

<h2 id="toc_28">其他方法解析</h2>

<p>matrix除了上面的方法外，还有一些其他的方法，这里依次解析</p>

<h3 id="toc_29">setRectToRect</h3>

<p><code>public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</code>将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。<br/><br/>
<code>ScaleToFit</code> 有如下四个值：<br/><br/>
<code>FILL</code>: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br/><br/>
<code>START</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br/><br/>
<code>CENTER</code>: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br/><br/>
<code>END</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。<br/><br/>
这里使用谷歌的api demo的图片作为例子：<br/><br/>
<figure><img src="media/15561207868901/15713263235401.png" alt=""/></figure></p>

<h3 id="toc_30">setPolyToPoly</h3>

<p><code>public boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)</code>通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。<br/><br/>
下面通过例子分别说明1到4个点的可以达到的效果：</p>

<h4 id="toc_31">1个点，平移</h4>

<p>只指定一个点，可以达到平移效果：</p>

<p><figure><img src="media/15561207868901/15713263473878.png" alt=""/></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">float[] src = {0, 0};
int DX = 300;
float[] dst = {0 + DX, 0 + DX};
matrix.setPolyToPoly(src, 0, dst, 0, 1);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h4 id="toc_32">2个点，旋转或者缩放</h4>

<p>两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果</p>

<p><figure><img src="media/15561207868901/15713263597246.png" alt=""/></figure></p>

<p>代码如下</p>

<pre class="line-numbers"><code class="language-java">int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {bw / 2, bh / 2, bw, 0};
float[] dst = {bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2};
matrix.setPolyToPoly(src, 0, dst, 0, 2);
canvas.drawBitmap(bitmap, matrix, paint);123456123456
</code></pre>

<p>图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。</p>

<h4 id="toc_33">3个点，错切</h4>

<p>使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。<br/><br/>
看图：</p>

<p><figure><img src="media/15561207868901/15713263715305.png" alt=""/></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0,0, 0, bh,bw,bh};
float[] dst = {0, 0, 200, bh, bw + 200, bh};
matrix.setPolyToPoly(src, 0, dst, 0, 3);
canvas.drawBitmap(bitmap, matrix, paint);12345671234567
</code></pre>

<h4 id="toc_34">4个点，透视</h4>

<p>透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。<br/>
我们看下面的例子，更容易理解：</p>

<p><figure><img src="media/15561207868901/15713263850567.png" alt=""/></figure></p>

<p>图片看起来好像倾斜了，实现特别简单：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0, 0, 0, bh, bw, bh, bw, 0};
int DX = 100;
float[] dst = {0 + DX, 0, 0, bh, bw, bh, bw - DX, 0};
matrix.setPolyToPoly(src, 0, dst, 0, 4);
canvas.drawBitmap(bitmap, matrix, paint);1234567812345678
</code></pre>

<p>可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。</p>

<h3 id="toc_35">invert</h3>

<p><code>public boolean invert(Matrix inverse)</code>反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。<br/><br/>
反转前后有什么效果，我们来看看示例：</p>

<p><figure><img src="media/15561207868901/15713263956307.png" alt=""/></figure></p>

<p>可以看到，反转之后，其实是对效果的一种反转。</p>

<h3 id="toc_36">mapPoints</h3>

<pre class="line-numbers"><code class="language-java">public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)
public void mapPoints(float[] dst, float[] src)
public void mapPoints(float[] pts)
</code></pre>

<p>映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。</p>

<ul>
<li>dst：指定写入的数组<br/></li>
<li>dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1</li>
<li>src：指定要计算的点</li>
<li>srcIndex：要计算的点的索引</li>
<li>pointCount：需要计算的点的个数，每个点有两个值，x和y。</li>
</ul>

<h3 id="toc_37">mapVectors</h3>

<pre class="line-numbers"><code class="language-java">public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)
public void mapVectors(float[] dst, float[] src)
public void mapVectors(float[] vecs)

</code></pre>

<p>与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。</p>

<h3 id="toc_38">mapRect</h3>

<pre class="line-numbers"><code class="language-java">public boolean mapRect(RectF dst, RectF src)
public boolean mapRect(RectF rect)
</code></pre>

<p>返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。</p>

<h3 id="toc_39">mapRadius</h3>

<p><code>public float mapRadius(float radius)</code>返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868861.html">
                
                  <h1>Android Studio 关联 Bitbucket</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。</p>

<h2 id="toc_1">Bitbucket简介</h2>

<p>BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势：</p>

<ul>
<li>支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。</li>
<li>完全免费的闭源项目，还支持5人以内的合作开发。</li>
<li>支持中文。</li>
<li>官方的git工具SourceTree比GitHub for windows好用。</li>
</ul>

<h2 id="toc_2">使用步骤</h2>

<h3 id="toc_3">一、安装Git</h3>

<p>安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联：</p>

<p>Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。<br/>
<figure><img src="media/15561207868861/15713246960472.png" alt=""/></figure></p>

<h3 id="toc_4">二、在Bitbucket网站创建远程仓库</h3>

<p>在Bitbucket网站上创建仓库<br/><br/>
<figure><img src="media/15561207868861/15713247073567.png" alt=""/></figure></p>

<p>记录下远程仓库的URL，后面会用到<br/>
<figure><img src="media/15561207868861/15713247206326.png" alt=""/></figure></p>

<h3 id="toc_5">三、在AndroidStudio中创建新项目</h3>

<p>首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色<br/><br/>
<figure><img src="media/15561207868861/15713247349739.png" alt=""/></figure></p>

<p><figure><img src="media/15561207868861/15713247482004.png" alt=""/></figure></p>

<p><figure><img src="media/15561207868861/15713247715529.png" alt=""/></figure></p>

<p>接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files<br/><br/>
<figure><img src="media/15561207868861/15713247845617.png" alt=""/></figure></p>

<p>接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。<br/><br/>
<figure><img src="media/15561207868861/15713247974008.png" alt=""/></figure></p>

<p><figure><img src="media/15561207868861/15713248090123.png" alt=""/></figure> </p>

<p>至此创建项目就完成了</p>

<h3 id="toc_6">四、AndroidStudio中将项目提交并推送到远程仓库</h3>

<p>进入AS项目中，选择VCS–&gt;Git-&gt;Commit File<br/><br/>
<figure><img src="media/15561207868861/15713248252576.png" alt=""/></figure></p>

<p>填写提交信息后，选择commit and Push<br/><br/>
<figure><img src="media/15561207868861/15713248367087.png" alt=""/></figure></p>

<p>之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。<br/>
<figure><img src="media/15561207868861/15713248467219.png" alt=""/></figure></p>

<p><figure><img src="media/15561207868861/15713248552072.png" alt=""/></figure></p>

<p>到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。</p>

<h3 id="toc_7">五、别忘了给Bitbucket添加SSH密钥</h3>

<p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br/><br/>
使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868826.html">
                
                  <h1>Android 冷启动实现APP秒开</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在阅读这篇文章之前，首先需要理解几个东西：  </p>

<ul>
<li>1、什么是Android的冷启动时间？<br/>
冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。</li>
<li>2、在冷启动的时间段内发生了什么？<br/>
首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。<br/></li>
</ul>

<p>来看下效果图：<br/><br/>
<strong>未优化：</strong><br/><br/>
<figure><img src="media/15561207868826/20170227548242189443-4a70e91b2e124b48.gif" alt=""/></figure></p>

<p><strong>优化方案一：</strong><br/><br/>
<figure><img src="media/15561207868826/20170227487382189443-4829eba35492d39b.gif" alt=""/></figure></p>

<p><strong>优化方案二：</strong><br/><br/>
<figure><img src="media/15561207868826/20170227662152189443-c861191c8a80cd94.gif" alt=""/></figure></p>

<h2 id="toc_1">历史原因</h2>

<p>当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是<strong>Preview Window</strong>,即预览窗口。</p>

<p>好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。</p>

<p>但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！</p>

<p>所以，下面我们就来聊聊这个问题的解决方案。</p>

<h2 id="toc_2">解决方案</h2>

<p>既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了</p>

<p>所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。</p>

<h3 id="toc_3">方案一 ：开历史倒车</h3>

<p>这个方案就是禁止加载Preview Window，具体做法如下：</p>

<p>style.xml</p>

<style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar">
   <item name="android:windowDisablePreview">true</item>
</style>

<p>将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。</p>

<p>结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。</p>

<p>我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。</p>

<h3 id="toc_4">方案二：自定义Preview Window</h3>

<h4 id="toc_5">1、透明启动</h4>

<p>将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会&quot;立即&quot;进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。<br/>
<code>&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;</code><br/>
透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常：</p>

<blockquote>
<p>java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</p>
</blockquote>

<p>这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单：</p>

<ul>
<li>1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity</li>
<li>2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
            setTheme(R.style.AppTheme);
            super.onCreate(savedInstanceState);
    }
}
</code></pre>

<h4 id="toc_6">2、Logo图片启动</h4>

<p>将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。<br/><br/>
具体方法如下：</p>

<p>style.xlm</p>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;APPTheme&quot; parent=&quot;@android:style/Theme.Holo.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_icon&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。</p>

<p>splash_icon.xml</p>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:opacity=&quot;opaque&quot;&gt;
    &lt;item android:drawable=&quot;@color/white&quot;/&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/qq&quot;/&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>

<p>这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下<br/><br/>
<figure><img src="media/15561207868826/2017022724594838b008fdb18f761ede8.gif" alt=""/></figure></p>

<p>上面的2种做法，我们都需要将Theme引入对应的Activity</p>

<pre class="line-numbers"><code class="language-java">&lt;activity
    android:name=&quot;.app.main.MainActivity&quot;
    android:theme=&quot;@style/AppWelcome&quot;
    android:screenOrientation=&quot;portrait&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的，</p>

<p>所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。</p>

<p>在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。</p>

<h3 id="toc_7">方案三：自定义Preview Window增强版</h3>

<p>废话少说，我们先来看效果<br/><br/>
<figure><img src="media/15561207868826/20170227597652f5ba2feffca1ca31a8c.gif" alt=""/></figure></p>

<p>有了动画之后，界面切换顺畅了许多。<br/>
上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看<a href="https://github.com/ladingwu/Splash">本次项目的demo</a>，我们重点来聊一聊思路。</p>

<p>在这里我们需要明确一点的是，<strong>preview window</strong> 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 <strong>Preview Window</strong> 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 <strong>Preview Window</strong> 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。</p>

<p>然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 <strong>Preview Window</strong> 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。</p>

<p>好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空：</p>

<p>SplashActivity.java</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    //将window的背景图设置为空
    getWindow().setBackgroundDrawable(null);
    super.onCreate(savedInstanceState);
}
</code></pre>

<h2 id="toc_8">关于启动优化</h2>

<p>上面的做法其实可以达到&quot;秒开&quot;APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。<br/><br/>
这里给出几点建议：  </p>

<ul>
<li>1、不要让Application参与业务的操作</li>
<li>2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到&quot;确实该使用的时候再去创建&quot;亦或者是数据库的一些操作。</li>
<li>3、不要以静态变量的方式在Application中保存数据等。</li>
</ul>

<p>当然这是绝对的理想主义，把上面的&quot;不要&quot;2字之前添上&quot;尽量&quot;2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。</p>

<p>对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。</p>

<h2 id="toc_9">总结</h2>

<p>到这里，关于Android启动页的相关问题就都讲完了。<br/><br/>
最终的高清的效果图：<br/><br/>
<figure><img src="media/15561207868826/201702274812409e2d6cccbbdf90fb06f.gif" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868790.html">
                
                  <h1>Android Thread</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、线程简介</h2>

<p>现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。</p>

<p>一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。</p>

<p>想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。</p>

<p>如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。</p>

<h2 id="toc_1">二、线程创建的三种方式</h2>

<p>送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式：</p>

<h3 id="toc_2">(一) 实现 Runnable 接口</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest0 {

    /**
     * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务
     */
    static class Task implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
            Thread shixinzhang = new Thread(new Task(), &quot;外卖任务 &quot; + i);
            //3.命令送餐员出发！
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下：</p>

<p><code>外卖任务 3: 您的外卖已送达</code><br/><br/>
<code>外卖任务 1: 您的外卖已送达</code><br/><br/>
<code>外卖任务 0: 您的外卖已送达</code><br/><br/>
<code>外卖任务 2: 您的外卖已送达</code>  </p>

<p>可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。</p>

<p>直接在 main 中调用 run()：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 4; i++) {
        //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
        Task task = new Task();
        Thread shixinzhang = new Thread(task, &quot;外卖任务 &quot; + i);
        //3.直接执行任务
        task.run();
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code>  </p>

<h3 id="toc_3">(二) 继承 Thread，重写其 run 方法</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest1 {
    /**
     * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务
     */
    static class DeliverThread extends Thread{

        public DeliverThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，同时起个名
            DeliverThread shixinzhang = new DeliverThread(&quot;外卖任务&quot; + i);
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>外卖任务1: 您的外卖已送达</code><br/><br/>
<code>外卖任务3: 您的外卖已送达</code><br/><br/>
<code>外卖任务0: 您的外卖已送达</code><br/><br/>
<code>外卖任务2: 您的外卖已送达</code>  </p>

<p>为什么直接继承 Thread 也可以在子线程中执行任务呢？</p>

<p>从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：<br/><br/>
<code>public class Thread implements Runnable</code>  </p>

<p>它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。</p>

<p>线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。</p>

<p>等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。</p>

<h3 id="toc_4">(三) 实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果</h3>

<pre class="line-numbers"><code class="language-java">public class CallableTest {
    /**
     * 实现 Callable 接口
     */
    static class DeliverCallable implements Callable&lt;String&gt; {
        /**
         * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常
         * @return
         * @throws Exception
         */
        @Override
        public String call() throws Exception {
            Thread.sleep(new Random().nextInt(10000));
            System.out.println(Thread.currentThread().getName() + &quot;：您的外卖已送达&quot;);
            return Thread.currentThread().getName() + &quot; 送达时间：&quot; + System.currentTimeMillis() + &quot;\n&quot;;
        }
    }

    /**
     * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行
     * @param args
     */
    public static void main(String[] args) {
        List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4);
        for (int i = 0; i &lt; 4; i++) {
            DeliverCallable callable = new DeliverCallable();
            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
            futureTasks.add(futureTask);

            Thread thread = new Thread(futureTask, &quot;送餐员 &quot; + i);
            thread.start();
        }

        StringBuilder results = new StringBuilder();
        futureTasks.forEach(futureTask -&gt; {
            try {
                //获取线程返回结果，没返回就会阻塞
                results.append(futureTask.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        System.out.println(System.currentTimeMillis() + &quot; 得到结果：\n&quot; + results);
    }
}
</code></pre>

<p>第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。</p>

<p>运行结果：  </p>

<pre class="line-numbers"><code class="language-text">送餐员 3：您的外卖已送达  
送餐员 1：您的外卖已送达  
送餐员 0：您的外卖已送达  
送餐员 2：您的外卖已送达  
1487998155430 得到结果： 
送餐员 0 送达时间：1487998155076 
送餐员 1 送达时间：1487998150453 
送餐员 2 送达时间：1487998155430 
送餐员 3 送达时间：1487998149779
</code></pre>

<h2 id="toc_5">三、线程的基本属性</h2>

<h3 id="toc_6">(一) 优先级</h3>

<p>Thread 有个优先级字段：private int priority</p>

<p>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。</p>

<p>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。</p>

<p>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。</p>

<p>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久； <br/>
频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。  </p>

<pre class="line-numbers"><code class="language-java"> public final static int MIN_PRIORITY = 1;

 //线程的默认优先级
 public final static int NORM_PRIORITY = 5;

 public final static int MAX_PRIORITY = 10;
</code></pre>

<blockquote>
<p>线程优先级只是对操作系统分配时间片的建议。 <br/>
虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>

<h3 id="toc_7">(二) 守护线程</h3>

<p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。</p>

<p>Thread 中有个布尔值标识当前线程是否为守护线程：</p>

<p><code>private boolean     daemon = false;</code></p>

<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>

<pre class="line-numbers"><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}

public final boolean isDaemon() {
    return daemon;
}
</code></pre>

<blockquote>
<p>Daemon 属性需要在调用线程的 start() 方法之前调用。</p>
</blockquote>

<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。</p>

<p><strong>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。</strong></p>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class DaemonTreadTest0 {
    static class DaemonThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName() + &quot; finally is called!&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DaemonThread thread = new DaemonThread();
        thread.setDaemon(true);
        thread.start();
    }
}
</code></pre>

<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。</p>

<p>如果将setDaemon方法注释掉，就会发现有运行结果:</p>

<p><code>Thread-0 finally is called!</code></p>

<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。</p>

<h2 id="toc_8">四、线程的生命周期</h2>

<p>线程具有如下几个状态：</p>

<table>
<thead>
<tr>
<th>线程状态</th>
<th style="text-align: center">介绍</th>
<th style="text-align: left">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>NEW</td>
<td style="text-align: center">新创建</td>
<td style="text-align: left">还未调用 start() 方法；还不是活着的 (alive)</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align: center">就绪的</td>
<td style="text-align: left">调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)</td>
</tr>
<tr>
<td>RUNNING</td>
<td style="text-align: center">运行中</td>
<td style="text-align: left">线程获得 CPU 资源，正在执行任务；活着的</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align: center">阻塞的</td>
<td style="text-align: left">线程阻塞于锁或者调用了 sleep；活着的</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align: center">等待中</td>
<td style="text-align: left">线程由于某种原因等待其他线程；或者的</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align: center">超时等待</td>
<td style="text-align: left">与 WAITING 的区别是可以在特定时间后自动返回；活着的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align: center">终止</td>
<td style="text-align: left">执行完毕或者被其他线程杀死；不是活着的</td>
</tr>
</tbody>
</table>

<p>有几点注意：</p>

<ul>
<li>Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE</li>
<li>三个让线程进入 WAITING 状态的方法 
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>Lock.lock()</li>
</ul></li>
</ul>

<p><strong>Java 中关于“线程是否活着”的定义</strong></p>

<p>Thread 中有个判断是否为活着的方法：<br/><br/>
<code>public final native boolean isAlive()</code></p>

<p>Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。</p>

<h2 id="toc_9">五、线程的关键方法</h2>

<h3 id="toc_10">(一) Thread.sleep()</h3>

<p>Thread.sleep() 是一个静态方法：</p>

<p><code>public static native void sleep(long millis) throws InterruptedException;</code></p>

<p>sleep() 方法：</p>

<ul>
<li>使当前所在线程进入阻塞</li>
<li>只是让出 CPU ，并没有释放对象锁</li>
<li>由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数</li>
<li>如果被中断会抛出 InterruptedException</li>
</ul>

<p><strong>注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</strong></p>

<h3 id="toc_11">(二) Object.wait()</h3>

<p>与 Thread.sleep() 容易混淆的是 Object.wait() 方法。</p>

<p>Object.wait() 方法：</p>

<ul>
<li>让出 CPU，释放对象锁</li>
<li>在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用</li>
<li>使该线程进入该对象监视器的等待队列</li>
</ul>

<h3 id="toc_12">(三) Thread.yield()</h3>

<p>Thread. yield() 也是一个静态方法：</p>

<p><code>public static native void yield();</code></p>

<p>“Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。</p>

<ul>
<li>和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</li>
<li>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。</li>
</ul>

<blockquote>
<p>yield() 一般使用较少。</p>
</blockquote>

<h3 id="toc_13">(四) Thread.join()</h3>

<p>Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。</p>

<blockquote>
<p>线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。</p>
</blockquote>

<p>比如下述代码：</p>

<pre class="line-numbers"><code class="language-java">Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;thread is running!&quot;);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
thread.start();
thread.join();
System.out.println(&quot;main thread &quot;);
</code></pre>

<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>

<blockquote>
<p>thread is running! <br/>
main thread</p>
</blockquote>

<p>Thread.join 源码：</p>

<pre class="line-numbers"><code class="language-java">//无参方法
public final void join() throws InterruptedException {
    join(0);
}
//有参方法，表示等待 millis 毫秒后自动返回
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束
public final synchronized void join(long millis, int nanos)
throws InterruptedException {

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
        millis++;
    }

    join(millis);
}
</code></pre>

<p>通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。</p>

<p>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>

<h2 id="toc_14">六、线程的中断</h2>

<p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest1 {
    static class InterruptThread extends Thread{
        private boolean running;

        public InterruptThread(boolean running) {
            this.running = running;
        }

        public boolean isRunning() {
            return running;
        }

        public void setRunning(boolean running) {
            this.running = running;
        }

        @Override
        public void run() {
            while (running){
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread(true);
        thread.start();

        Thread.sleep(5000);
        thread.setRunning(false);
    }
}
</code></pre>

<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。 <br/>
因此我们可以通过修改这个标志位为 false 来中断该线程。</p>

<p>其实 Thread 内部也为我们提供了同样的机制 ：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align: center">方法介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>public void interrupt()</td>
<td style="text-align: center">试图中断调用线程，设置中断标志位为 false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td style="text-align: center">返回调用线程是否被中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td style="text-align: center">返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">(一) public void interrupt()</h3>

<p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。</p>

<p>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest2 {

    static class UnInterruptThread extends Thread{
        public UnInterruptThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    static class  UnInterruptRunnable implements Runnable{

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UnInterruptThread thread = new UnInterruptThread(&quot;无法中断的线程&quot;);
//        Thread thread = new Thread(new UnInterruptRunnable(), &quot;无法中断&quot;);
        thread.start();

        //先让它执行一秒
        Thread.sleep(1000);

        thread.interrupt();

        //不立即退出
        Thread.sleep(3000);
    }
}
</code></pre>

<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！</p>

<p>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>

<h3 id="toc_16">(二) public boolean isInterrupted()</h3>

<p>我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。</p>

<blockquote>
<p>isInterrupted() 在刚创建时默认为 false 不用多说； <br/>
线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false； <br/>
线程结束后，线程的中断标志位也会复位为 false。</p>
</blockquote>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">/**
 * 线程中断练习
 * Created by zhangshixin on 17/2/25.
 * http://blog.csdn.net/u011240877
 */
public class ThreadInterruptTest {
    /**
     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException
     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置
     */
    static class SleepThread extends Thread{
        public SleepThread(String s) {
            setName(s);
        }
        @Override
        public void run() {
            while (!isInterrupted()){
                try {
                    Thread.sleep(500);
                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println(&quot;SleepRunner 在 sleep 时被中断了，此时中断标志位为：&quot; + isInterrupted());
                }
            }
        }
    }

    /**
     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置
     */
    static class BusyThread extends Thread{

        public BusyThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (!isInterrupted()){
                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SleepThread sleepThread = new SleepThread(&quot;SleepRunner：&quot;);
        BusyThread busyThread = new BusyThread(&quot;BusyRunner：&quot;);
        //新创建的线程 中断标志为 false
        System.out.println(&quot;SleepThread 新创建时的中断标志位：&quot; + sleepThread.isInterrupted());

        Thread.sleep(2000);
        //启动两个线程
        sleepThread.start();
        busyThread.start();
        //让它们运行一秒
        Thread.sleep(1000);
        //分别中断两个线程
        sleepThread.interrupt();
        busyThread.interrupt();
        //查看线程的中断标志位
        Thread.sleep(2000);
        System.out.println(&quot;由于中断标志位变为 true 导致运行结束的线程，中断标志位为: &quot; + busyThread.isInterrupted());

        Thread.sleep(1000);
    }
}
</code></pre>

<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。</p>

<p>运行结果如下：</p>

<p><figure><img src="media/15561207868790/15713244513325.png" alt=""/></figure></p>

<p>可以看到：</p>

<ul>
<li>线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false</li>
<li>这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</li>
</ul>

<h3 id="toc_17">(三) public static boolean interrupted()</h3>

<p><code>Thread.interrupted()</code> 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。</p>

<p>因此 <code>Thread.interrupted()</code> 第二次调用永远返回 false。</p>

<p>源码：</p>

<pre class="line-numbers"><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
</code></pre>

<h2 id="toc_18">七、总结</h2>

<p>这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>

<p>我们可以通过下面的图片整体分析线程的生命周期和主要方法：<br/><br/>
<figure><img src="media/15561207868790/15713244633003.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868752.html">
                
                  <h1>Android MVP模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。</p>

<h2 id="toc_0">一、什么是MVP？</h2>

<p>随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。<br/><br/>
MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。<br/><br/>
<figure><img src="media/15561207868752/15713243482376.png" alt=""/></figure></p>

<p>在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。</p>

<h3 id="toc_1">MVP模式的三个角色的作用：</h3>

<ul>
<li>Presenter-中介<br/>
主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。</li>
<li>Model-房主<br/>
Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。</li>
<li>View-用户<br/>
负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。</li>
<li>View interface<br/>
需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
</ul>

<h3 id="toc_2">为什么使用MVP模式</h3>

<p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.<br/><br/>
另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。</p>

<h3 id="toc_3">MVP与MVC的异同</h3>

<p>MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：<br/><br/>
无论MVC或是MVP模式都不可避免地存在一个弊端：<br/><br/>
          <strong>额外的代码复杂度及学习成本。</strong><br/>
这就导致了这两种开发模式也许并不是很小型应用。<br/>
但比起他们的优点，这点弊端基本可以忽略了：</p>

<ul>
<li>(1)降低耦合度</li>
<li>(2)模块职责划分明显</li>
<li>(3)利于测试驱动开发</li>
<li>(4)代码复用</li>
<li>(5)隐藏数据</li>
<li>(6)代码灵活性</li>
</ul>

<h4 id="toc_4">MVP模式：</h4>

<ul>
<li>View不直接与Model交互，而是通过与Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试</li>
<li>通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑<br/></li>
</ul>

<h4 id="toc_5">MVC模式：</h4>

<ul>
<li>View可以与Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享</li>
<li>可以负责决定显示哪个View</li>
</ul>

<h2 id="toc_6">二、MVP的效果</h2>

<p>现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。<br/>
<figure><img src="media/15561207868752/15713243597773.png" alt=""/></figure></p>

<p>页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：<br/><br/>
先来看看java文件的目录结构：<br/><br/>
<figure><img src="media/15561207868752/15713243709164.png" alt=""/></figure> </p>

<p>可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。</p>

<ul>
<li><p>(1)首先我们需要一个UserBean，用来保存用户信息</p>
<pre class="line-numbers"><code class="language-java">public class UserBean {  
private String mFirstName ;  <br/>
private String mLastName ;  <br/>
public UserBean (String firstName, String lastName) {  <br/>
    this.mFirstName = firstName;  <br/>
    this.mLastName = lastName;  <br/>
}  <br/>
public String getFirstName() {  <br/>
    return mFirstName ;  <br/>
}  <br/>
public String getLastName() {  <br/>
    return mLastName ;  <br/>
}<br/>
}
</code></pre></li>
<li><p>(2)再来看看View接口：<br/><br/>
根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</p>
<pre class="line-numbers"><code class="language-java">public interface IUserView {  
   int getID();  <br/>
   String getFristName();  <br/>
   String getLastName();  <br/>
   void setFirstName (String firstName);  <br/>
   void setLastName (String lastName);  <br/>
}
</code></pre></li>
<li><p>(3)Model接口：<br/><br/>
同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</p></li>
</ul>

<pre class="line-numbers"><code class="language-java">public interface IUserModel {  
       void setID (int id);  
       void setFirstName (String firstName);  
       void setLastName (String lastName);  
       int getID();  
       UserBean load (int id);//通过id读取user信息,返回一个UserBean  
}
</code></pre>

<ul>
<li><p>(4)Presenter:<br/><br/>
至此，Presenter就能通过接口与View及Model进行交互了：</p>
<pre class="line-numbers"><code class="language-java">public class UserPresenter {  
   private IUserView mUserView ;  <br/>
   private IUserModel mUserModel ;  <br/>
   public UserPresenter (IUserView view) {  <br/>
         mUserView = view;  <br/>
         mUserModel = new UserModel ();  <br/>
   }  <br/>
   public void saveUser( int id , String firstName , String lastName) {  <br/>
         mUserModel .setID (id );  <br/>
         mUserModel .setFirstName (firstName );  <br/>
         mUserModel .setLastName (lastName );  <br/>
   }  <br/>
   public void loadUser( int id ) {  <br/>
         UserBean user = mUserModel .load (id );  <br/>
         mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示  <br/>
         mUserView .setLastName (user .getLastName ());  <br/>
   }  <br/>
}
</code></pre></li>
<li><p>(5)UserActivity:<br/>
UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量：</p>
<pre class="line-numbers"><code class="language-java">public class UserActivity extends Activity implements OnClickListener,  
         IUserView {  <br/>
   private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ;  <br/>
   private Button mSaveButton , mLoadButton ;  <br/>
   private UserPresenter mUserPresenter ; 
</code></pre></li>
</ul>

<p>重写了OnClick方法：  </p>

<pre class="line-numbers"><code class="language-java">@Override  
       public void onClick(View v) {  
             // TODO Auto-generated method stub  
             switch ( v. getId()) {  
             case R .id .saveButton :  
                   mUserPresenter .saveUser (getID (), getFristName (),  
                               getLastName ());  
                   break ;  
             case R .id .loadButton :  
                   mUserPresenter .loadUser (getID ());  
                   break ;  
             default :  
                   break ;  
             }  
       }
</code></pre>

<p>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>

<h2 id="toc_7">三、MVP的Android伪代码实现</h2>

<ul>
<li>首先需要一个Presenter，作为View和Model的中间人
<figure><img src="media/15561207868752/15713243852476.png" alt=""/></figure></li>
<li>然后你还需要一个View以及ViewImpl接口
<figure><img src="media/15561207868752/15713244021446.png" alt=""/></figure>
<figure><img src="media/15561207868752/15713244211119.png" alt=""/></figure></li>
<li>最后你还需要Model一个ModelImpl接口
<figure><img src="media/15561207868752/15713244316200.png" alt=""/></figure></li>
</ul>

<h2 id="toc_8">四、不必纠结是MVC还是MVP</h2>

<blockquote>
<p>MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~</p>
</blockquote>

<ul>
<li>面向对象<br/>
封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？</li>
<li>封装<br/>
封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private<br/>
属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。</li>
<li>多态<br/>
多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。<br/>
行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。</li>
<li>继承？不！我想说的是对象！<br/>
我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋...等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！</li>
</ul>

<blockquote>
<p>那么MVC、MVP与面向对象有什么关系呢？？  </p>
</blockquote>

<p>首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？</p>

<ul>
<li><p>面向对象View?<br/><br/>
对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！</p></li>
<li><p>面向对象Model?<br/><br/>
同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳...这是不是和MVC中的Model一样，需要处理用户不同的操作。</p></li>
<li><p>面向对象Controller?<br/><br/>
最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。</p></li>
</ul>

<h2 id="toc_9">五、内存泄露问题</h2>

<p>由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？   </p>

<p><strong>答案是不能！</strong> </p>

<p>当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。<br/><br/>
换句话说：Presenter不销毁，Activity就无法正常被回收。  </p>

<p>解决MVP的内存泄露</p>

<p>Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。 <br/>
比如示例代码：<br/><br/>
<strong>Activity</strong>  </p>

<pre class="line-numbers"><code class="language-java">@Override
    public void onDestroy() {
        super.onDestroy();
        mPresenter.destroy();
        mPresenter = null;
    }
</code></pre>

<p><strong>Presenter</strong>  </p>

<pre class="line-numbers"><code class="language-java">public void destroy() {
    view = null;
    if(modle != null) {
        modle.cancleTasks();
        modle = null;
    }
}
</code></pre>

<p><strong>Modle</strong></p>

<pre class="line-numbers"><code class="language-java">public void cancleTasks() {
    // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api
}
</code></pre>

<p>个人总结</p>

<p>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</p>

<h2 id="toc_10">六、总结</h2>

<p>最后重新梳理一下 MVP 的编写方式。</p>

<ul>
<li>1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！</li>
<li>2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。</li>
<li>3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。</li>
<li>4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。</li>
</ul>

<p><strong>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</strong><br/><br/>
<strong>备注：</strong>为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_10.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_12.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android%E6%BA%90%E7%A0%81.html"><strong>Android源码</strong></a>
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15767453112302.html">添加环境变量</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_SVG-full"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
