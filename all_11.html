<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207868901.html">
                
                  <h1>Android Matrix</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Matrix的数学原理</h2>

<p>在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下：  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833750324849.png" alt="1.png"/><figcaption>1.png</figcaption></figure></p>

<p>Matrix的对图像的处理可分为四类基本变换：</p>

<ul>
<li>Translate ————    平移变换</li>
<li>Rotate        ————    旋转变换</li>
<li>Scale     ————    缩放变换</li>
<li>Skew          ————    错切变换</li>
</ul>

<p>从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616374765871.png" alt="20170923150616374765871.png"/><figcaption>20170923150616374765871.png</figcaption></figure></p>

<p>如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616379323870.png" alt="20170923150616379323870.png"/><figcaption>20170923150616379323870.png</figcaption></figure></p>

<p>看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616386136695.png" alt="20170923150616386136695.png"/><figcaption>20170923150616386136695.png</figcaption></figure></p>

<p>x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。</p>

<p>针对每种变换，Android提供了pre、set和post三种操作方式。其中</p>

<ul>
<li>set用于设置Matrix中的值。</li>
<li>pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。</li>
<li>post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</li>
</ul>

<p>除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>

<p>下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。</p>

<h3 id="toc_1">平移变换</h3>

<p>假定有一个点的坐标是 P(\(x_{0}\),\(y_{0}\)) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: \(\Delta\)x = x - \(x_{0}\) and \(\Delta\)y = y - \(y_{0}\)   </p>

<p>如下图所示：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833900863943.png" alt="20170301148833900863943.png"/><figcaption>20170301148833900863943.png</figcaption></figure>  </p>

<p>不难知道：<br/><br/>
x = \(x_{0}\) + \(\Delta\)x<br/><br/>
y = \(y_{0}\) + \(\Delta\)y    </p>

<p>如果用矩阵来表示的话，就可以写成：  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833910576102.png" alt="20170301148833910576102.png"/><figcaption>20170301148833910576102.png</figcaption></figure></p>

<h3 id="toc_2">旋转变换</h3>

<h4 id="toc_3">围绕坐标原点旋转：</h4>

<p>假定有一个点 P(\(x_{0}\),\(y_{0}\)) ，相对坐标原点 \(\theta\) 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833915872714.png" alt="20170301148833915872714.png"/><figcaption>20170301148833915872714.png</figcaption></figure></p>

<p>那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833921797142.png" alt="20170301148833921797142.png"/><figcaption>20170301148833921797142.png</figcaption></figure></p>

<p>如果用矩阵，就可以表示为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833923074578.png" alt="20170301148833923074578.png"/><figcaption>20170301148833923074578.png</figcaption></figure></p>

<h4 id="toc_4">围绕某个点旋转</h4>

<p>如果是围绕某个点 P(\(x_{p}\),\(y_{p}\)) 顺时针旋转 \(\theta\) ，那么可以用矩阵表示为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883392576953.png" alt="2017030114883392576953.png"/><figcaption>2017030114883392576953.png</figcaption></figure><br/><br/>
可以化为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833927146486.png" alt="20170301148833927146486.png"/><figcaption>20170301148833927146486.png</figcaption></figure><br/><br/>
很显然<br/><br/>
1、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833928967061.png" alt="20170301148833928967061.png"/><figcaption>20170301148833928967061.png</figcaption></figure>是将坐标原点移动到点 P(\(x_{p}\),\(y_{p}\)) 后， P(\(x_{0}\),\(y_{0}\)) 的新坐标。  </p>

<p>2、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833934213059.png" alt="20170301148833934213059.png"/><figcaption>20170301148833934213059.png</figcaption></figure>是将上一步变换后的 P(\(x_{0}\),\(y_{0}\)) ，围绕新的坐标原点顺时针旋转 \(\theta\) 。<br/><br/>
3、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833940633954.png" alt="20170301148833940633954.png"/><figcaption>20170301148833940633954.png</figcaption></figure><br/><br/>
经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。<br/><br/>
所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。  </p>

<p>同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。</p>

<h3 id="toc_5">缩放变换</h3>

<p>理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即<br/><br/>
x = \(k_{1}\)\(x_{0}\)<br/><br/>
y = \(k_{2}\)\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833944726575.png" alt="20170301148833944726575.png"/><figcaption>20170301148833944726575.png</figcaption></figure><br/><br/>
缩放变换比较好理解，就不多说了。 </p>

<h3 id="toc_6">错切变换</h3>

<p>错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。<br/><br/>
比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833947362086.png" alt="20170301148833947362086.png"/><figcaption>20170301148833947362086.png</figcaption></figure><br/><br/>
下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833948852458.png" alt="20170301148833948852458.png"/><figcaption>20170301148833948852458.png</figcaption></figure>  </p>

<p>假定一个点 P(\(x_{0}\),\(y_{0}\)) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：<br/><br/>
x = \(x_{0}\) + k\(y_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833957987910.png" alt="20170301148833957987910.png"/><figcaption>20170301148833957987910.png</figcaption></figure><br/><br/>
扩展到3 x 3的矩阵就是下面这样的形式：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833959011272.png" alt="20170301148833959011272.png"/><figcaption>20170301148833959011272.png</figcaption></figure><br/><br/>
同理，对于垂直错切，可以有：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833960187699.png" alt="20170301148833960187699.png"/><figcaption>20170301148833960187699.png</figcaption></figure><br/><br/>
在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833961263046.png" alt="20170301148833961263046.png"/><figcaption>20170301148833961263046.png</figcaption></figure></p>

<h3 id="toc_7">对称变换</h3>

<p>除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P(\(x_{0}\),\(y_{0}\)) 经过对称变换后得到 P(x,y) ，</p>

<p>如果对称轴是x轴，那么，<br/><br/>
x = \(x_{0}\)<br/><br/>
y = -\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834373561338.png" alt="20170301148834373561338.png"/><figcaption>20170301148834373561338.png</figcaption></figure><br/><br/>
如果对称轴是y轴，那么，<br/><br/>
x = -\(x_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834375645689.png" alt="20170301148834375645689.png"/><figcaption>20170301148834375645689.png</figcaption></figure><br/><br/>
如果对称轴是y = x，如图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834376584200.png" alt="20170301148834376584200.png"/><figcaption>20170301148834376584200.png</figcaption></figure><br/><br/>
那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834377595408.png" alt="20170301148834377595408.png"/><figcaption>20170301148834377595408.png</figcaption></figure><br/><br/>
很容易可以解得：<br/><br/>
x = \(y_{0}\)<br/><br/>
y = \(x_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883437925984.png" alt="2017030114883437925984.png"/><figcaption>2017030114883437925984.png</figcaption></figure><br/><br/>
同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834380928745.png" alt="20170301148834380928745.png"/><figcaption>20170301148834380928745.png</figcaption></figure><br/><br/>
特殊地，如果对称轴是y = kx，如下图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834381851581.png" alt="20170301148834381851581.png"/><figcaption>20170301148834381851581.png</figcaption></figure><br/><br/>
那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834382842810.png" alt="20170301148834382842810.png"/><figcaption>20170301148834382842810.png</figcaption></figure><br/><br/>
很容易可解得：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834383638888.png" alt="20170301148834383638888.png"/><figcaption>20170301148834383638888.png</figcaption></figure><br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201703011488343844739.png" alt="201703011488343844739.png"/><figcaption>201703011488343844739.png</figcaption></figure>  </p>

<p>当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。<br/><br/>
如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834385747500.png" alt="20170301148834385747500.png"/><figcaption>20170301148834385747500.png</figcaption></figure><br/><br/>
需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834387269783.png" alt="20170301148834387269783.png"/><figcaption>20170301148834387269783.png</figcaption></figure><br/><br/>
要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438827302.png" alt="2017030114883438827302.png"/><figcaption>2017030114883438827302.png</figcaption></figure><br/><br/>
关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。</p>

<h3 id="toc_8">三角函数</h3>

<pre class="line-numbers"><code class="language-text">public void setSinCos(float sinValue, float cosValue, float px, float py)
public void setSinCos(float sinValue, float cosValue)
</code></pre>

<p>这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616425357007.jpg" alt="20170923150616425357007.jpg"/><figcaption>20170923150616425357007.jpg</figcaption></figure></p>

<p>其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。<br/><br/>
sinValue：对应图中的sin值<br/><br/>
cosValue：对应cos值<br/><br/>
px:中心的x坐标<br/><br/>
py：中心的y坐标<br/><br/>
看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616431122661.png" alt="20170923150616431122661.png"/><figcaption>20170923150616431122661.png</figcaption></figure></p>

<p>看代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrixmatrix = new Matrix();
matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
canvas.drawBitmap(bitmap, matrix, paint);123123
</code></pre>

<h3 id="toc_9">数值操作</h3>

<p>数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。</p>

<h4 id="toc_10">set</h4>

<p><code>void set (Matrix src)</code>没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于<code>reset()</code></p>

<h4 id="toc_11">reset</h4>

<p><code>void reset ()</code>重置当前Matrix(将当前Matrix重置为单位矩阵)。</p>

<h4 id="toc_12">setValues</h4>

<p><code>void setValues (float[] values)</code>setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</p>

<h4 id="toc_13">getValues</h4>

<p><code>void getValues (float[] values)</code>很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。</p>

<h2 id="toc_14">基本方法解析</h2>

<p>讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。</p>

<pre class="line-numbers"><code class="language-java">public Matrix()
public Matrix(Matrix src)
</code></pre>

<p>构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）<br/>
单位矩阵如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616404162667.png" alt="20170923150616404162667.png"/><figcaption>20170923150616404162667.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-java">public boolean isIdentity()//判断是否是单位矩阵
public boolean isAffine()//判断是否是仿射矩阵
</code></pre>

<p>是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。<br/>
首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。<code>public boolean rectStaysRect()</code>判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。<code>public void reset()</code>重置矩阵为单位矩阵。<br/>
<code>public void setTranslate(float dx, float dy)</code>设置平移效果，参数分别是x，y上的平移量。<br/>
效果图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616415154198.png" alt="20170923150616415154198.png"/><figcaption>20170923150616415154198.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
canvas.drawBitmap(bitmap, matrix, paint);

matrix.setTranslate(100, 1000);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h2 id="toc_15">代码验证</h2>

<p>在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438981398.png" alt="2017030114883438981398.png"/><figcaption>2017030114883438981398.png</figcaption></figure><br/><br/>
其尺寸为162 x 251。  </p>

<p>每种变换的结果，请见代码之后的说明。</p>

<pre class="line-numbers"><code class="language-java">import android.app.Activity;  
import android.content.Context;  
import android.graphics.Bitmap;  
import android.graphics.BitmapFactory;  
import android.graphics.Canvas;  
import android.graphics.Matrix;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.MotionEvent;  
import android.view.View;  
import android.view.Window;  
import android.view.WindowManager;  
import android.view.View.OnTouchListener;  
import android.widget.ImageView;  
  
public class TestTransformMatrixActivity extends Activity  
implements  
OnTouchListener  
{  
    private TransformMatrixView view;  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);  
  
        view = new TransformMatrixView(this);  
        view.setScaleType(ImageView.ScaleType.MATRIX);  
        view.setOnTouchListener(this);  
          
        setContentView(view);  
    }  
      
    class TransformMatrixView extends ImageView  
    {  
        private Bitmap bitmap;  
        private Matrix matrix;  
        public TransformMatrixView(Context context)  
        {  
            super(context);  
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);  
            matrix = new Matrix();  
        }  
  
        @Override  
        protected void onDraw(Canvas canvas)  
        {  
            // 画出原图像  
            canvas.drawBitmap(bitmap, 0, 0, null);  
            // 画出变换后的图像  
            canvas.drawBitmap(bitmap, matrix, null);  
            super.onDraw(canvas);  
        }  
  
        @Override  
        public void setImageMatrix(Matrix matrix)  
        {  
            this.matrix.set(matrix);  
            super.setImageMatrix(matrix);  
        }  
          
        public Bitmap getImageBitmap()  
        {  
            return bitmap;  
        }  
    }  
  
    public boolean onTouch(View v, MotionEvent e)  
    {  
        if(e.getAction() == MotionEvent.ACTION_UP)  
        {  
            Matrix matrix = new Matrix();  
            // 输出图像的宽度和高度(162 x 251)  
            Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; +  view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight());  
            // 1. 平移  
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()  
            view.setImageMatrix(matrix);  
              
            // 下面的代码是为了查看matrix中的元素  
            float[] matrixValues = new float[9];  
            matrix.getValues(matrixValues);  
            for(int i = 0; i &lt; 3; ++i)  
            {  
                String temp = new String();  
                for(int j = 0; j &lt; 3; ++j)  
                {  
                    temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
                }  
                Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
            }  
              
  
//          // 2. 旋转(围绕图像的中心点)  
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
              
//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)  
//          matrix.setRotate(45f);  
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 4. 缩放  
//          matrix.setScale(2f, 2f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 5. 错切 - 水平  
//          matrix.setSkew(0.5f, 0f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠           
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 6. 错切 - 垂直  
//          matrix.setSkew(0f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          7. 错切 - 水平 + 垂直  
//          matrix.setSkew(0.5f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 8. 对称 (水平对称)  
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 9. 对称 - 垂直  
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }     
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 10. 对称(对称轴为直线y = x)  
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(),   
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
            view.invalidate();  
        }  
        return true;  
    }  
}
</code></pre>

<p>下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵</p>

<h3 id="toc_16">平移</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834397841218.png" alt="20170301148834397841218.png"/><figcaption>20170301148834397841218.png</figcaption></figure><br/><br/>
输出的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834399578654.png" alt="20170301148834399578654.png"/><figcaption>20170301148834399578654.png</figcaption></figure><br/><br/>
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。</p>

<h3 id="toc_17">旋转(围绕图像的中心点)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834401523528.png" alt="20170301148834401523528.png"/><figcaption>20170301148834401523528.png</figcaption></figure><br/>
输出的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834402755650.png" alt="20170301148834402755650.png"/><figcaption>20170301148834402755650.png</figcaption></figure>  </p>

<p><strong>它实际上是</strong> <br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code><br/><br/>
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
所产生的转换矩阵就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834407336074.png" alt="20170301148834407336074.png"/><figcaption>20170301148834407336074.png</figcaption></figure><br/><br/>
而<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code>的意思就是在上述矩阵的左边再乘以下面的矩阵：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883440946965.png" alt="2017030114883440946965.png"/><figcaption>2017030114883440946965.png</figcaption></figure><br/><br/>
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。<br/><br/>
所以它实际上就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834415832436.png" alt="20170301148834415832436.png"/><figcaption>20170301148834415832436.png</figcaption></figure><br/><br/>
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。</p>

<h3 id="toc_18">旋转(围绕坐标原点旋转，在加上两次平移，效果同2)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834419441235.png" alt="20170301148834419441235.png"/><figcaption>20170301148834419441235.png</figcaption></figure><br/><br/>
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：<br/><br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
等价于<br/><br/>
<code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
其中matrix.setRotate(45f)对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834424050901.png" alt="20170301148834424050901.png"/><figcaption>20170301148834424050901.png</figcaption></figure>  </p>

<p>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834425298280.png" alt="20170301148834425298280.png"/><figcaption>20170301148834425298280.png</figcaption></figure>  </p>

<p>由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。  </p>

<p><code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)</code>对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834426293354.png" alt="20170301148834426293354.png"/><figcaption>20170301148834426293354.png</figcaption></figure><br/><br/>
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。  </p>

<p>所以综合起来，  </p>

<p><code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
对应的矩阵就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834427273695.png" alt="20170301148834427273695.png"/><figcaption>20170301148834427273695.png</figcaption></figure><br/><br/>
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834428250094.png" alt="20170301148834428250094.png"/><figcaption>20170301148834428250094.png</figcaption></figure><br/><br/>
因此，此处变换后的图像和2中变换后的图像时一样的。  </p>

<h3 id="toc_19">缩放变换</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834429635851.png" alt="20170301148834429635851.png"/><figcaption>20170301148834429635851.png</figcaption></figure><br/><br/>
程序所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443077762.png" alt="2017030114883443077762.png"/><figcaption>2017030114883443077762.png</figcaption></figure><br/><br/>
其中第二个矩阵，其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834431597151.png" alt="20170301148834431597151.png"/><figcaption>20170301148834431597151.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。  </p>

<h3 id="toc_20">错切变换(水平错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443394822.png" alt="2017030114883443394822.png"/><figcaption>2017030114883443394822.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834434942666.png" alt="20170301148834434942666.png"/><figcaption>20170301148834434942666.png</figcaption></figure><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443583409.png" alt="2017030114883443583409.png"/><figcaption>2017030114883443583409.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_21">错切变换(垂直错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834436740060.png" alt="20170301148834436740060.png"/><figcaption>20170301148834436740060.png</figcaption></figure>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834438464295.png" alt="20170301148834438464295.png"/><figcaption>20170301148834438464295.png</figcaption></figure><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834439581151.png" alt="20170301148834439581151.png"/><figcaption>20170301148834439581151.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_22">错切变换(水平+垂直错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834440579717.png" alt="20170301148834440579717.png"/><figcaption>20170301148834440579717.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834441593278.png" alt="20170301148834441593278.png"/><figcaption>20170301148834441593278.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444261979.png" alt="2017030114883444261979.png"/><figcaption>2017030114883444261979.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。    </p>

<h3 id="toc_23">对称变换(水平对称)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834443981714.png" alt="20170301148834443981714.png"/><figcaption>20170301148834443981714.png</figcaption></figure>  </p>

<p>代码所输出的两个各矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444616294.png" alt="2017030114883444616294.png"/><figcaption>2017030114883444616294.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834447285645.png" alt="20170301148834447285645.png"/><figcaption>20170301148834447285645.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_24">对称变换(垂直对称)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834448061705.png" alt="20170301148834448061705.png"/><figcaption>20170301148834448061705.png</figcaption></figure>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834449886306.png" alt="20170301148834449886306.png"/><figcaption>20170301148834449886306.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834450718549.png" alt="20170301148834450718549.png"/><figcaption>20170301148834450718549.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_25">对称变换(对称轴为直线y = x)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834451545673.png" alt="20170301148834451545673.png"/><figcaption>20170301148834451545673.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834452594988.png" alt="20170301148834452594988.png"/><figcaption>20170301148834452594988.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834453180954.png" alt="20170301148834453180954.png"/><figcaption>20170301148834453180954.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_26">关于先乘和后乘的问题</h3>

<p>由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834454434026.png" alt="20170301148834454434026.png"/><figcaption>20170301148834454434026.png</figcaption></figure><br/><br/>
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。  </p>

<p>当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate(\(\theta\))，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。  </p>

<h2 id="toc_27">进阶方法解析</h2>

<p>上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：<br/>
preXXXX:以pre开头，例如preTranslate<br/>
postXXXX:以post开头，例如postScale<br/>
他们分别代表了前乘，和后乘。看一段代码：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
matrix.setTranslate(100, 1000);
matrix.preScale(0.5f, 0.5f);
</code></pre>

<p>这里matrix前乘了一个scale矩阵，换算成数学式如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061645158599.png" alt="2017092315061645158599.png"/><figcaption>2017092315061645158599.png</figcaption></figure></p>

<p>从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。<br/>
后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616454160642.png" alt="20170923150616454160642.png"/><figcaption>20170923150616454160642.png</figcaption></figure></p>

<p>可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。<br/>
来看看他们对应的效果图：<br/><br/>
<strong>前乘：</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616460519787.png" alt="20170923150616460519787.png"/><figcaption>20170923150616460519787.png</figcaption></figure></p>

<p><strong>后乘：</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616463626763.png" alt="20170923150616463626763.png"/><figcaption>20170923150616463626763.png</figcaption></figure></p>

<p>可以明显看到，后乘的平移距离受了影响。<br/>
了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。</p>

<h2 id="toc_28">其他方法解析</h2>

<p>matrix除了上面的方法外，还有一些其他的方法，这里依次解析</p>

<h3 id="toc_29">setRectToRect</h3>

<p><code>public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</code>将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。<br/><br/>
<code>ScaleToFit</code> 有如下四个值：<br/><br/>
<code>FILL</code>: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br/><br/>
<code>START</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br/><br/>
<code>CENTER</code>: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br/><br/>
<code>END</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。<br/><br/>
这里使用谷歌的api demo的图片作为例子：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616472114007.png" alt="20170923150616472114007.png"/><figcaption>20170923150616472114007.png</figcaption></figure></p>

<h3 id="toc_30">setPolyToPoly</h3>

<p><code>public boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)</code>通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。<br/><br/>
下面通过例子分别说明1到4个点的可以达到的效果：</p>

<h4 id="toc_31">1个点，平移</h4>

<p>只指定一个点，可以达到平移效果：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616478770235.png" alt="20170923150616478770235.png"/><figcaption>20170923150616478770235.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">float[] src = {0, 0};
int DX = 300;
float[] dst = {0 + DX, 0 + DX};
matrix.setPolyToPoly(src, 0, dst, 0, 1);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h4 id="toc_32">2个点，旋转或者缩放</h4>

<p>两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616485313647.png" alt="20170923150616485313647.png"/><figcaption>20170923150616485313647.png</figcaption></figure></p>

<p>代码如下</p>

<pre class="line-numbers"><code class="language-java">int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {bw / 2, bh / 2, bw, 0};
float[] dst = {bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2};
matrix.setPolyToPoly(src, 0, dst, 0, 2);
canvas.drawBitmap(bitmap, matrix, paint);123456123456
</code></pre>

<p>图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。</p>

<h4 id="toc_33">3个点，错切</h4>

<p>使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。<br/><br/>
看图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616492474600.png" alt="20170923150616492474600.png"/><figcaption>20170923150616492474600.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0,0, 0, bh,bw,bh};
float[] dst = {0, 0, 200, bh, bw + 200, bh};
matrix.setPolyToPoly(src, 0, dst, 0, 3);
canvas.drawBitmap(bitmap, matrix, paint);12345671234567
</code></pre>

<h4 id="toc_34">4个点，透视</h4>

<p>透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。<br/>
我们看下面的例子，更容易理解：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616497319034.png" alt="20170923150616497319034.png"/><figcaption>20170923150616497319034.png</figcaption></figure></p>

<p>图片看起来好像倾斜了，实现特别简单：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0, 0, 0, bh, bw, bh, bw, 0};
int DX = 100;
float[] dst = {0 + DX, 0, 0, bh, bw, bh, bw - DX, 0};
matrix.setPolyToPoly(src, 0, dst, 0, 4);
canvas.drawBitmap(bitmap, matrix, paint);1234567812345678
</code></pre>

<p>可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。</p>

<h3 id="toc_35">invert</h3>

<p><code>public boolean invert(Matrix inverse)</code>反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。<br/><br/>
反转前后有什么效果，我们来看看示例：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616503373152.png" alt="20170923150616503373152.png"/><figcaption>20170923150616503373152.png</figcaption></figure></p>

<p>可以看到，反转之后，其实是对效果的一种反转。</p>

<h3 id="toc_36">mapPoints</h3>

<pre class="line-numbers"><code class="language-java">public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)
public void mapPoints(float[] dst, float[] src)
public void mapPoints(float[] pts)
</code></pre>

<p>映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。</p>

<ul>
<li>dst：指定写入的数组<br/></li>
<li>dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1</li>
<li>src：指定要计算的点</li>
<li>srcIndex：要计算的点的索引</li>
<li>pointCount：需要计算的点的个数，每个点有两个值，x和y。</li>
</ul>

<h3 id="toc_37">mapVectors</h3>

<pre class="line-numbers"><code class="language-java">public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)
public void mapVectors(float[] dst, float[] src)
public void mapVectors(float[] vecs)

</code></pre>

<p>与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。</p>

<h3 id="toc_38">mapRect</h3>

<pre class="line-numbers"><code class="language-java">public boolean mapRect(RectF dst, RectF src)
public boolean mapRect(RectF rect)
</code></pre>

<p>返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。</p>

<h3 id="toc_39">mapRadius</h3>

<p><code>public float mapRadius(float radius)</code>返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868826.html">
                
                  <h1>Android 冷启动实现APP秒开</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在阅读这篇文章之前，首先需要理解几个东西：  </p>

<ul>
<li>1、什么是Android的冷启动时间？<br/>
冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。</li>
<li>2、在冷启动的时间段内发生了什么？<br/>
首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。<br/></li>
</ul>

<p>来看下效果图：<br/><br/>
<strong>未优化：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227548242189443-4a70e91b2e124b48.gif" alt="20170227548242189443-4a70e91b2e124b48.gif"/><figcaption>20170227548242189443-4a70e91b2e124b48.gif</figcaption></figure></p>

<p><strong>优化方案一：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227487382189443-4829eba35492d39b.gif" alt="20170227487382189443-4829eba35492d39b.gif"/><figcaption>20170227487382189443-4829eba35492d39b.gif</figcaption></figure></p>

<p><strong>优化方案二：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227662152189443-c861191c8a80cd94.gif" alt="20170227662152189443-c861191c8a80cd94.gif"/><figcaption>20170227662152189443-c861191c8a80cd94.gif</figcaption></figure></p>

<h2 id="toc_1">历史原因</h2>

<p>当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是<strong>Preview Window</strong>,即预览窗口。</p>

<p>好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。</p>

<p>但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！</p>

<p>所以，下面我们就来聊聊这个问题的解决方案。</p>

<h2 id="toc_2">解决方案</h2>

<p>既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了</p>

<p>所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。</p>

<h3 id="toc_3">方案一 ：开历史倒车</h3>

<p>这个方案就是禁止加载Preview Window，具体做法如下：</p>

<p>style.xml</p>

<style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar">
   <item name="android:windowDisablePreview">true</item>
</style>

<p>将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。</p>

<p>结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。</p>

<p>我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。</p>

<h3 id="toc_4">方案二：自定义Preview Window</h3>

<h4 id="toc_5">1、透明启动</h4>

<p>将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会&quot;立即&quot;进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。<br/>
<code>&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;</code><br/>
透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常：</p>

<blockquote>
<p>java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</p>
</blockquote>

<p>这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单：</p>

<ul>
<li>1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity</li>
<li>2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
            setTheme(R.style.AppTheme);
            super.onCreate(savedInstanceState);
    }
}
</code></pre>

<h4 id="toc_6">2、Logo图片启动</h4>

<p>将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。<br/><br/>
具体方法如下：</p>

<p>style.xlm</p>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;APPTheme&quot; parent=&quot;@android:style/Theme.Holo.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_icon&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。</p>

<p>splash_icon.xml</p>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:opacity=&quot;opaque&quot;&gt;
    &lt;item android:drawable=&quot;@color/white&quot;/&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/qq&quot;/&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>

<p>这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022724594838b008fdb18f761ede8.gif" alt="2017022724594838b008fdb18f761ede8.gif"/><figcaption>2017022724594838b008fdb18f761ede8.gif</figcaption></figure></p>

<p>上面的2种做法，我们都需要将Theme引入对应的Activity</p>

<pre class="line-numbers"><code class="language-java">&lt;activity
    android:name=&quot;.app.main.MainActivity&quot;
    android:theme=&quot;@style/AppWelcome&quot;
    android:screenOrientation=&quot;portrait&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的，</p>

<p>所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。</p>

<p>在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。</p>

<h3 id="toc_7">方案三：自定义Preview Window增强版</h3>

<p>废话少说，我们先来看效果<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227597652f5ba2feffca1ca31a8c.gif" alt="20170227597652f5ba2feffca1ca31a8c.gif"/><figcaption>20170227597652f5ba2feffca1ca31a8c.gif</figcaption></figure></p>

<p>有了动画之后，界面切换顺畅了许多。<br/>
上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看<a href="https://github.com/ladingwu/Splash">本次项目的demo</a>，我们重点来聊一聊思路。</p>

<p>在这里我们需要明确一点的是，<strong>preview window</strong> 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 <strong>Preview Window</strong> 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 <strong>Preview Window</strong> 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。</p>

<p>然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 <strong>Preview Window</strong> 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。</p>

<p>好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空：</p>

<p>SplashActivity.java</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    //将window的背景图设置为空
    getWindow().setBackgroundDrawable(null);
    super.onCreate(savedInstanceState);
}
</code></pre>

<h2 id="toc_8">关于启动优化</h2>

<p>上面的做法其实可以达到&quot;秒开&quot;APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。<br/><br/>
这里给出几点建议：  </p>

<ul>
<li>1、不要让Application参与业务的操作</li>
<li>2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到&quot;确实该使用的时候再去创建&quot;亦或者是数据库的一些操作。</li>
<li>3、不要以静态变量的方式在Application中保存数据等。</li>
</ul>

<p>当然这是绝对的理想主义，把上面的&quot;不要&quot;2字之前添上&quot;尽量&quot;2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。</p>

<p>对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。</p>

<h2 id="toc_9">总结</h2>

<p>到这里，关于Android启动页的相关问题就都讲完了。<br/><br/>
最终的高清的效果图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201702274812409e2d6cccbbdf90fb06f.gif" alt="201702274812409e2d6cccbbdf90fb06f.gif"/><figcaption>201702274812409e2d6cccbbdf90fb06f.gif</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868861.html">
                
                  <h1>Android Studio 关联 Bitbucket</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。</p>

<h2 id="toc_1">Bitbucket简介</h2>

<p>BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势：</p>

<ul>
<li>支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。</li>
<li>完全免费的闭源项目，还支持5人以内的合作开发。</li>
<li>支持中文。</li>
<li>官方的git工具SourceTree比GitHub for windows好用。</li>
</ul>

<h2 id="toc_2">使用步骤</h2>

<h3 id="toc_3">一、安装Git</h3>

<p>安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联：</p>

<p>Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201702281488283957706.png" alt="201702281488283957706.png"/><figcaption>201702281488283957706.png</figcaption></figure></p>

<h3 id="toc_4">二、在Bitbucket网站创建远程仓库</h3>

<p>在Bitbucket网站上创建仓库<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828409731931.png" alt="20170228148828409731931.png"/><figcaption>20170228148828409731931.png</figcaption></figure></p>

<p>记录下远程仓库的URL，后面会用到<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828429892892.png" alt="20170228148828429892892.png"/><figcaption>20170228148828429892892.png</figcaption></figure></p>

<h3 id="toc_5">三、在AndroidStudio中创建新项目</h3>

<p>首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828440052273.png" alt="20170228148828440052273.png"/><figcaption>20170228148828440052273.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828442348214.png" alt="20170228148828442348214.png"/><figcaption>20170228148828442348214.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828458717975.png" alt="20170228148828458717975.png"/><figcaption>20170228148828458717975.png</figcaption></figure>  </p>

<p>接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828477916716.png" alt="20170228148828477916716.png"/><figcaption>20170228148828477916716.png</figcaption></figure></p>

<p>接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828487943329.png" alt="20170228148828487943329.png"/><figcaption>20170228148828487943329.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148828497542400.png" alt="20170228148828497542400.png"/><figcaption>20170228148828497542400.png</figcaption></figure>  </p>

<p>至此创建项目就完成了</p>

<h3 id="toc_6">四、AndroidStudio中将项目提交并推送到远程仓库</h3>

<p>进入AS项目中，选择VCS–&gt;Git-&gt;Commit File<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148829231635346.png" alt="20170228148829231635346.png"/><figcaption>20170228148829231635346.png</figcaption></figure></p>

<p>填写提交信息后，选择commit and Push<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148829246433438.png" alt="20170228148829246433438.png"/><figcaption>20170228148829246433438.png</figcaption></figure></p>

<p>之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148829325493022.png" alt="20170228148829325493022.png"/><figcaption>20170228148829325493022.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170228148829440667283.png" alt="20170228148829440667283.png"/><figcaption>20170228148829440667283.png</figcaption></figure></p>

<p>到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。</p>

<h3 id="toc_7">五、别忘了给Bitbucket添加SSH密钥</h3>

<p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br/><br/>
使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868790.html">
                
                  <h1>Android Thread</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、线程简介</h2>

<p>现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。</p>

<p>一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。</p>

<p>想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。</p>

<p>如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。</p>

<h2 id="toc_1">二、线程创建的三种方式</h2>

<p>送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式：</p>

<h3 id="toc_2">(一) 实现 Runnable 接口</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest0 {

    /**
     * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务
     */
    static class Task implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
            Thread shixinzhang = new Thread(new Task(), &quot;外卖任务 &quot; + i);
            //3.命令送餐员出发！
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下：</p>

<p><code>外卖任务 3: 您的外卖已送达</code><br/><br/>
<code>外卖任务 1: 您的外卖已送达</code><br/><br/>
<code>外卖任务 0: 您的外卖已送达</code><br/><br/>
<code>外卖任务 2: 您的外卖已送达</code>  </p>

<p>可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。</p>

<p>直接在 main 中调用 run()：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 4; i++) {
        //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
        Task task = new Task();
        Thread shixinzhang = new Thread(task, &quot;外卖任务 &quot; + i);
        //3.直接执行任务
        task.run();
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code>  </p>

<h3 id="toc_3">(二) 继承 Thread，重写其 run 方法</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest1 {
    /**
     * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务
     */
    static class DeliverThread extends Thread{

        public DeliverThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，同时起个名
            DeliverThread shixinzhang = new DeliverThread(&quot;外卖任务&quot; + i);
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>外卖任务1: 您的外卖已送达</code><br/><br/>
<code>外卖任务3: 您的外卖已送达</code><br/><br/>
<code>外卖任务0: 您的外卖已送达</code><br/><br/>
<code>外卖任务2: 您的外卖已送达</code>  </p>

<p>为什么直接继承 Thread 也可以在子线程中执行任务呢？</p>

<p>从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：<br/><br/>
<code>public class Thread implements Runnable</code>  </p>

<p>它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。</p>

<p>线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。</p>

<p>等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。</p>

<h3 id="toc_4">(三) 实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果</h3>

<pre class="line-numbers"><code class="language-java">public class CallableTest {
    /**
     * 实现 Callable 接口
     */
    static class DeliverCallable implements Callable&lt;String&gt; {
        /**
         * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常
         * @return
         * @throws Exception
         */
        @Override
        public String call() throws Exception {
            Thread.sleep(new Random().nextInt(10000));
            System.out.println(Thread.currentThread().getName() + &quot;：您的外卖已送达&quot;);
            return Thread.currentThread().getName() + &quot; 送达时间：&quot; + System.currentTimeMillis() + &quot;\n&quot;;
        }
    }

    /**
     * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行
     * @param args
     */
    public static void main(String[] args) {
        List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4);
        for (int i = 0; i &lt; 4; i++) {
            DeliverCallable callable = new DeliverCallable();
            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
            futureTasks.add(futureTask);

            Thread thread = new Thread(futureTask, &quot;送餐员 &quot; + i);
            thread.start();
        }

        StringBuilder results = new StringBuilder();
        futureTasks.forEach(futureTask -&gt; {
            try {
                //获取线程返回结果，没返回就会阻塞
                results.append(futureTask.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        System.out.println(System.currentTimeMillis() + &quot; 得到结果：\n&quot; + results);
    }
}
</code></pre>

<p>第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。</p>

<p>运行结果：  </p>

<pre class="line-numbers"><code class="language-text">送餐员 3：您的外卖已送达  
送餐员 1：您的外卖已送达  
送餐员 0：您的外卖已送达  
送餐员 2：您的外卖已送达  
1487998155430 得到结果： 
送餐员 0 送达时间：1487998155076 
送餐员 1 送达时间：1487998150453 
送餐员 2 送达时间：1487998155430 
送餐员 3 送达时间：1487998149779
</code></pre>

<h2 id="toc_5">三、线程的基本属性</h2>

<h3 id="toc_6">(一) 优先级</h3>

<p>Thread 有个优先级字段：private int priority</p>

<p>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。</p>

<p>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。</p>

<p>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。</p>

<p>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久； <br/>
频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。  </p>

<pre class="line-numbers"><code class="language-java"> public final static int MIN_PRIORITY = 1;

 //线程的默认优先级
 public final static int NORM_PRIORITY = 5;

 public final static int MAX_PRIORITY = 10;
</code></pre>

<blockquote>
<p>线程优先级只是对操作系统分配时间片的建议。 <br/>
虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>

<h3 id="toc_7">(二) 守护线程</h3>

<p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。</p>

<p>Thread 中有个布尔值标识当前线程是否为守护线程：</p>

<p><code>private boolean     daemon = false;</code></p>

<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>

<pre class="line-numbers"><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}

public final boolean isDaemon() {
    return daemon;
}
</code></pre>

<blockquote>
<p>Daemon 属性需要在调用线程的 start() 方法之前调用。</p>
</blockquote>

<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。</p>

<p><strong>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。</strong></p>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class DaemonTreadTest0 {
    static class DaemonThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName() + &quot; finally is called!&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DaemonThread thread = new DaemonThread();
        thread.setDaemon(true);
        thread.start();
    }
}
</code></pre>

<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。</p>

<p>如果将setDaemon方法注释掉，就会发现有运行结果:</p>

<p><code>Thread-0 finally is called!</code></p>

<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。</p>

<h2 id="toc_8">四、线程的生命周期</h2>

<p>线程具有如下几个状态：</p>

<table>
<thead>
<tr>
<th>线程状态</th>
<th style="text-align: center">介绍</th>
<th style="text-align: left">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>NEW</td>
<td style="text-align: center">新创建</td>
<td style="text-align: left">还未调用 start() 方法；还不是活着的 (alive)</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align: center">就绪的</td>
<td style="text-align: left">调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)</td>
</tr>
<tr>
<td>RUNNING</td>
<td style="text-align: center">运行中</td>
<td style="text-align: left">线程获得 CPU 资源，正在执行任务；活着的</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align: center">阻塞的</td>
<td style="text-align: left">线程阻塞于锁或者调用了 sleep；活着的</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align: center">等待中</td>
<td style="text-align: left">线程由于某种原因等待其他线程；或者的</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align: center">超时等待</td>
<td style="text-align: left">与 WAITING 的区别是可以在特定时间后自动返回；活着的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align: center">终止</td>
<td style="text-align: left">执行完毕或者被其他线程杀死；不是活着的</td>
</tr>
</tbody>
</table>

<p>有几点注意：</p>

<ul>
<li>Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE</li>
<li>三个让线程进入 WAITING 状态的方法 
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>Lock.lock()</li>
</ul></li>
</ul>

<p><strong>Java 中关于“线程是否活着”的定义</strong></p>

<p>Thread 中有个判断是否为活着的方法：<br/><br/>
<code>public final native boolean isAlive()</code></p>

<p>Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。</p>

<h2 id="toc_9">五、线程的关键方法</h2>

<h3 id="toc_10">(一) Thread.sleep()</h3>

<p>Thread.sleep() 是一个静态方法：</p>

<p><code>public static native void sleep(long millis) throws InterruptedException;</code></p>

<p>sleep() 方法：</p>

<ul>
<li>使当前所在线程进入阻塞</li>
<li>只是让出 CPU ，并没有释放对象锁</li>
<li>由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数</li>
<li>如果被中断会抛出 InterruptedException</li>
</ul>

<p><strong>注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</strong></p>

<h3 id="toc_11">(二) Object.wait()</h3>

<p>与 Thread.sleep() 容易混淆的是 Object.wait() 方法。</p>

<p>Object.wait() 方法：</p>

<ul>
<li>让出 CPU，释放对象锁</li>
<li>在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用</li>
<li>使该线程进入该对象监视器的等待队列</li>
</ul>

<h3 id="toc_12">(三) Thread.yield()</h3>

<p>Thread. yield() 也是一个静态方法：</p>

<p><code>public static native void yield();</code></p>

<p>“Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。</p>

<ul>
<li>和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</li>
<li>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。</li>
</ul>

<blockquote>
<p>yield() 一般使用较少。</p>
</blockquote>

<h3 id="toc_13">(四) Thread.join()</h3>

<p>Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。</p>

<blockquote>
<p>线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。</p>
</blockquote>

<p>比如下述代码：</p>

<pre class="line-numbers"><code class="language-java">Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;thread is running!&quot;);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
thread.start();
thread.join();
System.out.println(&quot;main thread &quot;);
</code></pre>

<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>

<blockquote>
<p>thread is running! <br/>
main thread</p>
</blockquote>

<p>Thread.join 源码：</p>

<pre class="line-numbers"><code class="language-java">//无参方法
public final void join() throws InterruptedException {
    join(0);
}
//有参方法，表示等待 millis 毫秒后自动返回
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束
public final synchronized void join(long millis, int nanos)
throws InterruptedException {

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
        millis++;
    }

    join(millis);
}
</code></pre>

<p>通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。</p>

<p>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>

<h2 id="toc_14">六、线程的中断</h2>

<p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest1 {
    static class InterruptThread extends Thread{
        private boolean running;

        public InterruptThread(boolean running) {
            this.running = running;
        }

        public boolean isRunning() {
            return running;
        }

        public void setRunning(boolean running) {
            this.running = running;
        }

        @Override
        public void run() {
            while (running){
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread(true);
        thread.start();

        Thread.sleep(5000);
        thread.setRunning(false);
    }
}
</code></pre>

<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。 <br/>
因此我们可以通过修改这个标志位为 false 来中断该线程。</p>

<p>其实 Thread 内部也为我们提供了同样的机制 ：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align: center">方法介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>public void interrupt()</td>
<td style="text-align: center">试图中断调用线程，设置中断标志位为 false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td style="text-align: center">返回调用线程是否被中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td style="text-align: center">返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">(一) public void interrupt()</h3>

<p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。</p>

<p>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest2 {

    static class UnInterruptThread extends Thread{
        public UnInterruptThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    static class  UnInterruptRunnable implements Runnable{

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UnInterruptThread thread = new UnInterruptThread(&quot;无法中断的线程&quot;);
//        Thread thread = new Thread(new UnInterruptRunnable(), &quot;无法中断&quot;);
        thread.start();

        //先让它执行一秒
        Thread.sleep(1000);

        thread.interrupt();

        //不立即退出
        Thread.sleep(3000);
    }
}
</code></pre>

<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！</p>

<p>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>

<h3 id="toc_16">(二) public boolean isInterrupted()</h3>

<p>我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。</p>

<blockquote>
<p>isInterrupted() 在刚创建时默认为 false 不用多说； <br/>
线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false； <br/>
线程结束后，线程的中断标志位也会复位为 false。</p>
</blockquote>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">/**
 * 线程中断练习
 * Created by zhangshixin on 17/2/25.
 * http://blog.csdn.net/u011240877
 */
public class ThreadInterruptTest {
    /**
     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException
     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置
     */
    static class SleepThread extends Thread{
        public SleepThread(String s) {
            setName(s);
        }
        @Override
        public void run() {
            while (!isInterrupted()){
                try {
                    Thread.sleep(500);
                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println(&quot;SleepRunner 在 sleep 时被中断了，此时中断标志位为：&quot; + isInterrupted());
                }
            }
        }
    }

    /**
     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置
     */
    static class BusyThread extends Thread{

        public BusyThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (!isInterrupted()){
                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SleepThread sleepThread = new SleepThread(&quot;SleepRunner：&quot;);
        BusyThread busyThread = new BusyThread(&quot;BusyRunner：&quot;);
        //新创建的线程 中断标志为 false
        System.out.println(&quot;SleepThread 新创建时的中断标志位：&quot; + sleepThread.isInterrupted());

        Thread.sleep(2000);
        //启动两个线程
        sleepThread.start();
        busyThread.start();
        //让它们运行一秒
        Thread.sleep(1000);
        //分别中断两个线程
        sleepThread.interrupt();
        busyThread.interrupt();
        //查看线程的中断标志位
        Thread.sleep(2000);
        System.out.println(&quot;由于中断标志位变为 true 导致运行结束的线程，中断标志位为: &quot; + busyThread.isInterrupted());

        Thread.sleep(1000);
    }
}
</code></pre>

<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。</p>

<p>运行结果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148820124316783.png" alt="20170227148820124316783.png"/><figcaption>20170227148820124316783.png</figcaption></figure></p>

<p>可以看到：</p>

<ul>
<li>线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false</li>
<li>这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</li>
</ul>

<h3 id="toc_17">(三) public static boolean interrupted()</h3>

<p><code>Thread.interrupted()</code> 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。</p>

<p>因此 <code>Thread.interrupted()</code> 第二次调用永远返回 false。</p>

<p>源码：</p>

<pre class="line-numbers"><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
</code></pre>

<h2 id="toc_18">七、总结</h2>

<p>这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>

<p>我们可以通过下面的图片整体分析线程的生命周期和主要方法：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148820130911992.png" alt="20170227148820130911992.png"/><figcaption>20170227148820130911992.png</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868752.html">
                
                  <h1>Android MVP模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。</p>

<h2 id="toc_0">一、什么是MVP？</h2>

<p>随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。<br/><br/>
MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819849456583.png" alt="20170227148819849456583.png"/><figcaption>20170227148819849456583.png</figcaption></figure> </p>

<p>在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。</p>

<h3 id="toc_1">MVP模式的三个角色的作用：</h3>

<ul>
<li>Presenter-中介<br/>
主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。</li>
<li>Model-房主<br/>
Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。</li>
<li>View-用户<br/>
负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。</li>
<li>View interface<br/>
需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
</ul>

<h3 id="toc_2">为什么使用MVP模式</h3>

<p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.<br/><br/>
另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。</p>

<h3 id="toc_3">MVP与MVC的异同</h3>

<p>MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：<br/><br/>
无论MVC或是MVP模式都不可避免地存在一个弊端：<br/><br/>
          <strong>额外的代码复杂度及学习成本。</strong><br/>
这就导致了这两种开发模式也许并不是很小型应用。<br/>
但比起他们的优点，这点弊端基本可以忽略了：</p>

<ul>
<li>(1)降低耦合度</li>
<li>(2)模块职责划分明显</li>
<li>(3)利于测试驱动开发</li>
<li>(4)代码复用</li>
<li>(5)隐藏数据</li>
<li>(6)代码灵活性</li>
</ul>

<h4 id="toc_4">MVP模式：</h4>

<ul>
<li>View不直接与Model交互，而是通过与Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试</li>
<li>通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑<br/></li>
</ul>

<h4 id="toc_5">MVC模式：</h4>

<ul>
<li>View可以与Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享</li>
<li>可以负责决定显示哪个View</li>
</ul>

<h2 id="toc_6">二、MVP的效果</h2>

<p>现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819875942251.png" alt="20170227148819875942251.png"/><figcaption>20170227148819875942251.png</figcaption></figure>  </p>

<p>页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：<br/><br/>
先来看看java文件的目录结构：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819877439872.png" alt="20170227148819877439872.png"/><figcaption>20170227148819877439872.png</figcaption></figure>  </p>

<p>可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。</p>

<ul>
<li><p>(1)首先我们需要一个UserBean，用来保存用户信息</p>
<pre class="line-numbers"><code class="language-java">public class UserBean {  
private String mFirstName ;  <br/>
private String mLastName ;  <br/>
public UserBean (String firstName, String lastName) {  <br/>
    this.mFirstName = firstName;  <br/>
    this.mLastName = lastName;  <br/>
}  <br/>
public String getFirstName() {  <br/>
    return mFirstName ;  <br/>
}  <br/>
public String getLastName() {  <br/>
    return mLastName ;  <br/>
}<br/>
}
</code></pre></li>
<li><p>(2)再来看看View接口：<br/><br/>
根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</p>
<pre class="line-numbers"><code class="language-java">public interface IUserView {  
   int getID();  <br/>
   String getFristName();  <br/>
   String getLastName();  <br/>
   void setFirstName (String firstName);  <br/>
   void setLastName (String lastName);  <br/>
}
</code></pre></li>
<li><p>(3)Model接口：<br/><br/>
同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</p></li>
</ul>

<pre class="line-numbers"><code class="language-java">public interface IUserModel {  
       void setID (int id);  
       void setFirstName (String firstName);  
       void setLastName (String lastName);  
       int getID();  
       UserBean load (int id);//通过id读取user信息,返回一个UserBean  
}
</code></pre>

<ul>
<li><p>(4)Presenter:<br/><br/>
至此，Presenter就能通过接口与View及Model进行交互了：</p>
<pre class="line-numbers"><code class="language-java">public class UserPresenter {  
   private IUserView mUserView ;  <br/>
   private IUserModel mUserModel ;  <br/>
   public UserPresenter (IUserView view) {  <br/>
         mUserView = view;  <br/>
         mUserModel = new UserModel ();  <br/>
   }  <br/>
   public void saveUser( int id , String firstName , String lastName) {  <br/>
         mUserModel .setID (id );  <br/>
         mUserModel .setFirstName (firstName );  <br/>
         mUserModel .setLastName (lastName );  <br/>
   }  <br/>
   public void loadUser( int id ) {  <br/>
         UserBean user = mUserModel .load (id );  <br/>
         mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示  <br/>
         mUserView .setLastName (user .getLastName ());  <br/>
   }  <br/>
}
</code></pre></li>
<li><p>(5)UserActivity:<br/>
UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量：</p>
<pre class="line-numbers"><code class="language-java">public class UserActivity extends Activity implements OnClickListener,  
         IUserView {  <br/>
   private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ;  <br/>
   private Button mSaveButton , mLoadButton ;  <br/>
   private UserPresenter mUserPresenter ; 
</code></pre></li>
</ul>

<p>重写了OnClick方法：  </p>

<pre class="line-numbers"><code class="language-java">@Override  
       public void onClick(View v) {  
             // TODO Auto-generated method stub  
             switch ( v. getId()) {  
             case R .id .saveButton :  
                   mUserPresenter .saveUser (getID (), getFristName (),  
                               getLastName ());  
                   break ;  
             case R .id .loadButton :  
                   mUserPresenter .loadUser (getID ());  
                   break ;  
             default :  
                   break ;  
             }  
       }
</code></pre>

<p>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>

<h2 id="toc_7">三、MVP的Android伪代码实现</h2>

<ul>
<li>首先需要一个Presenter，作为View和Model的中间人
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819813736752.png" alt="20170227148819813736752.png"/><figcaption>20170227148819813736752.png</figcaption></figure></li>
<li>然后你还需要一个View以及ViewImpl接口
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022714881981564410.png" alt="2017022714881981564410.png"/><figcaption>2017022714881981564410.png</figcaption></figure>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819816221120.png" alt="20170227148819816221120.png"/><figcaption>20170227148819816221120.png</figcaption></figure></li>
<li>最后你还需要Model一个ModelImpl接口
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819817269813.png" alt="20170227148819817269813.png"/><figcaption>20170227148819817269813.png</figcaption></figure></li>
</ul>

<h2 id="toc_8">四、不必纠结是MVC还是MVP</h2>

<blockquote>
<p>MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~</p>
</blockquote>

<ul>
<li>面向对象<br/>
封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？</li>
<li>封装<br/>
封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private<br/>
属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。</li>
<li>多态<br/>
多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。<br/>
行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。</li>
<li>继承？不！我想说的是对象！<br/>
我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋...等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！</li>
</ul>

<blockquote>
<p>那么MVC、MVP与面向对象有什么关系呢？？  </p>
</blockquote>

<p>首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？</p>

<ul>
<li><p>面向对象View?<br/><br/>
对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！</p></li>
<li><p>面向对象Model?<br/><br/>
同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳...这是不是和MVC中的Model一样，需要处理用户不同的操作。</p></li>
<li><p>面向对象Controller?<br/><br/>
最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。</p></li>
</ul>

<h2 id="toc_9">五、内存泄露问题</h2>

<p>由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？   </p>

<p><strong>答案是不能！</strong> </p>

<p>当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。<br/><br/>
换句话说：Presenter不销毁，Activity就无法正常被回收。  </p>

<p>解决MVP的内存泄露</p>

<p>Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。 <br/>
比如示例代码：<br/><br/>
<strong>Activity</strong>  </p>

<pre class="line-numbers"><code class="language-java">@Override
    public void onDestroy() {
        super.onDestroy();
        mPresenter.destroy();
        mPresenter = null;
    }
</code></pre>

<p><strong>Presenter</strong>  </p>

<pre class="line-numbers"><code class="language-java">public void destroy() {
    view = null;
    if(modle != null) {
        modle.cancleTasks();
        modle = null;
    }
}
</code></pre>

<p><strong>Modle</strong></p>

<pre class="line-numbers"><code class="language-java">public void cancleTasks() {
    // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api
}
</code></pre>

<p>个人总结</p>

<p>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</p>

<h2 id="toc_10">六、总结</h2>

<p>最后重新梳理一下 MVP 的编写方式。</p>

<ul>
<li>1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！</li>
<li>2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。</li>
<li>3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。</li>
<li>4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。</li>
</ul>

<p><strong>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</strong><br/><br/>
<strong>备注：</strong>为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868717.html">
                
                  <h1>Android Wi-Fi 直连</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多</p>

<h2 id="toc_0">API 概述</h2>

<ul>
<li>Wi-Fi直连的方法<br/>
类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备<br/></li>
</ul>

<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>initialize()</td>
<td style="text-align: center">在Wi-Fi框架中注册，必须在其他方法之前调用</td>
</tr>
<tr>
<td>connect()</td>
<td style="text-align: center">和另外的直连设备连接</td>
</tr>
<tr>
<td>cancelConnect()</td>
<td style="text-align: center">取消正在连接的动作</td>
</tr>
<tr>
<td>requestConnectInfo()</td>
<td style="text-align: center">请求已经连接的信息</td>
</tr>
<tr>
<td>createGroup()</td>
<td style="text-align: center">创建直连的设备组</td>
</tr>
<tr>
<td>removeGroup()</td>
<td style="text-align: center">删除当前的设置组</td>
</tr>
<tr>
<td>requestGroupInfo()</td>
<td style="text-align: center">请求当前组的信息</td>
</tr>
<tr>
<td>discoverPeers()</td>
<td style="text-align: center">初始化搜索</td>
</tr>
<tr>
<td>requestPeers()</td>
<td style="text-align: center">请求已经发现的设备的列表</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的监听<br/>
类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的<br/>
结果</li>
</ul>

<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align: center">相关的操作</th>
</tr>
</thead>

<tbody>
<tr>
<td>WifiP2pManager.ActionListener</td>
<td style="text-align: center">相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers()</td>
</tr>
<tr>
<td>WifiP2pManager.ChannelListener</td>
<td style="text-align: center">相关的操作：initialize()</td>
</tr>
<tr>
<td>WifiP2pManager.ConnectionInfoListener</td>
<td style="text-align: center">相关的操作：requestConnectInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.GroupInfoListener</td>
<td style="text-align: center">相关的操作：requestGroupInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.PeerListListener</td>
<td style="text-align: center">相关的操作：requestPeers()</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的Intent</li>
</ul>

<table>
<thead>
<tr>
<th>Intent</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>WIFI_P2P_CONNECTION_CHANGED_ACTION</td>
<td style="text-align: center">当设备的Wi-Fi的连接状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_PEERS_CHANGED_ACTION</td>
<td style="text-align: center">在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表</td>
</tr>
<tr>
<td>WIFI_P2P_STATE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_THIS_DEVICE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的设备的详细信息发生变化时触发</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">创建Wi-Fi直连的应用</h2>

<ul>
<li>初始化设置<br/>
首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的<br/>
api<br/>
在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明<code>android:minSdkVersion=&quot;14&quot;</code></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre>

<ul>
<li>初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态<br/>
``` java<br/>
private WifiP2pManager mManager;<br/>
private Channel mChannel;<br/>
private IntentFilter directFilter;<br/>
private WiFiDirectReceiver directReceiver ;</li>
</ul>

<p>@Override<br/>
protected void onCreate(Bundle savedInstanceState) {<br/>
  super.onCreate(savedInstanceState);<br/>
  setContentView(R.layout.activity_main);</p>

<p>mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE);<br/>
  mChannel = mManager.initialize(this, this.getMainLooper(), null);<br/>
  directReceiver = new WiFiDirectReceiver(mManager, mChannel, this);</p>

<p>directFilter = new IntentFilter();<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);</p>

<p>}</p>

<p>//注册广播监听<br/>
@Override<br/>
protected void onResume() {<br/>
  super.onResume();<br/>
  this.registerReceiver(directReceiver, directFilter);<br/>
}</p>

<p>//取消注册<br/>
@Override<br/>
protected void onPause() {<br/>
  super.onPause();<br/>
  this.unregisterReceiver(directReceiver);<br/>
}</p>

<pre class="line-numbers"><code class="language-text">
- 广播接受

``` java
public class WiFiDirectReceiver extends BroadcastReceiver{

    private WifiP2pManager mManager;
    private Channel mChannel;
    private MainActivity mActivity;
    private PeerListListener mListener;
    private WifiP2pConfig mConfig = new WifiP2pConfig();

    public WiFiDirectReceiver(){}

    public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity){
        this.mManager = manager;
        this.mChannel = channel;
        this.mActivity = activity;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        Log.e(&quot;tag&quot;, &quot;===============wifi direct action: &quot;+action);
        if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)){
            int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
            if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED){
                //打开
            }else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED){
                //关闭
            }
        }else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)){

        }
    }
}
</code></pre>

<ul>
<li>发现设备</li>
</ul>

<p>在调用之后initialize()方法之后，会触发<code>WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION</code>的广播，在BroadcastReceiver<br/>
中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.</p>

<p>会回调onSuccess方法  </p>

<pre class="line-numbers"><code class="language-java">mManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
@Override
                    public void onSuccess() {
                        Log.e(&quot;tag&quot;, &quot;===================discovery success&quot;);
                    }

                    @Override
                    public void onFailure(int reason) {
                        Log.e(&quot;tag&quot;, &quot;===================discovery failed&quot;);
                    }
});
</code></pre>

<p>如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备</p>

<pre class="line-numbers"><code class="language-java">if(null != mManager){
    mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() {
        @Override
        public void onPeersAvailable(WifiP2pDeviceList peers) {
            Log.e(&quot;tag&quot;, &quot;==================peers list size: &quot;+peers.getDeviceList().size());
            for(WifiP2pDevice device: peers.getDeviceList()){
                Log.e(&quot;tag&quot;, &quot;==================device addr: &quot;+device.deviceName+&quot; name: &quot;+device.deviceName);
            }
        }
    });
}
</code></pre>

<ul>
<li>连接设备<br/>
对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress</li>
</ul>

<pre class="line-numbers"><code class="language-java">private WifiP2pConfig mConfig = new WifiP2pConfig();  
mConfig.deviceAddress = device.deviceAddress;
mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        Log.e(&quot;tag&quot;, &quot;==============connnect success&quot;);
    }
    @Override
    public void onFailure(int reason) {
        Log.e(&quot;tag&quot;, &quot;=================connect failed&quot;);
    }
});
</code></pre>

<p>连接成功会回调onSuccess方法</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868648.html">
                
                  <h1>Android 权限机制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818759960353.png" alt="20170227148818759960353.png"/><figcaption>20170227148818759960353.png</figcaption></figure></p>

<h2 id="toc_0">一、概要</h2>

<p>Android M已经发布一段时间了，市面上很多应用都已经适配Android M。权限机制，作为Android M的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，1、Android权限机制关键知识点；2、QQ音乐对于权限的适配经验；3、近段时间以来遇到的一些Android权限方面的问题。OK，下面进入主题。</p>

<h2 id="toc_1">二、Android权限机制</h2>

<p>已经了解过基本知识的，建议直接跳到第三点（QQ音乐的权限适配经验）。</p>

<p>Android6.0以前，Android的权限机制比较简单，开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。然而，同期的iOS对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在APP运行时，用户可以根据自身的需要，决定是否授予APP某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，Android过于简单的权限机制也受到了不少人的吐槽。终于，Android6.0也发布了动态权限的机制。</p>

<h3 id="toc_2">(一) 开始适配和如何兼容</h3>

<p>APP要适配Android6.0非常简单，只需要将targetSdkVersion和compileSdkVersion都升级到23及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的APP在Android6.0机型上运行或者针对Android6.0适配了的APP在Android6.0以下机型上运行，会有什么表现呢？是如何兼容的呢？</p>

<p>1、首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。</p>

<p>2、适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。</p>

<h3 id="toc_3">(二) 危险权限与普通权限</h3>

<p>一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的APP，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？</p>

<p>好歹，Google还算比较明智，并不是所有的权限都需要运行时申请才能使用。Google对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取sd卡数据这类权限，很显然就是危险权限了，APP必须向用户申请这个权限。</p>

<p>Google还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读sd卡和写sd卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。Google对于危险权限的定义和分组见下图。<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022714881876646793.png" alt="2017022714881876646793.png"/><figcaption>2017022714881876646793.png</figcaption></figure></p>

<h3 id="toc_4">(三) 权限相关API说明</h3>

<p>首先，在动态权限申请的流程中，开发者主要关注流程和API如下：</p>

<h4 id="toc_5">1、检查权限是否授予。</h4>

<p>Activity.java<br/>
<code>public int checkSelfPermission(permission)</code></p>

<h4 id="toc_6">2、申请权限。</h4>

<p>Activity.java<br/><br/>
<code>public final void requestPermissions( new String[permission1,permission2,...], requestCode)</code></p>

<p>这个时候，会弹出系统授权弹窗<strong>（授权弹窗是不支持自定义的，原因理所当然）</strong>。</p>

<h4 id="toc_7">3、权限回调。</h4>

<p>用户在系统弹窗里面选择后，结果会通过Activity的<code>onRequestPermissionsResult</code>方法回调APP。</p>

<pre class="line-numbers"><code class="language-text">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    //继续执行逻辑或者提示权限获取失败
}
</code></pre>

<h4 id="toc_8">4、权限说明。</h4>

<p>用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,<strong>这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。</strong>  </p>

<pre class="line-numbers"><code class="language-java">public boolean shouldShowRequestPermissionRationale(permission)
{
    1、APP没有申请这个权限的话，返回false
    2、用户拒绝时，勾选了不再提示的话，返回false
    3、用户拒绝，但是没有勾选不再提示的话，返回true
    因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。
}
</code></pre>

<h2 id="toc_9">三、QQ音乐的权限适配经验</h2>

<h3 id="toc_10">(一) 不同权限，申请的时机不同</h3>

<p>QQ音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配6.0时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。</p>

<p><strong>用户触发：</strong>这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时APP运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。</p>

<p><strong>应用启动时：</strong>我们在梳理的时候发现，有些权限（读取设备信息，读写sd卡等）并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者APP不能妥协的权限，因为如果用户不授权的话，将会影响整个APP的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是Google建议的一种方式。</p>

<p>但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用APP自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到SD卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，Google对于权限的弹窗说明很不local，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。</p>

<h3 id="toc_11">(二) 应用启动授权，需要一个壳</h3>

<p>刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动APP，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限crash了，即使没有crash，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。</p>

<p>做过启动相关的同学都知道，拦截一个APP正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就QQ音乐而言，我们很容易的就想到了dex加载的壳，需求也很类似，dex加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在dex的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分APP都是分dex的了，因此建议按照这个方式来做，可以节省很多的工作量。</p>

<h2 id="toc_12">四、Android权限机制“乱象”</h2>

<p>这里要说的乱象，其实是和Android严重的碎片化有一定的关系。随着国产ROM越来越个性，很多ROM在尝试建立自己的权限机制，有些甚至基于Android5.x就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。</p>

<h3 id="toc_13">(一) 读取运动数据权限</h3>

<p>开发QQ音乐跑步电台的过程中发现，在某国产ROM的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关API发现，我们使用的计步相关的Sensor并不需要申请什么权限。可如果用户选择了拒绝，即使APP注册了Sensor，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方APP无法检查和申请这个权限，这个权限本身也属于该厂商ROM自己的权限机制。</p>

<p>类似的案例还有一个，就是在某厂商的手机管家，会一直提示QQ音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了PackageManager相关的一些API，就是触发这个告警。</p>

<p>对于这类问题，我们怀疑，第三方ROM是在运行时检测到了APP调用了相关的API后，进行权限阻断。这里开发同学需要注意的是，被阻断的API不一定会导致crash，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。</p>

<h3 id="toc_14">(二) 无法添加快捷方式</h3>

<p>本来<code>&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot;/&gt;</code>声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产ROM，对于APP添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，APP才能最终成功的添加。这种情况，APP也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。</p>

<h3 id="toc_15">(三) 消失的桌面歌词，悬浮窗权限</h3>

<p>QQ音乐桌面歌词采用了向WindowManager里面添加View的方式实现。可是很多国产ROM很早就具备了悬浮窗权限。一开始，我们将type改为LayoutParams.TYPE_TOAST同时声明<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</code>这个普通权限，躲避了大多数系统的问题。可是，2016年底，随着某ROM系统的升级，这一招也没用了，大批用户反馈爆发。</p>

<p>我们继续尝试检测悬浮窗权限，发现<code>checkPermission（&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;）</code>返回的结果永远是true，因此这条路也走不通。</p>

<p>最终，经过各种查阅，发现这个悬浮窗权限并不在Android6.0标准的权限机制内，而是AppOpsManager里面已经被隐藏了的一个开关位，对应于第24个开关。需要注意的是，AppOpsManager这个类很早就有了，但是很多ROM隐藏了checkOp的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。  </p>

<pre class="line-numbers"><code class="language-java"> AppOpsManager manager = (AppOpsManager) context.getSystemService(&quot;appops&quot;);
try {
    Object object = invokeMethod(manager, &quot;checkOp&quot;, op, Binder.getCallingUid(), getPackageName(context));
    return AppOpsManager.MODE_ALLOWED == (Integer) object;
} catch (Exception e) {
    MLog.e(TAG, &quot;CheckPermission &quot; + e.toString());
}
</code></pre>

<p>不过，要打开悬浮窗权限，不同ROM的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的ROM，给予用户不同的引导，终于将反馈量降了下去。</p>

<p><strong>转载自<a href="http://mp.weixin.qq.com/s/YL-NooJmsqbGSUlpNmpqbw">Android权限机制与适配经验</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/1/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868683.html">
                
                  <h1>Android 存储方式以及路径API</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>首先说一句,平时说的存储分成了内部存储和外部存储。注意内部存储又叫做机身内存，而且内存又包含了两个部分RAM(运行时内存,这个和运行速度有关系，是手机运行时存储数据和指令的地方)、ROM(这个才算是真正存储东西的内部存储范围，是应用配置和其他数据的地方);而外部存储就很明确了,用户的外部挂载存储设备,如SD卡,手机的内部存储卡。</p>

<p>来介绍几个概念:</p>

<h2 id="toc_0">一、内存</h2>

<p>全称内部存储,英文名(InternalStorage)。当我们在打开DDMS下的File Explorer面板的时候，/data目录就是所谓的内部存储 (ROM )。<br/><br/>
但是注意，当手机没有root的时候不能打开此文件夹。<br/><br/>
当打开data文件夹的时候，目录结构如下:<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818814550660.png" alt="20170227148818814550660.png"/><figcaption>20170227148818814550660.png</figcaption></figure>  </p>

<p>这里一般都是关注两个最重要的文件夹: </p>

<ul>
<li>app文件夹里存放着我们所有安装的app的apk文件，并且当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。 <br/>
这里写图片描述 </li>
<li>第二个文件夹是data,也就是我们常说的/data/data目录(存储包私有数据)。此目录下将每一个APP的存储内容按照包名分类存放好。 <br/>
比如: 
<ul>
<li>data/data/包名/shared_prefs 存放该APP内的SP信息 </li>
<li>data/data/包名/databases 存放该APP的数据库信息 </li>
<li>data/data/包名/files 将APP的文件信息存放在files文件夹 </li>
<li>data/data/包名/cache 存放的是APP的缓存信息 </li>
</ul></li>
</ul>

<p>多扯一句,下面的代码就会在files文件夹先创建一个hello_file文件并写入了数据:</p>

<pre class="line-numbers"><code class="language-java">String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;
FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_APPEND|Context.MODE_WORLD_READABLE);
fos.write(string.getBytes());
fos.close();
</code></pre>

<h2 id="toc_1">二、外存</h2>

<p>/storage/sdcard/Android/data目录或者说/storage/emulated/0/Android/data包目录属于外部存储。比如我们的内部存储卡。 <br/>
注意,Google官方建议开发者将App的数据存储在私有目录即/storage/emulated/0/Android/data包下，这样卸载App时数据会随之被系统清除，不会造成数据残留。 </p>

<h2 id="toc_2">三、除了/data之外的存储目录</h2>

<ol>
<li><strong>/mnt</strong>:这个目录专门用来当作挂载点(MountPoint)。通俗点说,/mnt就是来挂载外部存储设备的(如sdcard),我们的sdcard将会被手机系统视作一个文件夹,这个文件夹将会被系统嵌入到收集系统的mnt目录 </li>
<li><strong>/dev包</strong>:Linux系统的常规文件夹。 </li>
<li><p><strong>/system包</strong>:系统配置的文件夹，比如Android系统框架（framework）、底层类库（lib）、字体（font）等。 </p></li>
</ol>

<ul>
<li>1、下面说一下路径API和对以上的文件的操作:<br/>
<code>context.getFilesDir().getAbsolutePath()</code><br/>
<code>context.getFilesDir().getPath()</code><br/></li>
</ul>

<p>上面的两个API都是得到应用程序私有目录下的文件路径:<br/><br/>
<code>/data/data/包名/files</code></p>

<ul>
<li><p>2、<code>context.getCacheDir().getPath()</code><br/><br/>
取得应用程序的缓存文件在内部存储上的存储路径<br/><br/>
<code>/data/data/包名/cache</code>  </p></li>
<li><p>3、<code>context.getExternalCacheDir().getAbsolutePath()</code>和<code>context.getExternalCacheDir().getCanonicalPath()</code><br/>
取得应用程序的缓存文件在外部存储上的存储路径<br/><br/>
<code>/storage/sdcard/Android/data/包名/cache</code></p></li>
<li><p>4、<code>context.getObbDir().getAbsolutePath()</code><br/>
取得外部存储obb目录的根路径<br/><br/>
<code>/storage/sdcard/Android/obb/包名</code></p></li>
<li><p>5、<code>Environment.getExternalStorageState()</code><br/><br/>
得到外部存储卡(sdcard)的存储状态<br/><br/>
<code>mounted</code>  </p></li>
<li><p>6、<code>Environment.getExternalStorageDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的整个根路径<br/><br/>
<code>/storage/sdcard</code>  </p></li>
<li><p>7、<code>Environment.getDownloadCacheDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的下载文件的缓存路径<br/>
<code>/cache</code></p></li>
<li><p>8、<code>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath()</code><br/><br/>
得到外部存储的图片的根路径<br/><br/>
<code>/storage/sdcard/Pictures</code></p></li>
<li><p>9、<code>Environment.getRootDirectory().getAbsolutePath()</code><br/><br/>
<code>/system</code></p></li>
<li><p>10、<code>Environment.getDataDirectory().getAbsolutePath()</code></p></li>
</ul>

<p><code>/data</code></p>

<h2 id="toc_3">最后总结一下:</h2>

<ul>
<li>内部数据：/data/data/包名/XXX </li>
<li>外部私有数据：/storage/emulated/0/Android/data/包名/XXX </li>
<li>外部公有数据：/storage/emulated/0/包名/XXX</li>
</ul>

<p>当用应用管理来清除数据的时候: </p>

<ul>
<li>清除缓存：将外部私有数据下的cache包（/storage/emulated/0/Android/data/包名/cache）清除，将内部数据下的cache包下的内容（/data/data/包名/cache/XXX）清除 。 </li>
<li>清楚数据：将外部私有数据包（/storage/emulated/0/Android/data/包名）清除，将内部数据下的所有内容（/data/data/包名/XXX）清除；</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/1/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868614.html">
                
                  <h1>Android 响应式编程的应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">响应式编程简介</h2>

<ul>
<li>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</li>
<li>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</li>
<li>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</li>
</ul>

<h2 id="toc_1">响应式编程的具体实现-RxJava</h2>

<h3 id="toc_2">基本概念</h3>

<h4 id="toc_3">RxJava的四种角色</h4>

<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subject</li>
<li>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。</li>
</ul>

<h4 id="toc_4">热Observable和冷Observable</h4>

<p>从发射物的角度来看，有两种不同的Observable:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p>

<h4 id="toc_5">Observable创建符</h4>

<ul>
<li>Observable.create()</li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable.create(new Observable.OnSubscribe&lt;Object&gt;(){
    @Override
    public void call(Subscriber&lt;? super Object&gt; subscriber{
    }
});
</code></pre>

<ul>
<li>Observable.from()<br/>
from() 创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java Future 类来创建Observable，并发射Future对象的 .get() 方法返回的结果值。传入 Future 作为参数时，我们可以指定一个超时的值。Observable将等待来自 Future 的结果；如果在超时之前仍然没有结果返回，Observable将会触发 onError() 方法通知观察者有错误发生了。<br/>
``` java<br/>
List<Integer> items = new ArrayList<Integer>();<br/>
items.add(1);<br/>
items.add(10);<br/>
items.add(100);<br/>
items.add(200);</li>
</ul>

<p>Observable<Integer> observableString = Observable.from(items);<br/>
Subscription subscriptionPrint = observableString.subscribe(new Observer<Integer>() {<br/>
    @Override<br/>
    public void onCompleted() {<br/>
    System.out.println(&quot;Observable completed&quot;);<br/>
    }<br/>
    @Override<br/>
    public void onError(Throwable e) {<br/>
    System.out.println(&quot;Oh,no! Something wrong happened！&quot;);<br/>
    }<br/>
    @Override<br/>
    public void onNext(Integer item) {<br/>
    System.out.println(&quot;Item is &quot; + item);<br/>
    }<br/>
});</p>

<pre class="line-numbers"><code class="language-text">
- Observable.just()   
just() 方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。 just() 方法也可以接受列表或数组，就像 from() 方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。

``` java
Observable&lt;String&gt; observableString = Observable.just(helloWorld
());
Subscription subscriptionPrint = observableString.subscribe(new
Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {
    System.out.println(&quot;Observable completed&quot;);
    }
    @Override
    public void onError(Throwable e) {
    System.out.println(&quot;Oh,no! Something wrong happened!&quot;);
    }
    @Override
    public void onNext(String message) {
    System.out.println(message);
    }
});
</code></pre>

<p>helloWorld() 方法比较简单，像这样：</p>

<pre class="line-numbers"><code class="language-java">private String helloWorld(){
    return &quot;Hello World&quot;;
}
</code></pre>

<h3 id="toc_6">Subject</h3>

<p>Subject 既可以是 Observable，也可以是 Observer。 <br/>
RxJava 提供四种不同的 Subject :</p>

<ul>
<li>PublishSubject</li>
<li>BehaviorSubject<br/>
BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。<br/></li>
</ul>

<p><code>BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(1);</code>  </p>

<p>在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。</p>

<ul>
<li>ReplaySubject<br/>
ReplaySubject 会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发:<br/></li>
</ul>

<p><code>ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create();</code></p>

<ul>
<li>AsyncSubject<br/>
当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。<br/></li>
</ul>

<p><code>AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create();</code></p>

<h3 id="toc_7">直接创建 Observable</h3>

<p>在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。</p>

<p>首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。</p>

<pre class="line-numbers"><code class="language-java">private Observable&lt;AppInfo&gt; getApps(){
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfoRich&gt; apps = new ArrayList&lt;AppInfoRich&gt;();
        final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        List&lt;ResolveInfo&gt; infos = getActivity().queryIntentActivities(mainIntent, 0);
        for(ResolveInfo info : infos){
            apps.add(new AppInfoRich(getActivity(),info));
        }
        for (AppInfoRich appInfo:apps) {
            Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon());
            String name = appInfo.getName();
            String iconPath = mFilesDir + &quot;/&quot; + name;
            Utils.storeBitmap(App.instance, icon,name);
            if (subscriber.isUnsubscribed()){
                return;
            }
            subscriber.onNext(new AppInfo(name, iconPath, appInfo.getLastUpdateTime()));
        }
        if (!subscriber.isUnsubscribed()){
            subscriber.onCompleted();
        }
    });
}
</code></pre>

<p>AppInfo为App信息的实体类，包括上次更新时间、图标、名字三个属性，此处省略。</p>

<p><strong>需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。</strong></p>

<p>接下来，我们来定义下拉刷新的方法：  </p>

<pre class="line-numbers"><code class="language-java">private void refreshTheList() {
    getApps().toSortedList()
    .subscribe(new Observer&lt;List&lt;AppInfo&gt;&gt;() {
    @Override
    public void onCompleted() {
        Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
    }
    @Override
    public void onError(Throwable e) {
        Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
        mSwipeRefreshLayout.setRefreshing(false);
    }
    @Override
    public void onNext(List&lt;AppInfo&gt; appInfos) {
        mRecyclerView.setVisibility(View.VISIBLE);
        mAdapter.addApplications(appInfos);
        mSwipeRefreshLayout.setRefreshing(false);
    }
    });
}
</code></pre>

<h3 id="toc_8">从列表创建 Observable</h3>

<p>在这个例子中，我们将引入 from() 函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。  </p>

<pre class="line-numbers"><code class="language-java">private void loadList(List&lt;AppInfo&gt; apps) {
    mRecyclerView.setVisibility(View.VISIBLE);
    Observable.from(apps).subscribe(new Observer&lt;AppInfo&gt;() {
        @Override
        public void onCompleted() {
            mSwipeRefreshLayout.setRefreshing(false);
            Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
        }
        @Override
        public void onError(Throwable e) {
            Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
            mSwipeRefreshLayout.setRefreshing(false);
        }
        @Override
        public void onNext(AppInfo appInfo) {
            mAddedApps.add(appInfo);
            mAdapter.addApplication(mAddedApps.size() - 1, appInfo);
        }
    });
}
</code></pre>

<p>和第一个例子一个主要的不同是我们在 onCompleted() 函数中停掉进度条是因为我们一个一个的发射元素；<br/><br/>
第一个例子中的Observable发射的是整个list,因此在 onNext() 函数中停掉进度条的做法是安全的。  </p>

<h3 id="toc_9">具有特殊功能的创建符</h3>

<ul>
<li>just()<br/>
你可以将一个函数作为参数传给 just() 方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。</li>
<li>repeat()<br/>
假如你想对一个Observable重复发射三次数据 :
<code>java
Observable.just(appOne,appTwo,appThree)<br/>
.repeat(3)<br/>
.subscribe();
</code></li>
</ul>

<p>我们在 just() 创建Observable后追加了 repeat(3) ，它将会创建9个元素的序列，每一个都单独发射。</p>

<ul>
<li>defer()<br/>
有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的 getInt() 函数：
<code>java
private Observable&lt;Integer&gt; getInt(){<br/>
return Observable.create(subscriber -&gt; {<br/>
    if(subscriber.isUnsubscribed()){<br/>
        return;<br/>
    }<br/>
    App.L.debug(&quot;GETINT&quot;);<br/>
    subscriber.onNext(42);<br/>
    subscriber.onCompleted();<br/>
});<br/>
}
</code></li>
</ul>

<p>这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用 defer() :</p>

<p><code>Observable&lt;Integer&gt; deferred = Observable.defer(this::getInt);</code>  </p>

<p>这次， deferred 存在，但是 getInt() create() 方法还没有调用 : logcat日志也没有“GETINT”打印出来 :</p>

<pre class="line-numbers"><code class="language-java">deferred.subscribe(number -&gt; {
    App.L.debug(String.valueOf(number));
});
</code></pre>

<p>但是一旦我们订阅了， create() 方法就会被调用并且我们也可以在logcat日志中打印出两个值：GETINT 和 42。</p>

<ul>
<li><p>range()<br/><br/>
从一个指定的数字X开始发射N个数字。range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。</p></li>
<li><p>interval()<br/><br/>
interval() 函数在你需要创建一个轮询程序时非常好用。interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p></li>
<li><p>timer()<br/><br/>
如果你需要一个一段时间之后才发射的Observable，你可以使用 timer()。</p></li>
</ul>

<h2 id="toc_10">过滤Observables</h2>

<h3 id="toc_11">过滤序列</h3>

<p>RxJava让我们使用 filter() 方法来过滤我们观测序列中不想要的值。</p>

<p>我们从发出的每个元素中过滤掉开头字母不是C的 :</p>

<pre class="line-numbers"><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo.getName().startsWith(&quot;C&quot;);
    }
})
</code></pre>

<p>我们传一个新的 Func1 对象给 filter() 函数，即只有一个参数的函数。 Func1 有一个 AppInfo 对象来作为它的参数类型并且返回 Boolean 对象。只要条件符合 filter() 函数就会返回 true 。此时，值会发射出去并且所有的观察者都会接收到。</p>

<p>filter() 函数最常用的用法之一时过滤 null 对象：</p>

<pre class="line-numbers"><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo != null;
    }
})
</code></pre>

<p>它帮我们免去了在 onNext() 函数调用中再去检测 null 值，让我们把注意力集中在应用业务逻辑上。</p>

<h3 id="toc_12">获取我们需要的数据</h3>

<p>当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用 take() 或 takeLast() 。</p>

<ul>
<li><p>take()<br/><br/>
take() 函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(apps)
.take(3)<br/>
.subscribe(...);
</code></pre></li>
<li><p>takeLast()<br/><br/>
如果我们想要最后N个元素，我们只需使用 takeLast() 函数：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(apps)
.takeLast(3)<br/>
.subscribe(...);
</code></pre></li>
</ul>

<h3 id="toc_13">有且仅有一次</h3>

<ul>
<li><p>distinct()<br/><br/>
就像 takeLast() 一样， distinct() 作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。</p>
<pre class="line-numbers"><code class="language-java">Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps)
.take(3)<br/>
.repeat(3);<br/>
fullOfDuplicates.distinct()<br/>
.subscribe(...);
</code></pre></li>
<li><p>ditinctUntilChanged()<br/><br/>
如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？ditinctUntilChanged() 过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。</p></li>
</ul>

<h3 id="toc_14">First and last</h3>

<p>first() 方法和 last() 方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数。 <br/>
与 first() 和 last() 相似的变量有： firstOrDefault() 和 lastOrDefault() 。这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值。</p>

<h3 id="toc_15">Skip and SkipLast</h3>

<p>skip() 和 skipLast() 函数与 take() 和 takeLast() 相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。</p>

<h3 id="toc_16">ElementAt</h3>

<p>如果我们只想要可观测序列发射的第五个元素该怎么办？ elementAt() 函数仅从一个序列中发射第n个元素然后就完成了。 <br/>
如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault() 。</p>

<h3 id="toc_17">Sampling</h3>

<p>在Observable后面加一个 sample() ，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值：  </p>

<pre class="line-numbers"><code class="language-java">Observable&lt;Integer&gt; sensor = [...]
sensor.sample(30,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<p>如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst() 。</p>

<h3 id="toc_18">Timeout</h3>

<p>我们可以使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为 timeout() 为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发 onError() 函数。</p>

<pre class="line-numbers"><code class="language-java">Subscription subscription = getCurrentTemperature()
    .timeout(2,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<h3 id="toc_19">Debounce</h3>

<p>debounce() 函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。  </p>

<p>下图展示了多久从Observable发射一次新的数据， debounce() 函数开启一个内部定时器，如果在这个时间间隔内没有新的据发射，则新的Observable发射出最后一个数据：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818620477547.png" alt="20170227148818620477547.png"/><figcaption>20170227148818620477547.png</figcaption></figure>  </p>

<h2 id="toc_20">变换Observables</h2>

<h3 id="toc_21">*map家族</h3>

<p>RxJava提供了几个mapping函数： map() , flatMap() , concatMap() , flatMapIterable() 以及 switchMap() .所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。</p>

<ul>
<li><p>Map<br/><br/>
RxJava的 map 函数接收一个指定的 Func 对象然后将它应用到每一个由Observable发射的值上。</p>
<pre class="line-numbers"><code class="language-java">Observable.from(apps)
.map(new Func1&lt;AppInfo,AppInfo&gt;(){<br/>
    @Override<br/>
    public Appinfo call(AppInfo appInfo){<br/>
        String currentName = appInfo.getName();<br/>
        String lowerCaseName = currentName.toLowerCase();<br/>
        appInfo.setName(lowerCaseName);<br/>
        return appInfo;<br/>
    }<br/>
})<br/>
.subscribe(...);
</code></pre>
<p>正如你看到的，像往常一样创建我们发射的Observable之后，我们追加一个 map 调用，我们创建一个简单的函数来更新 AppInfo对象并提供一个名字小写的新版本给观察者。</p></li>
<li><p>FlatMap<br/><br/>
在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的 flatMap() 函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818631525343.png" alt="20170227148818631525343.png"/><figcaption>20170227148818631525343.png</figcaption></figure><br/><br/>
当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况， flatMap() 将会触发它自己的 onError() 函数并放弃整个链。重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap() 不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p></li>
<li><p>ConcatMap<br/><br/>
RxJava的 concatMap() 函数解决了 flatMap() 的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022714881863516790.png" alt="2017022714881863516790.png"/><figcaption>2017022714881863516790.png</figcaption></figure></p></li>
<li><p>FlatMapIterable<br/><br/>
作为*map家族的一员， flatMapInterable() 和 flatMap() 很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。</p></li>
<li><p>SwitchMap<br/><br/>
switchMap() 和 flatMap() 很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。</p></li>
<li><p>Scan<br/><br/>
RxJava的 scan() 函数可以看做是一个累积函数。 scan() 函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。</p></li>
</ul>

<p>作为一个通用的例子，给出一个累加器：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1,2,3,4,5)
    .scan((sum,item) -&gt; sum + item)
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            Log.d(&quot;RXJAVA&quot;, &quot;Sequence completed.&quot;);
        }
        @Override
        public void onError(Throwable e) {
            Log.e(&quot;RXJAVA&quot;, &quot;Something went south!&quot;);
        }
        @Override
        public void onNext(Integer item) {
            Log.d(&quot;RXJAVA&quot;, &quot;item is: &quot; + item);
        }
    });
</code></pre>

<p>我们得到的结果是：</p>

<p><code>RXJAVA: item is: 1</code><br/><br/>
<code>RXJAVA: item is: 3</code><br/><br/>
<code>RXJAVA: item is: 6</code><br/><br/>
<code>RXJAVA: item is: 10</code><br/><br/>
<code>RXJAVA: item is: 15</code><br/><br/>
<code>RXJAVA: Sequence completed.</code>  </p>

<h3 id="toc_22">GroupBy</h3>

<p>RxJava提供了一个有用的函数从列表中按照指定的规则： groupBy() 来分组元素。下图中的例子展示了 groupBy() 如何将发射的值根据他们的形状来进行分组。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818647619248.png" alt="20170227148818647619248.png"/><figcaption>20170227148818647619248.png</figcaption></figure></p>

<p>这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。</p>

<p>为了创建一个分组了的已安装应用列表，我们在 loadList() 函数中引入了一个新的元素：</p>

<pre class="line-numbers"><code class="language-java">Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps)
            .groupBy(new Func1&lt;AppInfo,String&gt;(){
                @Override
                public String call(AppInfo appInfo){
                    SimpleDateFormat formatter = new SimpleDateFormat(&quot;MM/yyyy&quot;);
                    return formatter.format(new Date(appInfo.getLastUpdateTime()));
                }
            });
</code></pre>

<p>现在我们创建了一个新的Observable， groupedItems ，它将会发射一个带有 GroupedObservable 的序列。 GroupedObservable 是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是 String ，代表的意思是 Month/Year 格式化的最近更新日期。</p>

<h3 id="toc_23">Buffer</h3>

<p>RxJava中的 buffer() 函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。</p>

<p>buffer() 函数有几种变体。其中有一个是允许你指定一个 skip 值：此后每 skip 项数据，用count项数据填充缓冲区。另一个是buffer() 带一个 timespan 的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。</p>

<h3 id="toc_24">Window</h3>

<p>RxJava的 window() 函数和 buffer() 很像，但是它发射的是Observable而不是列表。</p>

<p>正如 buffer() 一样, window() 也有一个 skip 变体。</p>

<h3 id="toc_25">Cast</h3>

<p>cast() 函数是 map() 操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的 Class 。</p>

<h2 id="toc_26">组合Observables</h2>

<h3 id="toc_27">Merge</h3>

<p>在”异步的世界“中经常会创建这样的场景，我们有多个来源但是又只想有一个结果：多输入，单输出。RxJava的 merge() 方法将帮助你把两个甚至更多的Observables合并到他们发射的数据项里。下图给出了把两个序列合并在一个最终发射的Observable。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201702271488186536493.png" alt="201702271488186536493.png"/><figcaption>201702271488186536493.png</figcaption></figure></p>

<p>正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。</p>

<pre class="line-numbers"><code class="language-java">Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);
mergedObserbable.subscribe(...);
</code></pre>

<p>注意错误时的toast消息，你可以认为每个Observable抛出的错误都将会打断合并。如果你需要避免这种情况，RxJava提供了 mergeDelayError() ，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时， mergeDelayError() 将会发射 onError()。</p>

<h3 id="toc_28">ZIP</h3>

<p>在一种新的可能场景中处理多个数据来源时会带来：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成： zip() 合并两个或者多个Observables发射出的数据项，根据指定的函数Func* 变换它们，并发射一个新值。下图展示了 zip() 方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818658329706.png" alt="20170227148818658329706.png"/><figcaption>20170227148818658329706.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-java">Observable.zip(observableApp, tictoc, (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);
</code></pre>

<p>zip() 函数有三个参数：两个Observables和一个 Func2 。</p>

<h3 id="toc_29">Join</h3>

<p>前面两个方法， zip() 和 merge() 方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的 join() 函数基于时间窗口将两个Observables发射的数据结合在一起。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818661695074.png" alt="20170227148818661695074.png"/><figcaption>20170227148818661695074.png</figcaption></figure></p>

<p>为了正确的理解上一张图，我们解释下 join() 需要的参数：</p>

<ul>
<li>第二个Observable和源Observable结合。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。</li>
<li>Func2 参数：定义已发射的数据如何与新发射的数据项相结合。</li>
</ul>

<h3 id="toc_30">combineLatest</h3>

<p>RxJava的 combineLatest() 函数有点像 zip() 函数的特殊形式。正如我们已经学习的， zip() 作用于最近未打包的两个Observables。相反， combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了A并且 Observable2 发射了B和C， combineLatest() 将会分组处理AB和AC，如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818665751005.png" alt="20170227148818665751005.png"/><figcaption>20170227148818665751005.png</figcaption></figure></p>

<h3 id="toc_31">And,Then和When</h3>

<p>在将来还有一些 zip() 满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148818667457515.png" alt="20170227148818667457515.png"/><figcaption>20170227148818667457515.png</figcaption></figure></p>

<h3 id="toc_32">Switch</h3>

<p>给出一个发射多个Observables序列的源Observable， switch() 订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时， switch() 立即取消订阅前一个发射数 <br/>
据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。</p>

<h3 id="toc_33">StartWith</h3>

<p>RxJava的 startWith() 是 concat() 的对应部分。正如 concat() 向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前，startWith() 通过传递一个参数来先发射一个数据序列。</p>

<h2 id="toc_34">Schedulers-解决Android主线程问题</h2>

<h3 id="toc_35">Schedulers</h3>

<p>调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。</p>

<p>RxJava提供了5种调度器：</p>

<ul>
<li>.io()</li>
<li>.computation()</li>
<li>.immediate()</li>
<li>.newThread()</li>
<li>.trampoline()</li>
</ul>

<h4 id="toc_36">Schedulers.io()</h4>

<p>这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的 StrictMode 违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。</p>

<p><strong>重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。</strong></p>

<h4 id="toc_37">Schedulers.computation()</h4>

<p>这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器： buffer() , debounce() , delay() , interval() , sample() , skip()。</p>

<h4 id="toc_38">Schedulers.immediate()</h4>

<p>这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout() , timeInterval() ,以及 timestamp() 方法默认的调度器。</p>

<h4 id="toc_39">Schedulers.newThread()</h4>

<p>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</p>

<h4 id="toc_40">Schedulers.trampoline()</h4>

<p>当我们想在当前线程执行一个任务时，并不是立即，我们可以用 .trampoline() 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat() 和 retry() 方法默认的调度器。</p>

<h3 id="toc_41">非阻塞I/O操作</h3>

<p>使用 Schedulers.io() 创建非阻塞的版本：</p>

<pre class="line-numbers"><code class="language-java">public static void storeBitmap(Context context, Bitmap bitmap, String filename) {
    Schedulers.io().createWorker().schedule(() -&gt; {
        blockingStoreBitmap(context, bitmap, filename);
    });
}
</code></pre>

<h3 id="toc_42">SubscribeOn and ObserveOn</h3>

<p>我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了 subscribeOn() 方法来用于每个Observable对象。 subscribeOn() 方法用 Scheduler 来作为参数并在这个Scheduler上执行Observable调用。</p>

<p>首先，我们需要一个新的 getApps() 方法来检索已安装的应用列表：</p>

<pre class="line-numbers"><code class="language-java">private Observable&lt;AppInfo&gt; getApps() {
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfo&gt; apps = new ArrayList&lt;&gt;();
        SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
        Type appInfoType = new TypeToken&lt;List&lt;AppInfo&gt;&gt;(){}.getType();
        String serializedApps = sharedPref.getString(&quot;APPS&quot;, &quot;&quot;);
        if (!&quot;&quot;.equals(serializedApps)) {
            apps = new Gson().fromJson(serializedApps,appInfoType);
        }
        for (AppInfo app : apps) {
            subscriber.onNext(app);
        }
        subscriber.onCompleted();
    });
}
</code></pre>

<p>然后，我们所需要做的是指定 getApps() 需要在调度器上执行：</p>

<pre class="line-numbers"><code class="language-java">getApps().subscribeOn(Schedulers.io())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>最后，我们只需在 loadList() 函数添加几行代码，那么每一项就都准备好了：</p>

<pre class="line-numbers"><code class="language-java">getApps()
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>observeOn() 方法将会在指定的调度器上返回结果：如例子中的UI线程。 onBackpressureBuffer() 方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。</p>

<h3 id="toc_43">处理耗时的任务</h3>

<p>一个与I/O无关的耗时的任务：  </p>

<pre class="line-numbers"><code class="language-java">getObservableApps(apps)
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.computation())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<h1 id="toc_44">总结</h1>

<p>RxJava提供了一种以面向时序的方式考虑数据的机会：所有事情都是持续变化的，数据在更新，事件在触发，然后你就可以创建事件响应式的、灵活的、运行流畅的App。</p>

<p><strong>转载自<a href="http://blog.csdn.net/cmder1000/article/details/54848060">响应式编程在Android中的应用</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/1/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868578.html">
                
                  <h1>Android 图片加载框架－Picasso的使用指南</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android 中有几个比较有名的图片加载框架，Universal ImageLoader、Picasso、Glide和Fresco。它们各有优点，以前一直用的是ImageLoader 做项目中的图片加载，由于作者宣布ImageLoader 不会在更新了，因此新的项目打算换一个图片加载框架－Picasso, Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。<strong>Square</strong> 真是一家良心公司啊，为我们Android开发者贡献了很多优秀的开源项目有木有！像什么Rerefoit 、OkHttp、LeakCanary、Picasso等等都是非常火的开源项目。扯远了，回到正题，除了使用简单方便，Picasso还能自动帮我们做以下事情：</p>

<ul>
<li>处理Adapter 中ImageView的回收和取消下载。</li>
<li>使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。</li>
<li>自动帮我们缓存图片。内存和磁盘缓存。<br/>
以上只是列出了Picasso 比较核心的几点，其实它的优点远远不止这些，接下来就看一下如何使用Picasso。</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148816003127407.png" alt="20170227148816003127407.png"/><figcaption>20170227148816003127407.png</figcaption></figure></p>

<h2 id="toc_1">一、添加依赖</h2>

<p>要使用Picasso,首先我们要添加版本依赖，去官网或者Github 看一下当前的最新版本(截止本文最新版本为2.5.2)，然后在build.gradle中添加依赖：</p>

<pre class="line-numbers"><code class="language-text">compile &#39;com.squareup.picasso:picasso:2.5.2&#39;
</code></pre>

<h2 id="toc_2">二、加载显示图片</h2>

<p>将Picasso添加到项目之后，我们就可以用它来加载图片了，使用方法非常简单：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this)
        .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
        .into(mImageView);
</code></pre>

<p>只需要一行代码就完成了加载图片到显示的整个过程，链式调用，非常简洁，其实有三步，一次调用了三个方法：</p>

<ul>
<li>with(Context) 获取一个Picasso单例，参数是一个Context上下文</li>
<li>load(String) 调用load 方法加载图片</li>
<li>into (ImageView) 将图片显示在对应的View上，可以是ImageView，也可以是实现了Target j接口的自定义View。<br/>
上面演示了加载一张网络图片，它还支持其它形式的图片加载，加载文件图片，加载本地资源图片，加载一个Uri 路径给的图片，提供了几个重载的方法：</li>
</ul>

<h3 id="toc_3">(一) load(Uri uri) 加载一个以Uri路径给的图片</h3>

<pre class="line-numbers"><code class="language-java">Uri uri = Uri.parse(ANDROID_RESOURCE + context.getPackageName() + FOREWARD_SLASH + resourceId)
Picasso.with(this).load(uri).into(mImageView);
</code></pre>

<h3 id="toc_4">(二) load(File file) 加载File中的图片</h3>

<p><code>Picasso.with(this).load(file).into(mImageView);</code></p>

<h3 id="toc_5">(三) load(int resourceId) 加载本地资源图片</h3>

<p><code>Picasso.with(this).load(R.mipmap.ic_launcher).into(mImageView);</code></p>

<blockquote>
<p>提醒：上面介绍了load的几个重载方法，加载不同资源的图片，另外提醒注意一下load(String path)接受String 参数的这个方法，参数String 可以是一个网络图片url,也可以是file 路径、content资源 和Android Resource。看一下源码的注释。</p>

<pre class="line-numbers"><code class="language-java">/**
   * Start an image request using the specified path. This is a convenience method for calling
   * {@link #load(Uri)}.
   * &lt;p&gt;
   * This path may be a remote URL, file resource (prefixed with {@code file:}), content resource
   * (prefixed with {@code content:}), or android resource (prefixed with {@code
   * android.resource:}.
   * &lt;p&gt;
   * Passing {@code null} as a {@code path} will not trigger any request but will set a
   * placeholder, if one is specified.
   *
   * @see #load(Uri)
   * @see #load(File)
   * @see #load(int)
   * @throws IllegalArgumentException if {@code path} is empty or blank string.
   */
  public RequestCreator load(String path) {
    if (path == null) {
      return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
    }
    return load(Uri.parse(path));
  }
</code></pre>

<p>要使用string 参数加载上面的几种资源，除了网络url,其它几种需要加上对应前缀，file文件路径前缀：file: , content 添加前缀：content: ,Android Resource 添加：android.resource:</p>
</blockquote>

<h2 id="toc_6">三、placeholder&amp; error &amp; noPlaceholder &amp; noFade</h2>

<p>通过上面的第一步我们就可以通过Picasso 加载图片了，我们的项目中通常最常用的就是加载网络图片，但是由于网络环境的差异，有时侯加载网络图片的过程有点慢，这样界面上就会显示空ImageView什么也看不见，用户体验非常不好。其实以前用过ImageLoader的同学都知道，ImageLoader 是可以设置加载中显示默认图片的，Picasso当然也给我们提供了这个功能，这就是我们要说的placeholder(占位图)。</p>

<h3 id="toc_7">(一) placeholder</h3>

<p>placeholder提供一张在网络请求还没有完成时显示的图片，它必须是本地图片，代码如下：</p>

<pre class="line-numbers"><code class="language-java"> Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .into(mImageView);
</code></pre>

<p>设置placeholder之后，在加载图片的时候，就可以显示设置的默认图了，提升用户体验。</p>

<h3 id="toc_8">(二) error</h3>

<p>和placeholder 的用法一样，error 提供一张在加载图片出错的情况下显示的默认图</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_9">(三) noPlaceholder</h3>

<p>这个方法的意思就是：在调用into的时候明确告诉你没有占位图设置。根据这个方法签名的解释是阻止View被回收的时候Picasso清空target或者设置一个应用的占位图。需要注意的是placeholder和noPlaceholder 不能同时应用在同一个请求上，会抛异常。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .noPlaceholder()
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_10">(四) noFade</h3>

<p>无论你是否设置了占位图，Picasso 从磁盘或者网络加载图片时，into 显示到ImageView 都会有一个简单的渐入过度效果，让你的UI视觉效果更柔顺丝滑一点，如果你不要这个渐入的效果（没有这么坑爹的需求吧！！！），就调用noFade方法。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .noFade()
                .into(mImageView);
</code></pre>

<h2 id="toc_11">四、设置图片尺寸(Resize)、缩放(Scale)和裁剪(Crop)</h2>

<h3 id="toc_12">(一) Resize(int w,int h)</h3>

<p>在项目中，为了带宽、内存使用和下载速度等考虑，服务端给我们的图片的size 应该和我们View 实际的size一样的，但是实际情况并非如此，服务端可能给我们一些奇怪的尺寸的图片，我们可以使用resize(int w,int hei) 来重新设置尺寸。  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .into(mImageView);
</code></pre>

<p>resize()方法接受的参数的单位是pixels,还有一个可以设置dp单位的方法，将你的尺寸写在dimens.xml文件中，然后用<code>resizeDimen(int targetWidthResId, int targetHeightResId)</code>方法   </p>

<pre class="line-numbers"><code class="language-markup">&lt;dimen name=&quot;image_width&quot;&gt;300dp&lt;/dimen&gt;
&lt;dimen name=&quot;image_height&quot;&gt;200dp&lt;/dimen&gt;
</code></pre>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resizeDimen(R.dimen.image_width,R.dimen.image_height)
                .into(mImageView);
</code></pre>

<h3 id="toc_13">(二) onlyScaleDown</h3>

<p>当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用,如：  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(4000,2000)
                .onlyScaleDown()
                .into(mImageView);
</code></pre>

<p>只有当原来的图片尺寸大于4000 x 2000的时候，resize 才起作用。</p>

<h3 id="toc_14">(三) 图片裁剪 centerCrop()</h3>

<p>这个属性应该不陌生吧！ImageView 的ScaleType 就有这个属性。当我们使用resize 来重新设置图片的尺寸的时候，你会发现有些图片拉伸或者扭曲了（使用ImageView的时候碰到过吧），我要避免这种情况，Picasso 同样给我们提供了一个方法，centerCrop，<strong>充满ImageView 的边界，居中裁剪</strong>。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerCrop()
                .into(mImageView);
</code></pre>

<h3 id="toc_15">(四) centerInside</h3>

<p>上面的centerCrop是可能看不到全部图片的，如果你想让View将图片展示完全，可以用centerInside，但是如果图片尺寸小于View尺寸的话，是不能充满View边界的。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerInside()
                .into(mImageView);
</code></pre>

<h3 id="toc_16">(五) fit</h3>

<p>fit 是干什的呢？上面我们需要用resize()来指定我们需要的图片的尺寸，那就是说在程序中需要我们计算我们需要的尺寸（固定大小的除外），这样很麻烦，fit 方法就帮我们解决了这个问题。fit 它会自动测量我们的View的大小，然后内部调用reszie方法把图片裁剪到View的大小，这就帮我们做了计算size和调用resize 这2步。非常方便。代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .into(mImageView);
</code></pre>

<p>使用fit 还是会出现拉伸扭曲的情况，因此最好配合前面的centerCrop使用，代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .into(mImageView);
</code></pre>

<p>看一下对比图:<br/><br/>
<strong>fit(会拉伸):</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148816675790516.png" alt="20170227148816675790516.png"/><figcaption>20170227148816675790516.png</figcaption></figure>  </p>

<p><strong>fit &amp; centerCrop (不会拉伸):</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148816678223732.png" alt="20170227148816678223732.png"/><figcaption>20170227148816678223732.png</figcaption></figure></p>

<blockquote>
<p>注意：特别注意，  </p>

<ol>
<li>fit 只对ImageView 有效<br/></li>
<li>使用fit时，ImageView 宽和高不能为wrap_content,很好理解，因为它要测量宽高。</li>
</ol>
</blockquote>

<h2 id="toc_17">五、图片旋转Rotation()</h2>

<p>在图片显示到ImageView 之前，还可以对图片做一些旋转操作，调用<code>rotate(int degree)</code>方法  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180)
                .into(mImageView);
</code></pre>

<p>这个方法它是以（0，0）点旋转，但是有些时候我们并不想以（0,0）点旋转，还提供了另外一个方法可以指定原点：</p>

<ul>
<li>rotate(float degrees, float pivotX, float pivotY) 以(pivotX, pivotY)为原点旋转</li>
</ul>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180,200,100)
                .into(mImageView);
</code></pre>

<h2 id="toc_18">六、转换器Transformation</h2>

<p>Transformation 这就是Picasso的一个非常强大的功能了，它允许你在load图片 -&gt; into ImageView 中间这个过成对图片做一系列的变换。比如你要做图片高斯模糊、添加圆角、做度灰处理、圆形图片等等都可以通过Transformation来完成。</p>

<p>来看一个高斯模糊的例子：</p>

<h3 id="toc_19">(一) 首先定义一个转换器继承 Transformation</h3>

<pre class="line-numbers"><code class="language-java">public static class BlurTransformation implements Transformation{

        RenderScript rs;

        public BlurTransformation(Context context) {
            super();
            rs = RenderScript.create(context);
        }

        @Override
        public Bitmap transform(Bitmap bitmap) {
            // Create another bitmap that will hold the results of the filter.
            Bitmap blurredBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

            // Allocate memory for Renderscript to work with
            Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED);
            Allocation output = Allocation.createTyped(rs, input.getType());

            // Load up an instance of the specific script that we want to use.
            ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));
            script.setInput(input);

            // Set the blur radius
            script.setRadius(25);

            // Start the ScriptIntrinisicBlur
            script.forEach(output);

            // Copy the output to the blurred bitmap
            output.copyTo(blurredBitmap);

            bitmap.recycle();

            return blurredBitmap;
        }

        @Override
        public String key() {
            return &quot;blur&quot;;
        }
    }
</code></pre>

<h3 id="toc_20">(二) 加载图片的时候，在into 方法前面调用 transform方法 应用Transformation</h3>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .transform(new BlurTransformation(this))
                .into(mBlurImage);
</code></pre>

<p>看一下效果图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148816706778603.png" alt="20170227148816706778603.png"/><figcaption>20170227148816706778603.png</figcaption></figure>  </p>

<p>上面为原图，下面为高斯模糊图<br/><br/>
是不是很强大，任何复杂的变换都可以通过Transformation 来做。<br/><br/>
还不止于此，还有更强大的功能。可以在一个请求上应用多个Transformation<br/><br/>
比如：我想先做个灰度处理然后在做一个高斯模糊图：  </p>

<h4 id="toc_21">1.灰度的Transformation</h4>

<pre class="line-numbers"><code class="language-java">public static class GrayTransformation implements Transformation{

        @Override
        public Bitmap transform(Bitmap source) {
            int width, height;
            height = source.getHeight();
            width = source.getWidth();

            Bitmap bmpGrayscale = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
            Canvas c = new Canvas(bmpGrayscale);
            Paint paint = new Paint();
            ColorMatrix cm = new ColorMatrix();
            cm.setSaturation(0);
            ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm);
            paint.setColorFilter(f);
            c.drawBitmap(source, 0, 0, paint);

            if(source!=null &amp;&amp; source!=bmpGrayscale){
                source.recycle();
            }
            return bmpGrayscale;
        }

        @Override
        public String key() {
            return &quot;gray&quot;;
        }
    }
</code></pre>

<h4 id="toc_22">2.如果是多个Transformation操作，有2种方式应用</h4>

<p><strong>方式一：直接调用多次transform 方法，不会覆盖的。它只是保存到了一个List 里面</strong></p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .transform(new GrayTransformation())//度灰处理
                .transform(new BlurTransformation(this))//高斯模糊
                .into(mBlurImage);
</code></pre>

<p>需要注意调用的顺序<br/>
<strong>方式二：接受一个List，将Transformation 放大list 里</strong></p>

<pre class="line-numbers"><code class="language-java">List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;();
transformations.add(new GrayTransformation());
transformations.add(new BlurTransformation(this));
Picasso.with(this).load(URL)
        .placeholder(R.drawable.default_bg)
        .error(R.drawable.error_iamge)
        .fit()
        .centerCrop()
        .transform(transformations)
        .into(mBlurImage);
</code></pre>

<p>效果图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201702271488167661608.png" alt="201702271488167661608.png"/><figcaption>201702271488167661608.png</figcaption></figure></p>

<p>如上图，第一张为灰度操作，第二张为 灰度＋高斯模糊<br/><br/>
另外发现了一个开源库，专门写了很多好玩的Transformation，有兴趣的可以看一下：<br/>
<a href="https://github.com/wasabeef/picasso-transformations">picasso-transformations</a></p>

<h2 id="toc_23">七、请求优先级</h2>

<p>Picasso 为请求设置有优先级，有三种优先级，LOW、NORMAL、HIGH。默认情况下都是NORMAL，除了调用fetch 方法，fetch 方法的优先级是LOW。</p>

<pre class="line-numbers"><code class="language-java">public enum Priority {
    LOW,
    NORMAL,
    HIGH
}
</code></pre>

<p>可以通过priority方法设置请求的优先级，这会影响请求的执行顺序，但是这是不能保证的，它只会往高的优先级靠拢。代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .priority(Picasso.Priority.HIGH)
               // .priority(Picasso.Priority.LOW)
                .into(mImageView);
</code></pre>

<h2 id="toc_24">八、Tag管理请求</h2>

<p>Picasso 允许我们为一个请求设置tag来管理请求，看一下对应的几个方法：<br/><br/>
下面3个方法是Picasso这个类的：  </p>

<ul>
<li>cancelTag(Object tag) 取消设置了给定tag的所有请求</li>
<li>pauseTag(Object tag) 暂停设置了给定tag 的所有请求</li>
<li>resumeTag(Object tag) resume 被暂停的给定tag的所有请求<br/></li>
</ul>

<p>还有一个方法是RequestCreator的:</p>

<ul>
<li>tag(Object tag) 为请求设置tag</li>
</ul>

<p>几个方法的意思也很明确，就是我们可以暂停、resume、和取消请求，可以用在哪些场景呢？</p>

<p><strong>场景一：</strong> 比如一个照片流列表，当我们快速滑动列表浏览照片的时候，后台会一直发起请求加载照片的，这可能会导致卡顿，那么我们就可以为每个请求设置一个相同的Tag，在快速滑动的时候，调用pauseTag暂停请求，当滑动停止的时候，调用resumeTag恢复请求，这样的体验是不是就会更好一些呢。</p>

<p><strong>Adapter中添加如下代码：</strong>  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(mData.get(position))
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .tag(&quot;PhotoTag&quot;)
                .into(holder.mImageView);
</code></pre>

<p><strong>Activity中为RecyclerView添加滑动监听：</strong>  </p>

<pre class="line-numbers"><code class="language-java">mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                final Picasso picasso = Picasso.with(MainActivity.this);

                if (newState == SCROLL_STATE_IDLE) {
                    picasso.resumeTag(&quot;PhotoTag&quot;);
                } else {
                    picasso.pauseTag(&quot;PhotoTag&quot;);
                }
            }
        });
</code></pre>

<p><strong>场景二</strong>： 比如一个照片流列表界面，在弱网环境下，加载很慢，退出这个界面时可能会有很多请求没有完成，这个时候我们就可 以通过tag 来取消请求了。</p>

<h2 id="toc_25">九、同步／异步加载图片</h2>

<p>Picasso 加载图片也有同步／异步两种方式</p>

<h3 id="toc_26">(一) get() 同步</h3>

<p>很简单，同步加载使用get() 方法，返回一个Bitmap 对象，代码如下：</p>

<pre class="line-numbers"><code class="language-java">try {
    Bitmap bitmap =  Picasso.with(this).load(URL).get();
    } catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<blockquote>
<p>注意：使用同步方式加载，不能放在主线程来做。</p>
</blockquote>

<h3 id="toc_27">(二) 异步的方式加载图片，fetch()</h3>

<p>一般直接加载图片通过into显示到ImageView 是异步的方式，除此之外，还提供了2个异步的方法：</p>

<ul>
<li>fetch() 异步方式加载图片</li>
<li>fetch(Callback callback) 异步方式加载图片并给一个回调接口。</li>
</ul>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL).fetch(new Callback() {
    @Override
    public void onSuccess() {
    //加载成功
    }

    @Override
    public void onError() {
    //加载失败
    }
});
</code></pre>

<p>这里就要吐槽一下接口设计了，回调并没有返回Bitmap, 不知道作者是怎么考虑的，只是一个通知效果，知道请求失败还是成功。<br/>
fetch 方法异步加载图片并没有返回Bitmap，这个方法在请求成功之后，将结果存到了缓存，包括磁盘和内存缓存。所以使用这种方式加载图片适用于这种场景：知道稍后会加载图片，使用fetch 先加载缓存，起到一个预加载的效果。</p>

<h2 id="toc_28">十、缓存（Disk 和 Memory）</h2>

<p>Picasso 有内存缓存(Memory)和磁盘缓存（ Disk）, 首先来看一下源码中对于缓存的介绍：</p>

<ul>
<li>LRU memory cache of 15% the available application RAM</li>
<li>Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only<br/>
available on API 14+ or if you are using a standalone library that provides a disk cache on all API levels like OkHttp)</li>
<li>Three download threads for disk and network access.</li>
</ul>

<p>可以看出，内存缓存是使用的LRU 策略的缓存实现，它的大小是内存大小的15%,可以自定义它的大小，最后在扩展那一章节再讲，磁盘缓存是磁盘容量的2%但是不超过50M,不少于5M。处理一个请求的时候，按照这个顺讯检查：memory-&gt;disk-&gt;network 。先检查有木有内存缓存，如果命中，直接返回结果，否则检查磁盘缓存，命中则返回结果，没有命中则从网上获取。</p>

<p><strong>默认情况下，Picasso 内存缓存和磁盘缓存都开启了的，也就是加载图片的时候，内存和磁盘都缓存了，但是有些时候，我们并不需要缓存，比如说：加载一张大图片的时候，如果再内存中保存一份，很容易造成OOM,这时候我们只希望有磁盘缓存，而不希望缓存到内存，因此就需要我们设置缓存策略了。Picasso 提供了这样的方法。</strong></p>

<h3 id="toc_29">(一) memoryPolicy 设置内存缓存策略</h3>

<p>就像上面所说的，有时候我们不希望有内存缓存，我们可以通过 memoryPolicy 来设置。MemoryPolicy是一个枚举，有两个值</p>

<p><strong>NO_CACHE</strong>：表示处理请求的时候跳过检查内存缓存<br/>
<strong>NO_STORE</strong>: 表示请求成功之后，不将最终的结果存到内存。</p>

<p>示例代码如下：  </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
    .placeholder(R.drawable.default_bg)
    .error(R.drawable.error_iamge)
    .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE) //静止内存缓存
    .into(mBlurImage);
</code></pre>

<h3 id="toc_30">(二) networkPolicy 设置磁盘缓存策略</h3>

<p>和内存缓存一样，加载一张图片的时候，你也可以跳过磁盘缓存，和内存缓存策略的控制方式一样，磁盘缓存调用方法networkPolicy(NetworkPolicy policy, NetworkPolicy... additional) , NetworkPolicy是一个枚举类型，有三个值：</p>

<ul>
<li>NO_CACHE: 表示处理请求的时候跳过处理磁盘缓存</li>
<li>NO_STORE: 表示请求成功后，不将结果缓存到Disk,但是这个只对OkHttp有效。</li>
<li>OFFLINE: 这个就跟 上面两个不一样了，如果networkPolicy方法用的是这个参数，那么Picasso会强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。</li>
</ul>

<p>使用示例： </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE)//跳过内存缓存
            .networkPolicy(NetworkPolicy.NO_CACHE)//跳过磁盘缓存
            .into(mBlurImage);
</code></pre>

<p>强制从缓存获取：  </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .networkPolicy(NetworkPolicy.OFFLINE)//强制从缓存获取结果
            .into(mBlurImage);
</code></pre>

<h2 id="toc_31">十一、Debug 和日志</h2>

<h3 id="toc_32">(一) 缓存指示器</h3>

<p>上一节说了，Picasso 有内存缓存和磁盘缓存，先从内存获取，没有再去磁盘缓存获取，都有就从网络加载，网络加载是比较昂贵和耗时的。因此，作为一个开发者，我们往往需要加载的图片是从哪儿来的（内存、Disk还是网络），Picasso让我们很容易就实现了。只需要调用一个方法setIndicatorsEnabled(boolean)就可以了,它会在图片的左上角出现一个带色块的三角形标示，有3种颜色，绿色表示从内存加载、蓝色表示从磁盘加载、红色表示从网络加载。<br/><br/>
<code>Picasso.with(this).setIndicatorsEnabled(true);//显示指示器</code><br/><br/>
效果图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022714881690255844.png" alt="2017022714881690255844.png"/><figcaption>2017022714881690255844.png</figcaption></figure></p>

<p>如上图所示，第一张图从网络获取，第二张从磁盘获取，第三张图从内存获取。<br/><br/>
看一下源码中定义指示器的颜色：  </p>

<pre class="line-numbers"><code class="language-java">/** Describes where the image was loaded from. */
public enum LoadedFrom {
    MEMORY(Color.GREEN),
   DISK(Color.BLUE),
   NETWORK(Color.RED);

    final int debugColor;

    private LoadedFrom(int debugColor) {
        this.debugColor = debugColor;
    }
}
</code></pre>

<p>可以很清楚看出，对应三种颜色代表着图片的来源。</p>

<h3 id="toc_33">(二) 日志</h3>

<p>上面的指示器能够很好的帮助我们看出图片的来源，但是有时候我们需要更详细的信息，Picasso,可以打印一些日志，比如一些关键方法的执行时间等等，我们只需要调用setLoggingEnabled(true)方法，然后App在加载图片的过程中，我们就可以从logcat 看到一些关键的日志信息。<br/><br/>
<code>Picasso.with(this).setLoggingEnabled(true);//开启日志打印</code>  </p>

<h2 id="toc_34">十二、Picasso 扩展</h2>

<p>到目前为止，Picasso的基本使用已经讲得差不多了，但是在实际项目中我们这可能还满足不了我们的需求，我们需要对它做一些自己的扩展，比如我们需要换缓存的位置、我们需要扩大缓存、自定义线程池、自定义下载器等等。这些都是可以的，接下来我们来看一下可以做哪些方面的扩展。  </p>

<h3 id="toc_35">(一) 用Builder 自己构造一个Picasso Instance</h3>

<p>我们来回顾一下前面是怎么用Picasso加载图片的：  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this)
       .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
       .into(mImageView);
</code></pre>

<p><strong>总共3步：</strong></p>

<ol>
<li>用with方法获取一个Picasso 示例</li>
<li>用load方法加载图片</li>
<li>用into 放法显示图片</li>
</ol>

<p>首先Picasso是一个单例模式，我们每一次获取的示例都是默认提供给我们的实例。但是也可以不用它给的Instance,我们直接用builder来构造一个Picasso:  </p>

<pre class="line-numbers"><code class="language-java">Picasso.Builder builder = new Picasso.Builder(this);
//构造一个Picasso
Picasso picasso = builder.build();
//加载图片
picasso.load(URL)
.into(mImageView);
</code></pre>

<p>这样我们就构造了一个局部的Picasso实例，当然了，我们直接用new 了一个builder，然后build()生成了一个Picasso。这跟默认的通过with方法获取的实例是一样的。那么现在我们就可以配置一些自定义的功能了。</p>

<h3 id="toc_36">(二) 配置自定义下载器 downLoader</h3>

<p>如果我们不想用默认提供的Downloader,那么我们可以自定义一个下载器然后配置进去。举个例子：</p>

<h4 id="toc_37">1、先自定义一个Downloader(只是举个例子，并没有实现):</h4>

<pre class="line-numbers"><code class="language-java">/**
 * Created by zhouwei on 17/2/26.
 */

public class CustomDownloader implements Downloader {

    @Override
    public Response load(Uri uri, int networkPolicy) throws IOException {
        return null;
    }

    @Override
    public void shutdown() {

    }
}
</code></pre>

<h4 id="toc_38">2、然后通过builder配置：</h4>

<pre class="line-numbers"><code class="language-java"> //配置下载器
builder.downloader(new CustomDownloader());
//构造一个Picasso
Picasso picasso = builder.build();
</code></pre>

<p>这样配置后，我们用build()生成的Picasso 实例来加载图片就会使用自定义的下载器来下载图片了。</p>

<h3 id="toc_39">(三) 配置缓存</h3>

<p>前面说过，内存缓存是用的LRU Cahce ,大小是手机内存的15% ，如果你想缓存大小更大一点或者更小一点，可以自定义，然后配置。</p>

<pre class="line-numbers"><code class="language-java">//配置缓存
LruCache cache = new LruCache(5 * 1024 * 1024);// 设置缓存大小
builder.memoryCache(cache);
</code></pre>

<p>上面只是一个简单的举例，当然了你可以自定义，也可以使用LRUCache,改变大小，改变存储路径等等。</p>

<blockquote>
<p>提示： 很遗憾，好像没有提供改变磁盘缓存的接口，那就只能用默认的了。</p>
</blockquote>

<h3 id="toc_40">(四) 配置线程池</h3>

<p>Picasso 默认的线程池的核心线程数为3，如果你觉得不够用的话，可以配置自己需要的线程池，举个列子：  </p>

<pre class="line-numbers"><code class="language-java">//配置线程池
ExecutorService executorService = Executors.newFixedThreadPool(8);
builder.executor(executorService);
</code></pre>

<h3 id="toc_41">(五) 配置全局的 Picasso Instance</h3>

<p>上面说的这些自定义配置项目都是应用在一个局部的Picasso instance 上的，我们不可能每一次使用都要重新配置一下，这样就太麻烦了。我们希望我们的这些自定义配置能在整个项目都应用上，并且只配置一次。其实Picasso 给我们提供了这样的方法。可以调用<code>setSingletonInstance(Picasso picasso)</code>就可以了，看一下这个方法的源码：  </p>

<pre class="line-numbers"><code class="language-java">/**
  * Set the global instance returned from {@link #with}.
  * &lt;p&gt;
  * This method must be called before any calls to {@link #with} and may only be called once.
  */
public static void setSingletonInstance(Picasso picasso) {
    synchronized (Picasso.class) {
        if (singleton != null) {
            throw new IllegalStateException(&quot;Singleton instance already exists.&quot;);
        }
        singleton = picasso;
    }
}
</code></pre>

<p>设置一个通过with方法返回的全局instance。我们只希望配置一次，所以，我们应该在Application 的onCreate方法中做全局配置就可以了。app一启动就配置好，然后直接和前面的使用方法一样，调用with方法获取Picasso instance 加载图片就OK了。</p>

<p>因此在Application 中添加如下代码：</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onCreate() {
    super.onCreate();

    // 配置全局的Picasso instance 

    Picasso.Builder builder = new Picasso.Builder(this);
    //配置下载器
    builder.downloader(new CustomDownloader());
    //配置缓存
    LruCache cache = new LruCache(5*1024*1024);// 设置缓存大小
    builder.memoryCache(cache);
    //配置线程池
    ExecutorService executorService = Executors.newFixedThreadPool(8);
    builder.executor(executorService);

    //构造一个Picasso
    Picasso picasso = builder.build();
    // 设置全局单列instance 
    Picasso.setSingletonInstance(picasso);
}
</code></pre>

<p>然后应用这些自定义配置加载图片  </p>

<p><code>Picasso.with(this).load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;).into(mImageView);</code><br/><br/>
用法和以前的一样，但是我们已经将我们的自定义配置应用上了。</p>

<h2 id="toc_42">结尾</h2>

<p>以上就是对Picasso 用法的全部总结，如有什么问题，欢迎留言指正。Picasso真的是一个强大的图片加载缓存库，API 简单好用，而且是链式调用的（这点我特别喜欢）。官方文档写的比较简单，很多用法都要看源码和注释才知道。希望本文能给才开始使用Picasso 的同学一点帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/1/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_10.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_12.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
