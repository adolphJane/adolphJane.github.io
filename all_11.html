<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207871029.html">
                
                  <h1>Android Launcher启动Activity的工作过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Launcher</h2>

<p>手机桌面也是一个App，每一个应用的icon都罗列在Launcher上，点击icon触发onItemClick事件，下面例如我们要启动「淘宝」这个App，首先我们要在清单文件定义默认启动的Activity信息。</p>

<pre class="line-numbers"><code class="language-markup">&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>然后Launcher获取到该信息之后，启动淘宝App</p>

<pre class="line-numbers"><code class="language-java">//该应用的包名
String pkg = info.activityInfo.packageName;
//应用的主activity类
String cls = info.activityInfo.name;

ComponentName componet = new ComponentName(pkg, cls);

Intent i = new Intent();
i.setComponent(componet);
startActivity(i);
</code></pre>

<p>启动Activity这一工作不管是相同应用的2个不同Activity的启动，或者是不同进程不同应用的Activity启动，都是由Activity大管家ActivityManagerService（简称AMS）全权管理，而他们之间的通讯就要用到Binder，通过Binder与AMS多次通讯，才能启动淘宝App。 </p>

<h2 id="toc_1">整体流程</h2>

<blockquote>
<p>通过对Android操作系统的学习可以提高我们对操作系统在技术实现上的理解，这对于加强开发人员的内功是很有帮助的。 <br/>
但是由于Android内部实现多数都比较复杂，在研究内部实现上应该更加侧重对整体流程的把握，而不能深入到代码细节不能自拔。</p>
</blockquote>

<ol>
<li>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</li>
<li>AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。</li>
<li>Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</li>
<li>淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</li>
<li>淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</li>
<li>AMS通知淘宝绑定Application并启动MainActivity。</li>
<li>淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</li>
</ol>

<h3 id="toc_2">startActivityForResult</h3>

<p>我们从Activity的startActivity方法开始分析。<br/><br/>
<code>startActivity</code>方法有好几种重载方式，但它们最终都会调用<code>startActivityForResult</code>方法。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}
</code></pre>

<p>在<code>startActivityForResult</code>方法内，会调用<code>Instrumentation</code>的<code>execStartActivity</code>方法。</p>

<pre class="line-numbers"><code class="language-java">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) {
    ......
    Instrumentation.ActivityResult ar =mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
    ......
}
</code></pre>

<h3 id="toc_3">Instrumentation</h3>

<blockquote>
<p>Instrumentation从字面上来看是仪器盘的意思，具体到程序中是管理activity的一个工具类，包括创建和启动Activity，activity的生命周期方法都是由Instrumentation这个仪器来控制，一个进程中只用一个Instrumentation实例。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">/**
 *
 *
 * @param who The Context from which the activity is being started.
 * @param contextThread The main thread of the Context from which the activity
 *                      is being started.
 * @param token Internal token identifying to the system who is starting 
 *              the activity; may be null.
 * @param target Which activity is performing the start (and thus receiving 
 *               any result);
 *               may be null if this call is no`t being made form an activity.
 * @param intent The actual Intent to start.
 * @param requestCode Identifier for this request&#39;s result; less than zero 
 *                    if the caller is not expecting a result.
 * @param options Addition options.
 *
 */
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;

    ......

    try {
        int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);

        //检查启动Activity的结果（抛出异常，例如清单文件未注册Activity）
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException(&quot;Failure from system&quot;, e);
    }
    return null;
}
</code></pre>

<p>我们截取了比较关键的代码片段来分析<code>Instrumentation</code>的<code>execStartActivity</code>方法，方法参数注释中也有对该方法的几个参数进行简单描述。下面我们来分析一下比较重要的2个参数，<code>contextThread</code>和<code>token</code>。 </p>

<h3 id="toc_4">IBinder contextThread</h3>

<p>在上一个方法中传入为<code>mMainThread.getApplicationThread()</code> <br/>
我们可以看到这是一个<code>IBinder</code>对象，说明它的作用就是用于进程间通讯的<code>Binder</code>对象。</p>

<blockquote>
<p>mMainThread实际上是ActivityThread对象。ActivityThread，就是主线程，也就是UI线程，它是在App启动时创建的，它代表了App应用程序。<br/><br/>
啥？ActivityThread代表了App应用程序，那Application类岂不是被架空了？其实，Application对我们App开发人员来说也许很重要，但是在Android系统中还真的没那么重要，他就是个上下文。Activity不是有个Context上下文吗？Application就是整个ActivityThread的上下文。</p>
</blockquote>

<p>我们找到<code>ActivityThread</code>文件，其实这个<code>getApplicationThread</code>方法获取的是内部类<code>ApplicationThread</code>对象 <br/>
而且<code>ApplicationThread</code>继承<code>ApplicationThreadNative</code></p>

<pre class="line-numbers"><code class="language-java">public final class ActivityThread {//没有继承或者实现其他类。

    final ApplicationThread mAppThread = new ApplicationThread();

    public ApplicationThread getApplicationThread()
    {
        return mAppThread;
    }

    //ActivityThread的内部类ApplicationThread 
    private class ApplicationThread extends ApplicationThreadNative {
    ......
    }

}
</code></pre>

<p>我们打开<code>ApplicationThreadNative</code>类(需要通过sdk的源码找到，具体路径为Sdk\sources\android-25(sdk版本)\android\app\ApplicationThreadNative)<br/><br/>
通过构造方法我们就很清晰的可以得知原来这个<code>ApplicationThreadNative</code>就是相当于AIDL通讯中的Stub，也就是服务端，<code>ApplicationThreadProxy</code>即AIDL通讯中的Proxy，也就是客户端。所以ApplicationThread是通讯的具体实现类。<br/><br/>
上面的介绍中我们也说过，Activity的启动实际上是多次进程间通讯的成果，看到这里我们就可以得出结论：<strong>ActivityThread通过内部类ApplicationThread来进行进程间通讯</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class ApplicationThreadNative extends Binder implements IApplicationThread {

    static public IApplicationThread asInterface(IBinder obj) {...}

    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {...}

    public IBinder asBinder(){return this;}

}

class ApplicationThreadProxy implements IApplicationThread {
    private final IBinder mRemote;

    public ApplicationThreadProxy(IBinder remote) {
        mRemote = remote;
    }

    ...
}
</code></pre>

<p><code>public interface IApplicationThread extends IInterface {...}</code></p>

<h3 id="toc_5">IBinder token</h3>

<p>追溯到参数起源，这个<code>token</code>对象，是在<code>Activity</code>的<code>attach</code>方法中传入的，也就是<code>Activity</code>的创建与关联时候(下面的内容会提到)传入的<code>Activity</code>信息。<br/><br/>
这也是个<code>Binder</code>对象，它代表了<code>Launcher</code>这个<code>Activity</code>，这里也通过<code>Instrumentation</code>传给AMS，AMS查询后，就知道是谁向AMS发起请求了。</p>

<pre class="line-numbers"><code class="language-java">//Activity

    private IBinder mToken;

    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {

        mToken = token;
}
</code></pre>

<blockquote>
<p><code>contextThread</code>和<code>token</code>这两个参数是伏笔，传递给AMS，以后AMS想反过来通知<code>Launcher</code>，就能通过这两个参数，找到<code>Launcher</code>。</p>
</blockquote>

<h3 id="toc_6">startActivity</h3>

<p>在<code>Instrumentation</code>中，启动<code>Activity</code>真正的实现是由<code>ActivityManagerNative.getDefault()</code>的<code>startActivity</code>方法来完成。</p>

<pre class="line-numbers"><code class="language-java">int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
</code></pre>

<blockquote>
<p>ActivityManagerService（下面简称AMS）继承自ActivityManagerNative（下面简称AMN），而AMN继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder，它是IActivityManager的具体实现，由于ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，因此它的具体实现是AMS。</p>
</blockquote>

<p>我们先看代码，捋一捋上述所说的关系。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>首先我们来看这个命名方式，xxxNative，我们知道Stub持有Binder本地对象，Proxy持有的是Binder的代理对象。所以系统命名也是依据此因素（Native：本地的，土著的）作为命名规范。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Retrieve the system&#39;s default/global activity manager.
 */
static public IActivityManager getDefault() {
    return gDefault.get();
}

private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {
    protected IActivityManager create() {
        IBinder b = ServiceManager.getService(&quot;activity&quot;);
        IActivityManager am = asInterface(b);
        return am;
    }
};

/**
 * Cast a Binder object into an activity manager interface, generating
 * a proxy if needed.
 */
static public IActivityManager asInterface(IBinder obj) {
    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
    if (in != null) {
        return in;//同一进程，返回Stub本地对象。
    }
    return new ActivityManagerProxy(obj);//跨进程，返回代理对象。
}
</code></pre>

<blockquote>
<p>可以发现，在AMN 中，AMS这个Binder对象采用单例模式对外提供，Singleton是一个单例的封装类，第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续的调用中则直接返回之前创建的对象（使用同一个AMS）。</p>
</blockquote>

<p>分析create方法，在IActivityManager内（相当于Client），通过应用程序中的0号引用，可以向SMgr获取服务端（Server）的Binder引用。<br/><br/>
AMN通过getDefault方法，从ServiceManager中获取AMS中Binder的引用对象，然后将它转换成ActivityManagerProxy对象（简称AMP），AMP就是AMS的代理对象。</p>

<p>类似AIDL中客户端的绑定代码，此时我们就可以通过ActivityManagerProxy（asInterface返回值为 IActivityManager），与AMS进行通讯。</p>

<pre class="line-numbers"><code class="language-java">//ActivityManagerProxy

public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {

    Parcel data = Parcel.obtain();//从Parcel池中获取Parcel对象（通讯载体），用来写入数据
    Parcel reply = Parcel.obtain();//如果方法有返回值，则写入返回值
    data.writeInterfaceToken(IActivityManager.descriptor);//Binder唯一标识

    //caller即上面提到的contextThread，AMS就可以通过它与Launcher通讯
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);

    //resultTo即上面提到的token,包含Launcher的Activity信息
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);

        ......
    //发送类型为START_ACTIVITY_TRANSACTION的请求给AMS，data包含Launcher和淘宝App的信息
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();

    //Instrumentation通过result来检查并抛出异常（Activity未在清单文件注册等）
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
</code></pre>

<p><figure><img src="media/15561207871029/15713362032570.png" alt=""/></figure></p>

<p>从上面的分析可以知道，Activity是由<code>AMN.getDefault()</code>来启动的，而<code>AMN.getDefault()</code>实际上是AMS，因此Activity的启动过程又转移到了AMS中，为了继续分析这个过程，只需要查看AMS的startActivity方法即可。</p>

<blockquote>
<p>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</p>
</blockquote>

<p><figure><img src="media/15561207871029/15713362127963.png" alt=""/></figure></p>

<h2 id="toc_7">AMS</h2>

<p>上个图，先通俗易懂的总结一下Activity启动的整体流程，对整体框架有一个大概认识。</p>

<p><figure><img src="media/15561207871029/15713362240020.png" alt=""/></figure></p>

<h3 id="toc_8">AMS分析</h3>

<p>再回顾一遍，通过对AMS 类的查看，我们可以知道AMS 也是一个Binder，并且它是<code>IActivityManager</code>的具体实现。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>接着我们继续分析AMS的<code>startActivity</code>方法，这个阶段比较复杂和繁琐，一不小心就绕晕了，我们了解大致过程，不深入代码细节，对整体流程建立足够认识即可。</p>

<pre class="line-numbers"><code class="language-java">//AMS

@Override
public final int startActivity(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {

    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,resultWho, requestCode, startFlags, profilerInfo, bOptions,UserHandle.getCallingUserId());
}


@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller(&quot;startActivity&quot;);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);

    //7.0Acitivty启动管理类新增ActivityStarter(原本是ActivityStackSupervisor处理该过程)
    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,profilerInfo, null, null, bOptions, false, userId, null, null);
}
</code></pre>

<h3 id="toc_9">ActivityStarter</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

final int startActivityMayWait(IApplicationThread caller, int callingUid,String callingPackage, Intent intent, String resolvedType,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int startFlags,ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,Bundle bOptions, boolean ignoreTargetSecurity, int userId,IActivityContainer iContainer, TaskRecord inTask) {

            ``````

    //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择，
    //则会弹出ResolverActivity让用户选择合适的应用。
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,profileFile, profileFd, userId);

            ``````

    int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,aInfo, rInfo, voiceSession, voiceInteractor,resultTo, resultWho, requestCode, callingPid,callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,options, ignoreTargetSecurity, componentSpecified, outRecord, container,inTask);

            ``````

        return res;
    }



    //在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked(7.0前是startActivityUncheckedLocked)方法启动Activity。
   final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,String callingPackage, int realCallingPid, int realCallingUid, int startFlags,ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;

        ``````
        //创建ActivityRecord对象
        //ActivityRecord  :  在AMS中，将用ActivityRecord来作为Activity的记录者,每次启动一个Actvity会有一个对应的ActivityRecord对象，表示Activity的一个记录
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,requestCode, componentSpecified, voiceSession != null, mSupervisor, container,options, sourceRecord);

        ``````

        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                true, options, inTask);


        //此处将通知ActivityStarter, Activity对应的Task被移动到前台
        postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);

        return err;
    }
</code></pre>

<blockquote>
<p>在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked方法启动Activity。<br/>
startActivityUnchecked方法负责调度ActivityRecord和Task，理解该方法是理解Actvity启动模式的关键。<br/>
startActivityUnchecked方法调度task的算法非常复杂，和当前回退栈，要启动的acitivity的启动模式以及taskAffinity属性，启动activity时设置的intent的flag等诸多要素相关，intent的flag就有很多种情况，故此算法非常复杂，需要阅读源码并结合特定启动情况才能理解。</p>
</blockquote>

<p>接下来调用ActivityStack的startActivityLocked将ActivityRecord加入到回退栈里</p>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {

            ``````
        //ActivityStack的startActivityLocked,不要搞混了。
        //同时调用WindowManager准备App切换相关的工作
        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);


        if (mDoResume) {

            final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay
                    &amp;&amp; mStartActivity != topTaskActivity)) {
                // If the activity is not focusable, we can&#39;t resume it, but still would like to
                // make sure it becomes visible as it starts (this will also trigger entry
                // animation). An example of this are PIP activities.
                // Also, we don&#39;t want to resume activities in a task that currently has an overlay
                // as the starting activity just needs to be in the visible paused state until the
                // over is removed.

            } else {
                //最终调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }

}
</code></pre>

<h3 id="toc_10">ActivityStackSupervisor</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor

    boolean resumeFocusedStackTopActivityLocked() {
        return resumeFocusedStackTopActivityLocked(null, null, null);
    }

    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {
        //待启动Activity对应的Task为前台Task时，调用该Task对应ActivityStack的resumeTopActivityUncheckedLocked函数
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
        //否则只是调用当前前台栈的resumeTopActivityUncheckedLocked
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        }
        return false;
    }
</code></pre>

<h3 id="toc_11">ActivityStack</h3>

<p>接着跟进ActivityStack</p>

<pre class="line-numbers"><code class="language-java">//ActivityStack


    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {

        ``````
        result = resumeTopActivityInnerLocked(prev, options);

        return result;
    }


    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {


        //mResumedActivity指向上一次启动的Activity(Launcher)
        if (mResumedActivity != null) {
            ``````

           //通知Launcher进入pause状态
            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);
        }
         if (pausing) {//Launcher已经暂停了
            ``````

            if (next.app != null &amp;&amp; next.app.thread != null) {
                //如果app已经启动过
                //调用淘宝(待启动)Activity所在进程的优先级，保证其不被kill
                mService.updateLruProcessLocked(next.app, true, null);
            }

        } 
        ``````

        if (next.app != null &amp;&amp; next.app.thread != null) {

        //如果Intent不为空，调用NewIntent方法传入Intent
        next.app.thread.scheduleNewIntent(next.newIntents, next.appToken, false);

        //假设淘宝App已经启动，点击Home键返回到Launcher,再次从Launcher启动淘宝(或者第三方启动已开启的App)
        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                        mService.isNextTransitionForward(), resumeAnimOptions);
        ``````

        } else {
        ``````
           //创建进程，冷启动Activity。或者已启动App，重新启动Activity
           mStackSupervisor.startSpecificActivityLocked(next, true, true);
        }

        return true;
    }
</code></pre>

<p>resumeTopActivityInnerLocked函数非常繁琐，但整体来讲应该只有两个比较关键的地方：</p>

<ol>
<li>判断是否已有Activity(mResumedActivity)启动（即Launcher，通过Launcher启动淘宝的），有则暂停该Activity</li>
<li>判断是否需要重新启动目标Activity，即Activity是否已经启动过。（例如保存在后台，应用切换）</li>
</ol>

<blockquote>
<p>2.AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br/><br/>
3.Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</p>
</blockquote>

<h3 id="toc_12">创建进程</h3>

<p>接下来的操作就比较重要了，创建进程，启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // Is this activity&#39;s application already running?
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        if (app != null &amp;&amp; app.thread != null) {
            try {
                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !&quot;android&quot;.equals(r.info.packageName)) {

                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                //目标Activity的App已经启动（存在ActivityThread），则重启Activity
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
               ``````
            }
        }

        //如果进程不存在，则通过zygote创建应用进程。
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                &quot;activity&quot;, r.intent.getComponent(), false, false, true);
    }
</code></pre>

<p>从上面代码可以了解到startSpecificActivityLocked为启动Activity的两种不同情况</p>

<ul>
<li>例如从Launcher冷启动淘宝，则需要创建新进程，通过AMS调用Zygote(孕育天地)孵化应用进程。</li>
<li>如果淘宝App已经启动，例如从MainActivity跳转到LoginActivity，则通过realStartActivityLocked启动。</li>
</ul>

<p>因为我们开头以Launcher启动淘宝为例子，所以我们硬着头皮继续分析AMS创建进程以及Activity的绑定过程。 <br/>
上面分析到mService.startProcessLocked,到了这里我们直接看启动线程的方法，中间的过程实在是略复杂。</p>

<blockquote>
<p>4.淘宝App未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">//ActivityServiceManager

        //Process.java的start函数，将通过socket发送消息给zygote
        //zygote将派生出一个子进程，子进程将通过反射调用ActivityThread的main函数
        Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                    app.info.dataDir, entryPointArgs);
</code></pre>

<p>Zygote进程孵化出新的应用进程后，通过反射执行ActivityThread类的main方法。在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到AMS，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

public static void main(String[] args) {
    ``````
    //准备主线程的Looper，下篇博文分析Handler,Looper
    Looper.prepareMainLooper();

    //创建当前进程的ActivityThread
    ActivityThread thread = new ActivityThread();

    //将该进程绑定到AMS
    thread.attach(false);

    if (sMainThreadHandler == null) {
    //保存进程对应的主线程Handler
        sMainThreadHandler = thread.getHandler();
    }

    ``````
    //进入主线程的消息循环
    Looper.loop();

    ``````
}

//上面说过，ApplicationThread是ActivityThread用来与AMS通讯的中介
final ApplicationThread mAppThread = new ApplicationThread();

private void attach(boolean system) {
    if (!system) {
        final IActivityManager mgr = ActivityManagerNative.getDefault();

        //调用AMS的attachApplication方法，将ApplicationThread对象绑定至ActivityManagerService
        //这样AMS就可以通过ApplicationThread代理对象控制应用进程

            mgr.attachApplication(mAppThread);
    } else {
        ``````
    }
}
</code></pre>

<p>至此，进程创建完毕，并且也有了主线程，剩下的便是启动Activity和关联context等初始化操作了。</p>

<blockquote>
<p>5.淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</p>
</blockquote>

<h3 id="toc_13">AMS启动Activity小结</h3>

<p>至此通过下图总结一下在AMS启动Activity的大致流程，各个方法函数像一台机器上的不同零件，各尽其责，分工明确。 <br/>
虽然错综复杂，但是耦合性低，比如说启动模式需要优化，重新完善startActivityUnchecked方法函数即可。</p>

<p><figure><img src="media/15561207871029/15713362340361.png" alt=""/></figure></p>

<h3 id="toc_14">关联Activity</h3>

<p>在这个时候，虽然有了app进程，和主线程，但是仍是一副空壳。 <br/>
没有activity信息，没有关联上下文，这时候就要请出AMS来进行指挥。</p>

<p>因为主线程main入口通过attach方法将 ApplicationThread 发送给 AMS ，所以通过applicationThread这个桥梁来通知ActivityThread创建/关联和启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//AMS


    @Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            //获取applicationThread的进程id(也就是淘宝应用进程)
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
</code></pre>

<p>通过Binder获取proxy（ApplicationThread ）方的进程id，也就是获取目标(淘宝)进程的Pid。</p>

<pre class="line-numbers"><code class="language-java">//Binder


    /**
     * Return the ID of the process that sent you the current transaction
     * that is being processed.  This pid can be used with higher-level
     * system services to determine its identity and check permissions.
     * If the current thread is not currently executing an incoming transaction,
     * then its own pid is returned.
     */
    public static final native int getCallingPid(); 
</code></pre>

<p>接下来重点分析attachApplicationLocked方法</p>

<pre class="line-numbers"><code class="language-java">//AMS


    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;
        if (pid != MY_PID &amp;&amp; pid &gt;= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }

        //因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录）
        //如果没有ProcessRecord，则需要杀死该进程并退出
        if (app == null) {
            ``````
            return false;
        }

        // If this application record is still attached to a previous
        // process, clean it up now.
        if (app.thread != null) {
            //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread
            //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空，
            //同时新进程又刚好使用了此Pid
            handleAppDiedLocked(app, true, true);
        }


        //创建死亡代理（进程kill后通知AMS）
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);

        //进程注册成功，移除超时通知
        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        ``````
        try {
            //******绑定Application******
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());

            updateLruProcessLocked(app, false, null);
        } catch (Exception e) {

            ``````
            //bindApplication失败后，重启进程
            startProcessLocked(app, &quot;bind fail&quot;, processName);
            return false;
        }

        try {
            //******启动Activity(启动淘宝MainActivity)******
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;//didSomething表示是否有启动四大组件
            }
        } catch (Exception e) {
            badApp = true;
        }

        ``````
        //绑定service和Broadcast的Application


        if (badApp) {
            //如果以上组件启动出错，则需要杀死进程并移除记录
            app.kill(&quot;error during init&quot;, true);
            handleAppDiedLocked(app, false, true);
            return false;
        }

        //如果以上没有启动任何组件，那么didSomething为false
        if (!didSomething) {
            //调整进程的oom_adj值， oom_adj相当于一种优先级
            //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”
            updateOomAdjLocked();
        }
        return true;
    }
</code></pre>

<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。</p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）</li>
</ol>

<h3 id="toc_15">bindApplication</h3>

<p>在上面我们说道，ActivityThread通过ApplicationThread与AMS进行通讯，所以上面的thread.bindApplication（...）方法，就应该是通过ApplicationThread进行传达。<br/><br/>
在ActivityThread的内部类ApplicationThread中，我们找到bindApplication方法</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {

        public final void bindApplication(...一大堆参数...) {
            AppBindData data = new AppBindData();
            //给data设置参数...
            ``````

            sendMessage(H.BIND_APPLICATION, data);
        }
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        Message msg = Message.obtain();
        //给msg设置参数
        ``````
        mH.sendMessage(msg);
    }
</code></pre>

<p>发送消息是通过H的<code>Handler</code>类来完成的，这个命名贼个性，很令人印象深刻。PS : 我怀疑是编写这个类的工程师词穷了…</p>

<pre class="line-numbers"><code class="language-java">    private class H extends Handler {
        public static final int LAUNCH_ACTIVITY         = 100;
        public static final int PAUSE_ACTIVITY          = 101;
        ``````
        public static final int RESUME_ACTIVITY         = 107;

        public static final int DESTROY_ACTIVITY        = 109;
        public static final int BIND_APPLICATION        = 110;
        public static final int EXIT_APPLICATION        = 111;

        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
                //绑定application
                case BIND_APPLICATION:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);
                    AppBindData data = (AppBindData)msg.obj;
                    handleBindApplication(data);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;

            }

        }

    }
</code></pre>

<p>可以看出，这个H类相当于ActivityThread和ApplicationThread的中介人，也就是拉皮条的。<br/><br/>
<code>ActivityThread</code>通过<code>ApplicationThread</code>与<code>AMS</code>通讯。<br/><br/>
<code>ApplicationThread</code>通过<code>H</code>与<code>ActivityThread</code>通讯，处理Activity事务。  </p>

<p>那么既然<code>H</code>、<code>ApplicationThread</code>都在<code>ActivityThread</code>类里，为何<code>ApplicationThread</code>还要通过Handler来发送消息？</p>

<ul>
<li>便于集中管理，方便打印Log日志等，H就是这其中的大管家。</li>
<li><code>ActivityThread</code>通过<code>ApplicationThread</code>和AMS进行进程间通信，AMS以进程通讯的方式来完成<code>ActivityThread</code>的请求后调用<code>ApplicationThread</code>中的<code>Binder</code>方法，然后<code>ApplicationThread</code>会向H发送消息，H收到消息后会将<code>ApplicationThread</code>中的逻辑切换到<code>ActivityThread</code>中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。<br/>
而且有一点要注意的是，这个<code>ActivityThread</code>并不是一个线程Thread，它是final类并且无继承或者实现其它类，它的作用就是在main方法内消息循环，处理主线程事务。（还需了解Looper及消息机制）</li>
</ul>

<p>言归正传，上面ApplicationThread给H发送BIND_APPLICATION标识，在H中，通过handleBindApplication处理application的绑定事务。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread



        private void handleBindApplication(AppBindData data) {

           ``````
          //根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象
          data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);//获取LoadedApk


          /**
          * For apps targetting Honeycomb or later, we don&#39;t allow network usage
          * on the main event loop / UI thread. This is what ultimately throws
          * {@link NetworkOnMainThreadException}.
          */
          //禁止在主线程使用网络操作
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) {
              StrictMode.enableDeathOnNetwork();
          }
          /**
           * For apps targetting N or later, we don&#39;t allow file:// Uri exposure.
           * This is what ultimately throws {@link FileUriExposedException}.
           */
           //7.0引入Fileprovide
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) {
              StrictMode.enableDeathOnFileUriExposure();
          }

          ``````    
          //创建进程对应的Android运行环境ContextImpl
          final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);


          if ((InstrumentationInfo)ii != null) {
               ``````
          } else {
               //注意Activity的所有生命周期方法都会被Instrumentation对象所监控，
               //也就说执行Activity的生命周期方法前后一定会调用Instrumentation对象的相关方法
               mInstrumentation = new Instrumentation();
          }

          try {
             ``````
             Application app = data.info.makeApplication(data.restrictedBackupMode, null);
             mInitialApplication = app;


             //加载进程对应Package中携带的ContentProvider
             installContentProviders(app, data.providers);

             ``````        
             mInstrumentation.onCreate(data.instrumentationArgs);

             try {
                  //这里会调用Application的onCreate方法
                  //故此Applcation对象的onCreate方法会比ActivityThread的main方法后调用
                  //但是会比这个应用的所有activity先调用
                  mInstrumentation.callApplicationOnCreate(app);
              } catch (Exception e) {
                  ``````
              }
            } finally {
                StrictMode.setThreadPolicy(savedPolicy);
            }
        }
</code></pre>

<p>如上文所述，handleBindApplication的目的是让一个Java进程融入到Android体系中。 <br/>
因此，该函数中的代码主要进行以下工作：</p>

<ol>
<li>按照Android的要求，完成对进程基本参数的设置置，包括设置进程名、时区、资源及兼容性配置； <br/>
同时也添加了一些限制，例如主线程不能访问网络等。</li>
<li>创建进程对应的ContextImpl、LoadedApk、Application等对象，同时加载Application中的ContentProvider，并初始化Application。</li>
<li>使用Instrumentation监控Activity的生命周期。（一个进程对应一个Instrumentation实例）</li>
</ol>

<p>当完成上述工作后，新建的进程终于加入到了Android体系。</p>

<blockquote>
<p>6.AMS通知淘宝绑定Application并启动MainActivity。</p>
</blockquote>

<h2 id="toc_16">启动Activity</h2>

<h3 id="toc_17">attachApplicationLocked</h3>

<p>在上述代码AMS的<code>attachApplicationLocked</code>方法中，我们说道：</p>

<blockquote>
<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。  </p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity</li>
</ol>
</blockquote>

<p>绑定了Application之后，我们就可以启动Activity(淘宝MainActivity)。 </p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;

        //ActivityStackSupervisor维护着终端中所有ActivityStack
        //此处通过轮询，找出前台栈顶端的待启动Activity
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) {
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }

                ActivityRecord hr = stack.topRunningActivityLocked();
                if (hr != null) {
                    //前台待启动的Activity与当前新建的进程一致时，启动这个Activity
                    if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid
                            &amp;&amp; processName.equals(hr.processName)) {
                        try {

                            //realStartActivityLocked进行实际的启动工作
                            if (realStartActivityLocked(hr, app, true, true)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {

                        }
                    }
                }
            }
        }

        return didSomething;
    }
</code></pre>

<p>大概系统工程师也觉得这个启动过程贼鸡儿绕了，最终启动的方法命名为realStartActivityLocked，意味着告诉你，大伙儿不要搞晕了，这个就是最后启动Activity的方法了。<br/><br/>
最后我们直捣黄龙，在<code>ActivityStackSupervisor</code>方法中，我们找到如下代码</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,
                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,
                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);
</code></pre>

<p>看到这里想必大伙儿都明白了，AMS最后通过ApplicationThread通知ActivityThread启动Activity，感觉这一切的通讯都像发电报一样，鬼斧神工出神入化，皆出架构师之目营心匠。<br/><br/>
那么到这里我们就能推算出接下来的老套路了<br/><br/>
ApplicationThread—&gt; H—&gt; ActivityThread—&gt; 最终启动Activity的方法。  </p>

<h3 id="toc_18">ActivityThread</h3>

<pre class="line-numbers"><code class="language-java">//ActivityThread


    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {
        @Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();
            //设置参数
            ``````

            //从LAUNCH_ACTIVITY这个标识我们就可以知道，它就是用来启动Activity
            sendMessage(H.LAUNCH_ACTIVITY, r);
        }
    }

    private class H extends Handler {
        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    //利用ApplicationInfo等信息得到对应的LoadedApk，保存到ActivityClientRecord
                    //ActivityClientRecord包含Activity相关的信息
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
            }
        }
    }
</code></pre>

<pre class="line-numbers"><code class="language-java">//ActivityThread


private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ``````

    Activity a = performLaunchActivity(r, customIntent);
    if (a != null) {
        ``````
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

        ``````
    } 
    ``````
}
</code></pre>

<p><code>handleLaunchActivity</code>方法里有有两个重要的函数调用,</p>

<ul>
<li>performLaunchActivity : 会调用Activity的onCreate,onStart,onResotreInstanceState方法</li>
<li>handleResumeActivity : 会调用Activity的onResume方法.</li>
</ul>

<blockquote>
<p>从上面的源码可以看出，performLaunchActivity方法最终完成了Activity对象的创建和启动过程，并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。</p>
</blockquote>

<h3 id="toc_19">performLaunchActivity</h3>

<p><code>【performLaunchActivity】</code> 这个方法主要完成了如下几件事。【摘自Android开发艺术探索】</p>

<h4 id="toc_20">从ActivityClientRecord中获取待启动的Activity的组件信息。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }

        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }

        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }
</code></pre>

<h4 id="toc_21">通过Instrumentation的newActivity方法使用类加载器创建Activity对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            ``````
        }
</code></pre>

<h4 id="toc_22">通过LoadedApk的makeApplication方法来创建Application对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


Application app = r.packageInfo.makeApplication(false, mInstrumentation);//r.packageInfo为LoadedApk对象
</code></pre>

<p>其实在我们上面的bindApplication中，我们就有介绍到通过<code>LoadedApk</code>创建Application，并且创建完毕后，通过<code>Instrumentation的callApplicationOnCreate</code>来调用<code>Application</code>的onCreate方法</p>

<pre class="line-numbers"><code class="language-java"> Application app = data.info.makeApplication(data.restrictedBackupMode, null);

    ``````
 mInstrumentation.callApplicationOnCreate(app);
</code></pre>

<p>所以第三步是为了判断Application是否为空，而且我们从makeApplication方法中也能看出如果Application已经被创建过了，那么就不会再重复创建了。</p>

<h4 id="toc_23">创建ContextImpl对象，并通过Activity的attach方法来完成一些重要数据的初始化。</h4>

<pre class="line-numbers"><code class="language-java">
                Context appContext = createBaseContextForActivity(r, activity);//创建ContextImpl对象

                ``````
                Window window = null;
                if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
</code></pre>

<blockquote>
<p>ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立关联的，除此之外<strong>，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接收到外部输入事件后就可以将事件传递给Activity</strong>。</p>
</blockquote>

<h4 id="toc_24">调用Activity的onCreate方法</h4>

<p><code>mInstrumentation.callActivityOnCreate(activity, r.state);</code></p>

<p>由于Activity的onCreate已经被调用，这也意味着Activity已经完成了整个启动过程。</p>

<h4 id="toc_25">调用Activity的onStart,onResotreInstanceState方法</h4>

<pre class="line-numbers"><code class="language-java">        mInstrumentation.callActivityOnCreate(activity, r.state);

        ``````
        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
</code></pre>

<h2 id="toc_26">总结</h2>

<p>至此从Launcher启动Activity的工作过程整个流程已经阐述完毕了，通过这次分析，对启动Activity的来龙去脉有了大致的掌控，但是也留下了几个知识点尚未探索清晰。（越深入探索，越发现不足）</p>

<ul>
<li>Looper，Handler的工作机制（Android的消息机制）</li>
<li>Context 到底是什么</li>
<li>Window的内部机制又是怎样的</li>
</ul>

<p>如果是淘宝MainActivity启动LoginActivity呢？<br/><br/>
其实原理和上述过程大体一致，只是在<code>ActivityStackSupervisor</code>的<code>startSpecificActivityLocked</code>方法中，发现进程已经启动，直接调用<code>realStartActivityLocked</code>启动Activity。</p>

<p><figure><img src="media/15561207871029/15713362420977.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870990.html">
                
                  <h1>Android机型适配</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">多机型 UI 适配</h2>

<p>在 Android 开发的工作日常中，UI 适配是一件比较重要的事情。一般开发新的功能，有新的页面，最终开发完成发布之前，都需要让设计师来审 UI 效果。</p>

<p>而有时候，明明我们已经在一款标准的 3 倍手机上，做到了让设计师小姐姐满意的效果，但是当换了另外一台手机的时候，效果又不那么如意。</p>

<p>传统的做法是，拿到效果不对的手机，单独适配看看是不是哪里布局写的不对导致效果不正确，然后改正它。但是总能碰到我们拿不到真实设备的情况。</p>

<p>本文就介绍一个命令，可以修改你当前设备的参数，来模拟出目标设备的显示效果，让你独立就把多机型 UI 效果确认的事情给做了。</p>

<h2 id="toc_1">WM 命令</h2>

<h3 id="toc_2">什么是 WM 命令</h3>

<p>说的这么厉害，实际上需要使用的就是一行 wm 命令，可以通过 <code>adb shell</code> 来操作它。</p>

<p>wm 命令主要用来帮助我们修改一些屏幕的参数，先来看看它的文档。使用 <code>adb shell wm</code> 命令，可以方便的查看 wm 的文档描述</p>

<p><figure><img src="media/15561207870990/15713361587532.jpg" alt=""/></figure></p>

<p>可以看到，wm 命令可以帮助我们修改当前设备的 size 、 density 等参数，而这两个参数就是决定了当前设备的显示效果。</p>

<h3 id="toc_3">WM 的命令</h3>

<p>从上面的文档可以看出，它其实支持的命令还是挺多的，但是有一些根本用不上，是需要系统权限的，所以正常来说我们是无法使用的。那么，还是介绍几个比较实用的命令。</p>

<p>以下例子都是在一款标准 density 为 3 的设备上运行的，屏幕像素为 1080px * 1920px。</p>

<h4 id="toc_4">wm size</h4>

<p><code>wm size</code> 命令，可以用来查询和修改当前设备的尺寸，如果想要修改尺寸，可以使用 <strong>px</strong> 或者 <strong>dp</strong> 为单位（默认为 px），使用 <strong>x</strong> 进行连接，这个其实看看 <code>wm size</code> 的输出，你就清楚了。</p>

<p><figure><img src="media/15561207870990/15713361671418.jpg" alt=""/></figure></p>

<p>在这里的例子中，做了几件事情：</p>

<ul>
<li>使用 wm size 命令查看当前设备的尺寸。</li>
<li>使用 wm size 命令将当前尺寸修改成了 1000x2000。</li>
<li>再次使用 wm size 命令查看当前设备的尺寸。</li>
<li>最后使用 wm size reset 命令，将屏幕尺寸还原。</li>
<li>再用 wm size 命令，查看还原后的尺寸。</li>
</ul>

<p>这几个步骤就已经涵盖了 wm size 命令的所有使用步骤，可以使用它查看当前屏幕尺寸，并且修改屏幕尺寸和还原它。</p>

<h4 id="toc_5">wm density</h4>

<p><code>wm density</code> 命令，可以用来查看和修改当前设备的 density 参数。</p>

<p>使用起来很简单，直接上命令了。</p>

<p><figure><img src="media/15561207870990/15713361747771.jpg" alt=""/></figure></p>

<p>在这个例子中，我做了几件事情：</p>

<ul>
<li>使用 wm density 查看当前设备的 density。</li>
<li>在使用 wm density 命令，修改当前设备的 density 为 420。</li>
<li>然后再使用 wm density 查看修改后的参数。</li>
<li>最后使用 wm density reset 将设备的 density 还原。</li>
<li>最后再查看一下还原后的值。</li>
</ul>

<h4 id="toc_6">wm overscan</h4>

<p><code>wm overscan</code> 命令，可以修改当前设备的屏幕内边距。其实我觉得这个命令没什么用处，但是还是演示一下如何使用。</p>

<pre class="line-numbers"><code class="language-shell">adb shell wm overscan 20,20,20,20
adb shell wm overscan reset
</code></pre>

<p>在这个例子中，做了几件事情：</p>

<ul>
<li>使用 wm overscan 修改边距为 20 。</li>
<li>然后使用 wm overscan reset 将其还原。</li>
</ul>

<h3 id="toc_7">WM 命令的原理</h3>

<p>wm 命令的逻辑非常的简单，它实际上是和 WindowManagerService 进行交互，通过 WMS 来修改屏幕相关的一些参数。</p>

<p>这里就不介绍完整的 wm 源码了，就以一个方法举例来看看 wm 的逻辑。这里就以 <code>wm size</code>命令举例好了。</p>

<p>首先，看看 wm 命令的入口。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onRun() throws Exception {
    mWm = IWindowManager.Stub.asInterface(ServiceManager.checkService(Context.WINDOW_SERVICE));
    if (mWm == null){
        System.err.println(NO_SYSTEM_ERROR_CODE);
        throw new AndroidException(&quot;Can`t connect to window manager;is the system running?&quot;);
    }
    
    String op = nextArgRequired();
    
    if (op.equals(&quot;size&quot;)) {
        runDisplaySize();
    } else if (op.equals(&quot;overscan&quot;)){
        runDisplayOverscan();
    } else if (op.equals(&quot;scaling&quot;)){
        runDisplayScaling();
    } else if (op.equals(&quot;screen-capture&quot;)){
        runSetScreenCapture();
    } else if (op.equals(&quot;dismiss-keyguard&quot;)){
        runDismissKeyguard();
    } else {
        showError(&quot;Error: unknown command ` &quot; + op + &quot;`&quot;);
        return;
    }
}
</code></pre>

<p>这里会初始化 mWm ，并且根据输入的参数，调用不同的方法，如果输入的是 size ，则会调用 <code>runDisplaySize()</code> 方法。</p>

<pre class="line-numbers"><code class="language-java">private void runDisplaySize() throws Exception {
    String size = nextArg();
    int w,h;
    if (size == null){
        Point initialSize = new Point();
        Point baseSize = new Point();
        try {
            mWm.getInitialDisplaySize(Display.DEFAULT_DISPLAY, initialSize);
            mWm.getBaseDisplaySize(Display.DEFAULT_DISPLAY, baseSize);
            System.out.println(&quot;Physical size:&quot; + initialSize.x + &quot;x&quot; + initialSize.y);
            if (!initialSize.equals(baseSize)){
                System.out.println(&quot;Override size:&quot; + baseSize.x + &quot;x&quot; + baseSize.y);
            }
        } catch (RemoteException e){
        }
        return;
    } else if (&quot;reset&quot;.equals(size)){
        w = h = -1;
    } else {
        int div = size.indexOf(&#39;x&#39;);
        if (div &lt;= 0 || div &gt;= (size.length() - 1)){
            System.err.println(&quot;Error: bad size&quot; + size);
            return;
        }
        String wstr = size.substring(0,div);
        String hstr = size.substring(div + 1);
        try {
            w = parseDimension(wstr);
            h = parseDimension(hstr);
        } catch (NumberFormatException e){
            System.err.println(&quot;Error: bad number&quot; + e);
            return;
        }
    }
    
    try {
        if (w &gt;= 0 &amp;&amp; h &gt;= 0){
            mWm.setForcedDisplaySize(Display.DEFAULT_DISPLAY, w, h);
        } else {
            mWm.clearForcedDisplaySize(Display.DEFAULT_DISPLAY);
        }
    } catch (RemoteException e) {
    }
}
</code></pre>

<p>在 <code>runDisplaySize()</code> 方法中，会先判断 size 命令后面有没有跟其它参数，如果没有，则认为是一次查询操作，会将查询到的结果输出。</p>

<p>而如果是 reset 方法的话，就将 w 、h 这两个代表宽高的值，设置为 -1，最终会通过 <code>mWm.clearForcedDisplaySize()</code> 方法，将屏幕的 size 还原。</p>

<p>否者就从输入的参数中，通过 x 进行分割，拿到我们输入的宽高。最终通过 <code>mWm.setForcedDisplaySize()</code> 方法，将当前屏幕的 size 修改成我们输入的结果。</p>

<p>在设置size 的时候，还会通过 <code>parseDimens()</code> 方法，重新计算一下输入的尺寸。</p>

<p>private int parseDimension(String s) throws NumberFormatException {<br/>
    if (s.endsWith(&quot;px&quot;)) {<br/>
        return Integer.parseInt(s.substring(0, s.length() - 2));<br/>
    }<br/>
    if (s.endsWith(&quot;dp&quot;)){<br/>
        int density;<br/>
        try {<br/>
            density = mWm.getBaseDisplayDensity(Display.DEFAULT_DISPLAY);<br/>
        } catch (RemoteException e) {<br/>
            density = DisplayMetrics.DENSITY_DEFAULT;<br/>
        }<br/>
        return Integer.parseInt(s.substring(0,s.length() - 2)) * density / DisplayMetrics.DENSITY_DEFAULT;<br/>
    }<br/>
    return Integer.parseInt(s);<br/>
}</p>

<p>从这里可以看出，它支持两个尺寸，px 和 dp ，如果如果不指定尺寸，则默认认为是 px 。</p>

<p>到这里就完成了一次通过 <code>wm size</code> 命令，修改设备屏幕参数的全过程，跟多细节可以自行查阅源码。</p>

<p>源码的在线地址：</p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fandroidxref.com%2F7.1.1_r6%2Fxref%2Fframeworks%2Fbase%2Fcmds%2Fwm%2Fsrc%2Fcom%2Fandroid%2Fcommands%2Fwm%2FWm.java">androidxref.com/7.1.1_r6/xr…</a></p>

<h2 id="toc_8">实施修改设备参数</h2>

<p>既然已经讲清楚 wm 命令的所有细节了，那么我们只需要拿到我们需要适配的设备的 size 和 density。就可以在我们自己的设备上模拟出对应的效果。</p>

<p>我这里收集了一些比较常用的设备参数，可以供大家参考一下。</p>

<ul>
<li>魅族MX3：440，1080x1800</li>
<li>一加5：420，1080x1920</li>
<li>红米NOTE，320，720x1280</li>
<li>华为MATE7，480，1080x1812</li>
<li>MOTO-G5，480，1080x1920</li>
<li>Moto-tx1095，432，1080x1790</li>
<li>Nexus5x，420，1080x1794</li>
<li>Nexus6p，560，1440x2392</li>
<li>奇酷360，460，1080x1920</li>
<li>VivoX5，320，720x1280</li>
</ul>

<p>当然，最重要的是拿到公司各种 CEO、CTO、CxO 正在使用的手机参数，进行一波适配，哈哈。</p>

<p>下面，我们随便挑两个设备的参数进行修改，然后看看运行后的效果。</p>

<p>命令如下:</p>

<p>// 修改成 一加5</p>

<p>adb shell wm density 420</p>

<p>adb shell wm size 1080x1920</p>

<p>// 修改成 Moto-tx1095</p>

<p>adb shell wm density 432</p>

<p>adb shell wm size 1080x1790</p>

<p>下面，从做到右，分别是原本的尺寸、一加5、Moto-tx1095。</p>

<p><figure><img src="media/15561207870990/15713361843381.jpg" alt=""/></figure></p>

<p>其实看着差异不大，只能说桌面布局写的挺好的，所以说，如果布局写的好的话，是可以避免在不同设备上看着很明显的不同的问题 ，就像现在这样。</p>

<h2 id="toc_9">题外话</h2>

<p>实际上 wm 命令，也是有一些其它问题的，例如有时候通过 wm 命令修改 UI 的的时候，刷新会不及时，会卡顿，所以选择一个性能比较好的手机是一个缓解的办法。或者修改参数之后，退出 App 重新进也是一个不错的办法。</p>

<p>如果调整到一个太特殊的参数，例如 200x1000 这种，可能渲染起来会很奇怪。但是如果只是做一些常规设备参数的修改，只要修改值在合理的范围内，一般都是可以的。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870955.html">
                
                  <h1>Android项目从立项到上线</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！</p>

<p>接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github：</p>

<ul>
<li>Material Design风格项目 <a href="https://github.com/shuaijia/MaterialDesignProject">点击前往</a> 喜欢就给个star<sup>_^</sup></li>
<li>UI、Base、网络等封装库项目 <a href="https://github.com/shuaijia/JSBaseDemo">点击前往</a> 喜欢也给个star喽</li>
</ul>

<p>先上图来看看吧：</p>

<p><figure><img src="media/15561207870955/15713360246063.png" alt=""/></figure></p>

<p>项目采用<strong>MVP+Retrofit+RxJava+Gson+Glide+Material Design</strong>设计</p>

<p>同时也使用了<strong>EventBus</strong>事件总线、<strong>GreenDao</strong>数据库、<strong>SurfaceView+MediaPlayer视频播放器</strong>等主要技术。</p>

<p>ok！项目就简单介绍到这里，接下来开始我们的修仙之路。</p>

<p><figure><img src="media/15561207870955/15713360322852.png" alt=""/></figure></p>

<h2 id="toc_0">项目整体分析</h2>

<h3 id="toc_1">UI风格</h3>

<h4 id="toc_2">logo</h4>

<h4 id="toc_3">主题风格：</h4>

<ul>
<li>Material Design</li>
<li>仿ios</li>
<li>主界面–侧拉</li>
<li>主界面–仿微信 选项卡等</li>
</ul>

<h3 id="toc_4">技术方案</h3>

<h4 id="toc_5">整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。</h4>

<ul>
<li>项目架构</li>
<li>网络框架</li>
<li>图片处理</li>
<li>数据处理/接口格式</li>
<li>三方使用：统计、推送、更新等</li>
</ul>

<h3 id="toc_6">可行性分析</h3>

<p>邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。</p>

<h3 id="toc_7">工期</h3>

<p>根据项目需求和技术方案，给出开发时长；</p>

<p>根据工期要求，可适当调整技术方案。</p>

<h3 id="toc_8">测试用例</h3>

<p>测试人员开始整理、编写测试用例和项目标准文档；</p>

<p>个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。</p>

<h2 id="toc_9">开发规范</h2>

<p>其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范：</p>

<p>以自己项目为例，涉及到以下几项：</p>

<ul>
<li>文档规范</li>
<li>资源命名规范</li>
<li>代码命名规范</li>
<li>代码注释规范</li>
<li>代码风格规范</li>
<li>服务器数据规范 等</li>
</ul>

<h3 id="toc_10">文档</h3>

<p>重要有以下几个文档：</p>

<ul>
<li>需求文档</li>
<li>产品原型图</li>
<li>完整UI图</li>
<li>接口文档</li>
<li>核心技术文档</li>
<li>重点逻辑文档</li>
<li>程序框架图</li>
<li>ER图、数据字典、类图等</li>
<li>测试文档</li>
</ul>

<h3 id="toc_11">资源文件命名规范</h3>

<p>名字全部小写，最好不用数字，全部英文，单词中间下划线隔开</p>

<h4 id="toc_12">drawable、anim等文件夹下</h4>

<p>名称结构为“技术点模块点空间类型_功能名”结构，技术点主要有：selector、translate、alpha、scale等，模块名主要有：login、pay、mine、setting等，控件类型主要有：button、textview、imageview、dialog等，功能名主要有：findpwd、request、back、next等。 </p>

<p><figure><img src="media/15561207870955/15713360426518.png" alt=""/></figure></p>

<h4 id="toc_13">drawable-xhdpi等图片资源</h4>

<p>名称为“技术点模块点功能名”结构，技术点主要有：activity、fragment、item、include等，模块点主要有：login、setting、mine、pay等，功能名主要有：head、title、back、sure等。 </p>

<p><figure><img src="media/15561207870955/15713360520787.png" alt=""/></figure></p>

<h4 id="toc_14">layout</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><figure><img src="media/15561207870955/15713360607859.png" alt=""/></figure></p>

<h4 id="toc_15">values</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><figure><img src="media/15561207870955/15713360714083.png" alt=""/></figure></p>

<h3 id="toc_16">代码命名规范</h3>

<h4 id="toc_17">包名</h4>

<p>包名为“根包名.技术点名.模块名”结构，<strong>全部小写</strong></p>

<p><figure><img src="media/15561207870955/15713360791901.png" alt=""/></figure></p>

<h4 id="toc_18">类名</h4>

<p>采用 <strong>大驼峰</strong> 命名法，单词直接拼接，所有单词首字母大写</p>

<p>类名为“业务模块名 执行操作名 技术点名”结构，业务模块名主要有：home、lession、net、login，pay等，操作名主要有：Get、Set、Request、Login等，技术点名主要有：Activity、Fragment、View、Adapter等。 </p>

<p><figure><img src="media/15561207870955/15713360893838.png" alt=""/></figure></p>

<h4 id="toc_19">普通变量</h4>

<p>采用 <strong>小驼峰</strong> 命名法，第一个单词首字母小写，其他单词首字母大写。</p>

<p>普通变量为“名字简写 类型 功能名”结构，名字简写有：js等，类型主要有：Int、Double、Boolean、String、Char等，功能名有：Login、Number、Content等。 </p>

<p><figure><img src="media/15561207870955/15713360966735.png" alt=""/></figure></p>

<h4 id="toc_20">常亮</h4>

<p>所有字母全部大写，中间下划线隔开</p>

<p>常量为“功能名_标识”结构，功能名主要有：LOGIN、REQUEST、PERSONINFO等，标识有SUCCESS、ERROR、URL等。</p>

<p><figure><img src="media/15561207870955/15713361041900.png" alt=""/></figure></p>

<h3 id="toc_21">方法名</h3>

<p>名字能体现出功能即可。不再累赘重述。</p>

<h2 id="toc_22">数据/接口定义</h2>

<h3 id="toc_23">建议</h3>

<ul>
<li>服务器返回数据采用json格式</li>
<li>json数据中无数据，必须返回空数组或空字符串，不可返回null</li>
<li>Android端使用gson或fastjson或jackson等三方解析工具解析</li>
<li>不建议使用官方JSONObject解析，容易出错</li>
<li>实体类属性名与json中字段名完全一致</li>
<li>json中字段名全部使用英文，不可英文、拼音夹杂</li>
<li>用户表识建议使用Cookie</li>
<li>建议使用POST解析，它对参数数量没有要求，也比较安全</li>
<li>为了传输安全，使用https请求 等</li>
<li>完善接口文档，建议每一版对应一个完整接口文档</li>
</ul>

<h2 id="toc_24">屏幕适配</h2>

<p>安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的720 * 1280和1080 * 1920手机进行适配，同时对于其他类型手机也要适配。</p>

<p>关于屏幕适配，之前写过一个Android屏幕完美适配方案，<a href="http://blog.csdn.net/jiashuai94/article/details/77639511">点击前往</a>，这里不再重复表述。</p>

<h2 id="toc_25">程序架构MVP</h2>

<p><figure><img src="media/15561207870955/15713361130763.png" alt=""/></figure></p>

<h3 id="toc_26">上图介绍：</h3>

<p><strong>Contract</strong>：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。</p>

<p><strong>ViewInterface</strong>： view层接口，定义了view中的UI操作</p>

<p><strong>ModelInterface</strong>： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等</p>

<p><strong>CallbackInterface</strong>： model层操作数据完成后的回调</p>

<p><strong>BasePersenter</strong>： Persenter父类，主要是对相关view的获取，销毁等操作</p>

<p><strong>View</strong>： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应</p>

<p><strong>Model</strong>： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack</p>

<p><strong>Persenter</strong>： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示</p>

<h3 id="toc_27">MVP：</h3>

<p>MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。</p>

<p>使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要</p>

<p>现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。</p>

<h2 id="toc_28">package划分</h2>

<p><figure><img src="media/15561207870955/15713361217174.png" alt=""/></figure></p>

<p>如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。</p>

<p>总之，我们划分包时：以功能模块为主，以技术点为辅。</p>

<h2 id="toc_29">Base、Util、UI类封装</h2>

<h3 id="toc_30">Base类</h3>

<ul>
<li>BaseApplication</li>
<li>BaseActivity</li>
<li>BaseFragment</li>
<li>BasePresenter 等</li>
</ul>

<h4 id="toc_31">BaseApplication：</h4>

<p>主要进行一些例如：<strong>三方配置</strong>、<strong>热更新加载</strong>、<strong>文件配置</strong>、<strong>数据库配置</strong>等准备工作；同时也许定义全局性变量：如<strong>Application的Context</strong>、<strong>网络状态</strong>、<strong>主线程Looper</strong>、<strong>主线程Handler</strong>等。</p>

<h4 id="toc_32">BaseActivity：</h4>

<p>封装为抽象类，将各任务抽取成方法，有子类实现：比如<strong>findViewById(initView)</strong>、<strong>initData</strong>、<strong>setListener</strong>等；</p>

<p>对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。</p>

<p>项目为MVP结构，所以设置了View和Presenter的泛型，如：</p>

<p>其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。</p>

<p><figure><img src="media/15561207870955/15713361287302.png" alt=""/></figure></p>

<h4 id="toc_33">BaseFragment：</h4>

<p>BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；</p>

<p>创建createView(创建跟视图view)、initChildView(子view findViewById)、initData(加载数据)抽象方法</p>

<h4 id="toc_34">BasePresenter：</h4>

<p><figure><img src="media/15561207870955/15713361372176.png" alt=""/></figure></p>

<p>BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。</p>

<h3 id="toc_35">Utils类</h3>

<h4 id="toc_36">只列举一些常用的工具类：</h4>

<ul>
<li>SharedPreferenceUtils</li>
<li>ToastUtils</li>
<li>StorageUtils</li>
<li>FileUtils</li>
<li>NetUtils</li>
<li>deviceUtils</li>
<li>DateUtils</li>
<li>LogUtils</li>
<li>AppUtils 等</li>
</ul>

<h3 id="toc_37">UI类</h3>

<h4 id="toc_38">只列举一些常用的View类</h4>

<ul>
<li>下拉刷新、上拉加载</li>
<li>圆形ImageView</li>
<li>自定义Dialog</li>
<li>Banner</li>
<li>自定义ScrollView</li>
<li>自定义RecyclerView</li>
<li>项目相关的自定义View 等</li>
</ul>

<h2 id="toc_39">数据库</h2>

<p>关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。</p>

<p>但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；</p>

<p>所以我们只介绍几款流行的数据库框架：</p>

<ul>
<li>GreenDao</li>
<li>OrmLite</li>
<li>LitePal</li>
<li>Realm</li>
</ul>

<h3 id="toc_40">GreenDao：</h3>

<p><strong>特点</strong>：</p>

<ol>
<li>存取速度快; </li>
<li>支持数据库加密; </li>
<li>轻量级; </li>
<li>激活实体;</li>
<li>支持缓存; </li>
<li>代码自动生成</li>
</ol>

<p><strong>地址</strong>：<a href="https://github.com/greenrobot/greenDAO">https://github.com/greenrobot/greenDAO</a></p>

<h3 id="toc_41">OrmLite：</h3>

<p><strong>优点</strong>： </p>

<ol>
<li>轻量级；</li>
<li>使用简单，易上手；</li>
<li>封装完善；</li>
<li>文档全面。</li>
</ol>

<p><strong>缺点</strong>：</p>

<ol>
<li>基于反射，效率较低（本人还没有觉得效率低)</li>
<li>缺少中文翻译文档</li>
</ol>

<p><strong>jar包地址</strong>：<a href="http://ormlite.com/releases/">http://ormlite.com/releases/</a></p>

<h3 id="toc_42">LitePal：</h3>

<p>LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。</p>

<p>地址：<a href="https://github.com/LitePalFramework/LitePal">https://github.com/LitePalFramework/LitePal</a></p>

<h3 id="toc_43">Realm：</h3>

<ol>
<li><p>易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。</p></li>
<li><p>快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。</p></li>
<li><p>跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。</p></li>
<li><p>高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性</p></li>
<li><p>可视化</p></li>
</ol>

<p><a href="https://github.com/realm/realm-java">git地址</a></p>

<p><a href="https://realm.io/docs/java/latest/#getting-started">官网</a></p>

<p>自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。</p>

<h2 id="toc_44">图片处理</h2>

<p>之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。</p>

<p>但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点：</p>

<h3 id="toc_45">ImageLoader：</h3>

<p><strong>优点</strong>:</p>

<ul>
<li>多线程下载，线程管理。</li>
<li>多级缓存架构设计和策略，内存缓存，磁盘缓存，缓存有效性处理。</li>
<li>图片压缩，特效处理，动画处理。</li>
<li>复杂网络情况下下载图片策略，例如弱网络等。</li>
<li>内存管理，lru 算法、对象引用、GC回收等优化。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>时间久，官方不再维护，出现bug需要自己修复。</li>
</ul>

<h3 id="toc_46">Glide：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。</li>
<li>Glide可以加载GIF动态图。</li>
<li>Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是加载显示非常快。</li>
<li>默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley下载，也可以自定义下载方式。</li>
<li>默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小。</li>
<li>默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>Glide加载的图片质量要差于Picasso，这是因为Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半。</li>
</ul>

<h3 id="toc_47">Picasso：</h3>

<p><strong>特点</strong>：</p>

<ul>
<li>在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。</li>
<li>使用复杂的图片压缩转换来尽可能的减少内存消耗</li>
<li>自带内存和硬盘二级缓存功能</li>
</ul>

<h3 id="toc_48">Fresco：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了</li>
<li>图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。</li>
<li>支持加载Git动态图和Webp格式的图片。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>框架体积比较大，3M左右，会增加APK的大小。</li>
</ul>

<p>总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。</p>

<h2 id="toc_49">网络框架</h2>

<p>上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。</p>

<p>但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下：</p>

<h3 id="toc_50">添加依赖</h3>

<pre class="line-numbers"><code class="language-text">compile &#39;io.reactivex:rxjava:x.y.z&#39;
compile &#39;io.reactivex:rxandroid:1.0.1&#39;
compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;
compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;
compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;
</code></pre>

<p>要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致</p>

<h3 id="toc_51">登录Service</h3>

<pre class="line-numbers"><code class="language-text">interface BaseService {
  @GET(&quot;user/login&quot; )
  Observable&lt;User&gt; login(
          @Query(&quot;username&quot;) String username,
          @Query(&quot;password&quot;) String password
  );
}
</code></pre>

<p>login方法的返回值是Observable类型，就是RxJava中的被观察者。</p>

<h3 id="toc_52">网络请求</h3>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create()           
    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())//新的配置
    .baseUrl(BASE_URL)
    .build();
BaseService service = retrofit.create(BaseService.class);

service.login(phone, password)               //获取Observable对象
    .subscribeOn(Schedulers.newThread())//请求在新的线程中执行
    .observeOn(Schedulers.io())         //请求完成后在io线程中执行
    .doOnNext(new Action1&lt;UserInfo&gt;() {
        @Override
        public void call(User user) {
            saveUserInfo(user);//保存用户信息到本地
        }
    })
    .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行
    .subscribe(new Subscriber&lt;User&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {
            //请求失败
        }

        @Override
        public void onNext(User user) {
            //请求成功
        }
});
</code></pre>

<p>RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</p>

<p>可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。</p>

<pre class="line-numbers"><code class="language-text">注意：Retrofit在创建的时候添了一下代码
addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre>

<p>想了解更多关于RxJava，浏览<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1">http://gank.io/post/560e15be2dca930e00da1083#toc_1</a></p>

<h2 id="toc_53">其他三方</h2>

<p>在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；</p>

<p>也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；</p>

<p>就不再一一列举，附上一张图，大家有时间多去学习、多去了解。</p>

<p><figure><img src="media/15561207870955/15713361449592.png" alt=""/></figure></p>

<h2 id="toc_54">混淆、加固、上线</h2>

<h3 id="toc_55">混淆</h3>

<p>大家可以参考我的<a href="http://blog.csdn.net/jiashuai94/article/details/77991077">另一篇文章</a></p>

<p>混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。</p>

<h4 id="toc_56">坚持以下几项原则：</h4>

<ul>
<li>使用三方依赖，在混淆文件中添加官方提供的混淆代码，官方没有就google；</li>
<li>实体类不混淆，因为实体类涉及到与服务端的交互，各种gson的交互如此等等，是要保留的；</li>
<li>与js互调的类不混淆；</li>
<li>与反射有关的类不混淆 等。</li>
</ul>

<h4 id="toc_57">具体语法：</h4>

<pre class="line-numbers"><code class="language-text">-optimizationpasses 5 // 代码混淆的压缩比例，值在0-7之间
-dontusemixedcaseclassnames // 混淆后类名都为小写
-dontskipnonpubliclibraryclasses // 指定不去忽略非公共的库的类
-dontskipnonpubliclibraryclassmembers // 指定不去忽略非公共的库的类的成员
-dontpreverify // 不做预校验的操作

-verbose
-printmapping proguardMapping.txt // 生成原类名和混淆后的类名的映射文件

-optimizations !code/simplification/cast,!field/*,!class/merging/* // 指定混淆时采用的算法
-keepattributes *Annotation*,InnerClasses // 不混淆Annotation
-keepattributes Signature // 不混淆泛型
-keepattributes SourceFile,LineNumberTable // 抛出异常时保留代码行号
-keep class XXXX // 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。
-keepclasseswithmembers class XXXX // 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。
</code></pre>

<p><strong>加固</strong>：</p>

<p>加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。</p>

<p>360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..）</p>

<p><strong>上线</strong>：</p>

<p>也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。</p>

<p>每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。</p>

<p>发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。</p>

<p>ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870919.html">
                
                  <h1>Android学习路线</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android学习路线从4个阶段来对Android的学习过程做一个全面的分析:Android初级、中级、高级以及资深工程师。<br/>
只针对Android应用开发，不针对Rom开发和逆向工程等。方便起见虚拟“小D”为成长人物进行描述。</p>

<h2 id="toc_1">初级工程师</h2>

<p>小D之前完全没接触过Android开发，对编程基础、数据结构、C语言都有一定基础，Java语法什么的也都掌握的比较好，并不会搞Android。 </p>

<p>首先需要购买一本Android入门的书籍（现在更推荐直接看视频教程结合网上教程动手练习），为了更快地学习Android，小D业余时间也都用来一边看书一边照着书中的例子敲代码，结果2周时间小D就把这本书学了一遍。看完这本书后对Android的历史、结构、代码规范等都有了一个大概的了解，可以写出一些简单的Activity。这个时候在小D眼里，Android开发很简单很好玩，通过在xml中摆放一些按钮文本框什么的就可以做一些界面了。</p>

<p>小D开始跟着他的技术导师做需求，一些简单的小需求不在话下了。突然有一天来了一个需求，该需求要求在Activity中为一个button加一个动画效果，小D慌了：“完全没接触过，书上也没有讲，怎么办呢？”小D冷静了下，搜索“Android 动画”，打开前几个链接，恍然大悟，照着网上的例子把需求给实现了。 </p>

<p>后来导师告诉他：“学好Android，官方文档是必须看的，既全面又权威”。然后小D如获至宝，花了一年时间把上面的guide和training都看了一遍，并且他还动手抄了几个小例子。</p>

<p>有一天，小D又需要做一个动画相关的需求，又搜索“Android 动画”，突然他楞了一下：”总不能每次写动画都要搜索吧！“，于是他在CSDN开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用去搜了，事实如何呢？后面再写动画相关的代码，的确不用再去搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小D还学会了把一些琐碎的不方便放在博客上的东西写到了笔记上面，什么时候忘了10秒钟以内都可以快速找回来，而不是花10分钟去再次搜索一遍。</p>

<p>总结：Android入门的时候，需要有一本入门书（或者视频教程），好好学习书中的内容，同时花一年时间把Android官方文档中的training和guide看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。</p>

<p>技术要求：</p>

<ul>
<li>基本知识点<br/>
比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术</li>
<li>书籍推荐<br/>
《第一行代码 Android》、《疯狂Android》</li>
</ul>

<h2 id="toc_2">中级工程师</h2>

<p>小D经过一年的努力学习终于成为Android中级工程师了。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小D还不能一个人承担起来，这个时候小D需要学习的内容就很多了，如下所示：</p>

<ul>
<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>
<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>
<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>
<li>事件分发：弹性滑动、滑动冲突等；</li>
<li>玩转View：View的绘制原理、各种自定义View；</li>
<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>
<li>懂性能优化、熟悉mat等工具</li>
<li>懂点常见的设计模式</li>
</ul>

<h3 id="toc_3">学习方法</h3>

<p>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br/>
如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。<br/>
如何玩转自定义View呢？我们要透过现象看本质，更多地去关注自定义view所需的知识点：</p>

<ul>
<li>搞懂view的滑动原理</li>
<li>搞懂如何实现弹性滑动</li>
<li>搞懂view的滑动冲突</li>
<li>搞懂view的measure、layout和draw</li>
<li>然后再学习几个已有的自定义view的例子</li>
<li>最后就可以搞定自定义view了，所谓万变不离其宗</li>
</ul>

<p>大概再需要1-2年时间，即可达到高级工程师的技术水平。我个人认为通过《Android开发艺术探索》和《Android群英传》可以缩短这个过程为0.5-1年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。</p>

<h3 id="toc_4">技术要求：</h3>

<ul>
<li>稍微深入的知识点<br/>
AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android群英传》</li>
</ul>

<h2 id="toc_5">高级工程师</h2>

<p>小D成为了梦寐以求的高级工程师。这个时候小D的Android水平已经不错了，但是小D的目标是资深工程师，小D听说资深工程师月薪可以达到30k+。<br/>
为了成为Android资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示：</p>

<ul>
<li>继续加深理解”稍微深入的知识点“中所定义的内容</li>
<li>了解系统核心机制：
<ol>
<li>了解SystemServer的启动过程</li>
<li>了解主线程的消息循环模型</li>
<li>了解AMS和PMS的工作原理</li>
<li>能够回答问题”一个应用存在多少个Window？“</li>
<li>了解四大组件的大概工作流程</li>
<li>…</li>
</ol></li>
<li>基本知识点的细节
<ol>
<li>Activity的启动模式以及异常情况下不同Activity的表现</li>
<li>Service的onBind和onReBind的关联</li>
<li>onServiceDisconnected(ComponentName className)和binderDied()的区别</li>
<li>AsyncTask在不同版本上的表现细节</li>
<li>线程池的细节和参数配置</li>
<li>…</li>
</ol></li>
<li>熟悉设计模式，有架构意识</li>
</ul>

<h3 id="toc_6">学习方法</h3>

<p>这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。<br/><br/>
同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，推荐《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到Android源码中的设计思想。  </p>

<h3 id="toc_7">技术要求：</h3>

<ul>
<li>稍微深入的知识点</li>
<li>系统核心机制</li>
<li>基本知识点的细节</li>
<li>设计模式和架构</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</li>
</ul>

<h2 id="toc_8">资深工程师</h2>

<p>更多了解不同业务的架构问题，内核源码设计原理，整理并开源自己的组件</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870883.html">
                
                  <h1>Android学习目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207870883/15713359653854.png" alt=""/></figure></p>

<h2 id="toc_0">基础知识</h2>

<p><figure><img src="media/15561207870883/15713359733510.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359818799.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359891037.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359971568.jpg" alt=""/></figure></p>

<p>{% post_link android-learning-path Android学习路线 %}  </p>

<p>{% post_link android-study Android学习资源 %}</p>

<h3 id="toc_1">Java基础</h3>

<p><figure><img src="media/15561207870883/15713360098241.jpg" alt=""/></figure></p>

<h4 id="toc_2">Java字符串(String、StringBuilder、StringBuffer)</h4>

<h4 id="toc_3">Java线程池(newFixedThreadPool、newSingleThreadExecutor、newCacheThreadPool)</h4>

<ul>
<li><p><code>newFixedThreadPool</code>：newFixedThreadPool,创建固定大小的线程池，poolCoreSize和maxPoolSize 相等，到达coreSize,则将新的任务放到缓存队列，有线程执行完毕，直接去取。</p></li>
<li><p><code>newSingleThreadExecutor</code>：newSingleThreadExecutor,创建一个单线程的线程池，核心池的大小和最大池大小都为1.</p></li>
<li><p><code>newCacheThreadPool</code>：newCacheThreadPool,无大小限制的线程池，提交一个任务就创建一个线程执行。</p></li>
</ul>

<h4 id="toc_4">Java集合</h4>

<p><strong>Collection</strong>:</p>

<ul>
<li>List:
<ul>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Vector</li>
</ul></li>
<li>Set
<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul></li>
</ul>

<p><strong>Map</strong>:</p>

<ul>
<li>HashMap</li>
<li>TreeMap</li>
<li>HashTable</li>
</ul>

<h4 id="toc_5">Java内存模型</h4>

<p>Java 内存模型这一块非常重要，因为它涉及到我们程序的性能，我们需要知道，内存是如何分配的，成员变量、静态变量、局部变量、对象等各自分配到哪一个区：栈内存、堆内存</p>

<h3 id="toc_6">数据结构</h3>

<h3 id="toc_7">面向对象思想</h3>

<p>OOP的的三大特性：封装、继承、多态。</p>

<h3 id="toc_8">设计模式</h3>

<h4 id="toc_9">程序设计6大原则</h4>

<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>开闭原则</li>
</ul>

<h3 id="toc_10">Android Studio</h3>

<p>{% post_link android-studio-plugin Android Studio插件 %}  </p>

<p>{% post_link android-studio-keywords Android Studio快捷键 %}</p>

<h3 id="toc_11">Android SDK</h3>

<h3 id="toc_12">Activity</h3>

<p>{% post_link android-activity-launcher Android-启动Acivity的工作流程 %}</p>

<h3 id="toc_13">Service</h3>

<h3 id="toc_14">BroadcastReceiver</h3>

<h3 id="toc_15">ContentProvider</h3>

<h3 id="toc_16">StatusBar</h3>

<p>{% post_link android-statusbar Android-StatusBar详细学习 %}</p>

<h3 id="toc_17">Fragment</h3>

<h4 id="toc_18">DialogFragment</h4>

<p>{% post_link android-dialogfragment Android-DialogFragment详细学习 %}</p>

<h2 id="toc_19">UI</h2>

<p>{% post_link android-xml Android-XML参数详细了解 %}</p>

<h3 id="toc_20">Layout</h3>

<p>{% post_link android-layout Android-Layout详细学习 %}</p>

<h4 id="toc_21">FrameLayout</h4>

<h4 id="toc_22">LinearLayout</h4>

<h4 id="toc_23">TableLayout</h4>

<h4 id="toc_24">GridLayout</h4>

<h4 id="toc_25">RelativeLayout</h4>

<h4 id="toc_26">DrawerLayout</h4>

<h4 id="toc_27">SlidingPaneLayout</h4>

<h4 id="toc_28">CoordinatorLayout</h4>

<p>{% post_link android-coordinatorLayout Android-CoordinatorLayout %}</p>

<h3 id="toc_29">View</h3>

<p>{% post_link android-view-workflow Android-View的工作流程 %}</p>

<h4 id="toc_30">Widgets</h4>

<h5 id="toc_31">TextView</h5>

<h5 id="toc_32">EditText</h5>

<p>{% post_link android-edittext Android-EditText详细学习 %}  </p>

<p>{% post_link android-windowSoftInputMode Android-WindowSoftInputMode详细学习 %}  </p>

<h5 id="toc_33">Button</h5>

<h5 id="toc_34">RadioButton</h5>

<h5 id="toc_35">CheckBox</h5>

<h5 id="toc_36">Switch</h5>

<h5 id="toc_37">ToggleButton</h5>

<h5 id="toc_38">ImageButton</h5>

<h5 id="toc_39">ImageView</h5>

<p>{% post_link android-imageview Android-ImageView详细学习 %}</p>

<h5 id="toc_40">ProgressBar</h5>

<h5 id="toc_41">SeekBar</h5>

<h5 id="toc_42">RatingBar</h5>

<h5 id="toc_43">Spinner</h5>

<h5 id="toc_44">WebView</h5>

<h4 id="toc_45">Containers</h4>

<h5 id="toc_46">RadioGroup</h5>

<h5 id="toc_47">ListView</h5>

<h5 id="toc_48">GridView</h5>

<h5 id="toc_49">ExpandableListView</h5>

<h5 id="toc_50">ScrollVeiw</h5>

<h5 id="toc_51">TabHost</h5>

<h5 id="toc_52">SlidingDrawer</h5>

<h5 id="toc_53">Gallery</h5>

<h5 id="toc_54">VideoView</h5>

<h5 id="toc_55">DialerFilter</h5>

<h5 id="toc_56">RecyclerView</h5>

<p>{% post_link android-recyclerview Android-RecyclerView详细学习 %}  </p>

<h5 id="toc_57">CardView</h5>

<h5 id="toc_58">PopuWindow</h5>

<p>{% post_link android-popupwindow Android-PopupWindow详细学习 %}</p>

<h5 id="toc_59">DialogFragment</h5>

<h4 id="toc_60">Date&amp;Time</h4>

<h5 id="toc_61">TextClock</h5>

<h5 id="toc_62">AnalogClock</h5>

<h5 id="toc_63">Chronometer</h5>

<h5 id="toc_64">DatePicker</h5>

<h5 id="toc_65">TimePicker</h5>

<h5 id="toc_66">CalendarView</h5>

<h4 id="toc_67">Expert</h4>

<h5 id="toc_68">Space</h5>

<h5 id="toc_69">CheckedTextView</h5>

<h5 id="toc_70">QuickContactBadge</h5>

<h5 id="toc_71">ExtractEditText</h5>

<h5 id="toc_72">AutoCompleteTextView</h5>

<h5 id="toc_73">MultiAutoCompleteText</h5>

<h5 id="toc_74">NumberPicker</h5>

<h5 id="toc_75">ZoomButton</h5>

<h5 id="toc_76">ZoomController</h5>

<h5 id="toc_77">GestureOverlayView</h5>

<h5 id="toc_78">SurfaceView</h5>

<h5 id="toc_79">TexttureView</h5>

<h5 id="toc_80">StackView</h5>

<h5 id="toc_81">ViewStub</h5>

<p>{% post_link android-viewstub Android-ViewStub详细学习 %}</p>

<h5 id="toc_82">ViewAnimator</h5>

<h5 id="toc_83">ViewFlipper</h5>

<h5 id="toc_84">ViewSwitcher</h5>

<h5 id="toc_85">ImageSwitcher</h5>

<h5 id="toc_86">TextSwitcher</h5>

<h5 id="toc_87">AdapterViewFlipper</h5>

<h5 id="toc_88">ViewPager</h5>

<p>{% post_link android-viewpager Android-Viewpager详细学习 %}</p>

<h4 id="toc_89">Custom</h4>

<h5 id="toc_90">include</h5>

<h5 id="toc_91">fragment</h5>

<h5 id="toc_92">requestFocus</h5>

<h3 id="toc_93">Custom View</h3>

<h4 id="toc_94">extend system View</h4>

<h4 id="toc_95">combination View</h4>

<h4 id="toc_96">extend View</h4>

<p>{% post_link android-view Android-View详细学习 %}  </p>

<p>{% post_link android-draw Android自定义控件——绘图 %}  </p>

<h5 id="toc_97">ViewTreeObserver</h5>

<p>{% post_link android-getViewTreeObserver Android-getViewTreeObserver() %}</p>

<h5 id="toc_98">ColorFilter</h5>

<p>{% post_link android-colorfilter Android-ColorFilter详细学习 %}</p>

<h5 id="toc_99">Xfermode</h5>

<p>{% post_link android-xfermode Android-Xfermode详细学习 %}</p>

<h5 id="toc_100">Paint</h5>

<p>{% post_link android-paint Android-Paint详细学习 %}  </p>

<p>{% post_link android-paints Android-Paint详细学习 %}</p>

<h5 id="toc_101">Matrix</h5>

<p>{% post_link android-matrix Android-Matrix详细学习 %}  </p>

<h5 id="toc_102">Scroller</h5>

<p>{% post_link android-scroller Android-Scroller详细学习 %}</p>

<h5 id="toc_103">ViewConfiguration</h5>

<p>{% post_link android-viewconfiguration Android-ViewConfiguration解析 %}</p>

<h5 id="toc_104">MotionEvent</h5>

<p>{% post_link android-motionevent Android-MotionEvent解析 %}</p>

<h5 id="toc_105">VelocityTracker</h5>

<p>{% post_link android-velocitytracker Android-VelocityTracker详细学习 %}</p>

<h5 id="toc_106">SpannableString</h5>

<p>{% post_link android-spannablestring Android-SpannableString设置复合文本 %}</p>

<h3 id="toc_107">animation</h3>

<p>{% post_link android-animation Android动画详细学习 %}  </p>

<p>{% post_link android-activity-handoff-animation Android切换动画 %}</p>

<h4 id="toc_108">ViewAnimation</h4>

<h5 id="toc_109">TweenAnimation</h5>

<h5 id="toc_110">FrameAnimation</h5>

<h4 id="toc_111">PropertyAnimation</h4>

<h5 id="toc_112">ValueAnimator</h5>

<h5 id="toc_113">ObjectAnimator</h5>

<h5 id="toc_114">AnimatorSet</h5>

<h4 id="toc_115">VectorAnimation</h4>

<h5 id="toc_116">SVG</h5>

<h5 id="toc_117">VectorDrawable</h5>

<h5 id="toc_118">AnimatedVectorDrawable</h5>

<h3 id="toc_119">Resource</h3>

<h4 id="toc_120">assets</h4>

<h5 id="toc_121">AssetManager</h5>

<h4 id="toc_122">res</h4>

<h5 id="toc_123">anim</h5>

<h5 id="toc_124">animator</h5>

<h5 id="toc_125">color</h5>

<h5 id="toc_126">drawable</h5>

<h5 id="toc_127">interpolator</h5>

<h5 id="toc_128">layout</h5>

<h5 id="toc_129">menu</h5>

<h5 id="toc_130">raw</h5>

<h5 id="toc_131">values</h5>

<h6 id="toc_132">arrays</h6>

<h6 id="toc_133">attrs</h6>

<h6 id="toc_134">bools</h6>

<h6 id="toc_135">colors</h6>

<h6 id="toc_136">string</h6>

<h6 id="toc_137">styles</h6>

<h4 id="toc_138">OpenGL</h4>

<h4 id="toc_139">Bitmap</h4>

<h5 id="toc_140">BitmapFactory</h5>

<p>{% post_link android-bitmapfactory Android-BitmapFactory详细学习 %}</p>

<h2 id="toc_141">Material Design 系列</h2>

<h3 id="toc_142">Toolbar的使用</h3>

<p>{% post_link android-toolbar Android-ToolBar详细学习 %}</p>

<h3 id="toc_143">AppbarLayout+CollapsingToolbarLayout</h3>

<p>{% post_link android-appbarlayout-collapsingtoolbar-toolbar Android-AppBarLayout&amp;CollapsingToolbar&amp;Toolbar组合使用 %}  </p>

<p>{% post_link android-appbarlayout Android-AppBarLayout %}</p>

<h3 id="toc_144">Behavior 相关：</h3>

<ul>
<li>BottomSheetBehavior</li>
<li>BottomSheetDialog</li>
<li>SwipeDismissBehavior</li>
<li>自定义Behavior</li>
</ul>

<h3 id="toc_145">TextInputLayout + TextInputEditText</h3>

<h3 id="toc_146">TabLayout</h3>

<h3 id="toc_147">BottomNavigationView</h3>

<h3 id="toc_148">CardView 阴影卡片</h3>

<h3 id="toc_149">Snackbar , FloatActionButton</h3>

<h2 id="toc_150">通信</h2>

<h3 id="toc_151">Http</h3>

<h3 id="toc_152">Socket</h3>

<h3 id="toc_153">Bluetooth</h3>

<h3 id="toc_154">NFC</h3>

<h3 id="toc_155">Headset</h3>

<h3 id="toc_156">USB</h3>

<h2 id="toc_157">数据持久化</h2>

<h3 id="toc_158">Sqlite</h3>

<h4 id="toc_159">SQLiteOpenHelper</h4>

<h4 id="toc_160">ContentProvider</h4>

<h3 id="toc_161">File</h3>

<p>{% post_link android-save-method Android存储方式以及路径API %}</p>

<h4 id="toc_162">InternalStorage</h4>

<h4 id="toc_163">ExternalStorage</h4>

<h3 id="toc_164">SharedPreferences</h3>

<h2 id="toc_165">多线程</h2>

<p>{% post_link android-thread Android Thread %}  </p>

<h2 id="toc_166">性能</h2>

<p>{% post_link android-performance-optimize Android性能优化 %}</p>

<h3 id="toc_167">UI优化</h3>

<h4 id="toc_168">布局层次结构</h4>

<p>{% post_link android-view-performance-optimizing Android界面性能调优 %}</p>

<h4 id="toc_169">抽象布局使用</h4>

<h4 id="toc_170">HierarchyViewer</h4>

<h4 id="toc_171">Lint工具</h4>

<h3 id="toc_172">内存优化</h3>

<h4 id="toc_173">OOM</h4>

<h4 id="toc_174">ANR</h4>

<h4 id="toc_175">分析</h4>

<h5 id="toc_176">Heap</h5>

<h5 id="toc_177">adb shell</h5>

<p>{% post_link android-adb Android-ADB命令 %}</p>

<h6 id="toc_178">dumpsys meminfo</h6>

<h6 id="toc_179">showmap</h6>

<h5 id="toc_180">TraceView</h5>

<h5 id="toc_181">Dalvik日志</h5>

<h5 id="toc_182">logcat</h5>

<h5 id="toc_183">MAT</h5>

<h3 id="toc_184">电量优化</h3>

<h3 id="toc_185">流量优化</h3>

<h2 id="toc_186">调试(Debug)</h2>

<p>{% post_link android-debug Android-Debug %}</p>

<h3 id="toc_187">Logcat</h3>

<h3 id="toc_188">adb</h3>

<h3 id="toc_189">HierarchyViewer</h3>

<h3 id="toc_190">TraceView</h3>

<h3 id="toc_191">Heap</h3>

<h3 id="toc_192">Lint</h3>

<h2 id="toc_193">适配</h2>

<h3 id="toc_194">OS Version</h3>

<h4 id="toc_195">min SDK</h4>

<h3 id="toc_196">UI界面适配</h3>

<p>{% post_link android-ui-adapt Android界面适配 %}</p>

<p>{% post_link android-screen-adapt Android屏幕适配 %}</p>

<h4 id="toc_197">drawable</h4>

<h2 id="toc_198">测试</h2>

<h3 id="toc_199">Monkey</h3>

<h3 id="toc_200">MonkeyRunner</h3>

<h3 id="toc_201">JUnit</h3>

<h3 id="toc_202">Robotium</h3>

<h3 id="toc_203">Appium</h3>

<h3 id="toc_204">Athrun(TMTS)</h3>

<h3 id="toc_205">UIAutomator</h3>

<h2 id="toc_206">安全</h2>

<h3 id="toc_207">服务器安全</h3>

<h3 id="toc_208">通信安全</h3>

<h4 id="toc_209">与服务器通信</h4>

<h4 id="toc_210">组件间通信</h4>

<h3 id="toc_211">反编译</h3>

<p>{% post_link android-decompile Android反编译 %}  </p>

<p>{% post_link android-get-sha1 Android-获取sha1 %}  </p>

<p>{% post_link android-smali Android-smali文件格式 %}</p>

<h3 id="toc_212">数据加密</h3>

<h3 id="toc_213">数据验签</h3>

<h3 id="toc_214">代码混淆</h3>

<h3 id="toc_215">WebView/JS安全调用</h3>

<h3 id="toc_216">MD5、DES、RSA、https、证书、权限</h3>

<h2 id="toc_217">NDK</h2>

<p>{% post_link android-ndk Android-NDK %}</p>

<h3 id="toc_218">JNI</h3>

<h3 id="toc_219">C语言</h3>

<h3 id="toc_220">C++</h3>

<h2 id="toc_221">Android 多媒体</h2>

<h3 id="toc_222">相机开发</h3>

<h4 id="toc_223">使用自带的相机APP拍照</h4>

<h4 id="toc_224">系统相册选择照片</h4>

<h4 id="toc_225">系统相机或相册获取的照片裁剪</h4>

<h4 id="toc_226">使用相机API 开发相机:</h4>

<ul>
<li>Android 5.0 （API 21 ）以下 使用Camera API </li>
<li>Android 5.0 以上使用 Camera2 API </li>
</ul>

<h4 id="toc_227">自定义相册开发</h4>

<h4 id="toc_228">自定义裁剪界面</h4>

<h3 id="toc_229">视频开发</h3>

<h4 id="toc_230">视频播放</h4>

<ul>
<li>MediaPlayer</li>
<li>VideoView</li>
</ul>

<h4 id="toc_231">视频编解码</h4>

<h3 id="toc_232">音频开发</h3>

<h4 id="toc_233">AudioPlayer</h4>

<h4 id="toc_234">音乐播放器</h4>

<h2 id="toc_235">Android权限配置</h2>

<h2 id="toc_236">Gradle</h2>

<h3 id="toc_237">自定义Gradle插件</h3>

<h3 id="toc_238">Gradle多渠道打包</h3>

<h2 id="toc_239">手机功能</h2>

<h3 id="toc_240">电话</h3>

<h4 id="toc_241">联系人</h4>

<h4 id="toc_242">通话记录</h4>

<h3 id="toc_243">短/彩信</h3>

<h3 id="toc_244">Audio</h3>

<h3 id="toc_245">SD卡</h3>

<h3 id="toc_246">感应器</h3>

<h4 id="toc_247">加速</h4>

<h4 id="toc_248">方向</h4>

<h4 id="toc_249">重力</h4>

<h4 id="toc_250">光线</h4>

<h4 id="toc_251">陀螺仪</h4>

<h4 id="toc_252">磁场</h4>

<h4 id="toc_253">接近</h4>

<h4 id="toc_254">温度</h4>

<h4 id="toc_255">压力</h4>

<h4 id="toc_256">线性加速度</h4>

<h4 id="toc_257">旋转</h4>

<h2 id="toc_258">第三方扩展</h2>

<h3 id="toc_259">地图</h3>

<h3 id="toc_260">语音识别</h3>

<h3 id="toc_261">支付</h3>

<h3 id="toc_262">统计分析</h3>

<h3 id="toc_263">广告</h3>

<h2 id="toc_264">其他</h2>

<h3 id="toc_265">Intent</h3>

<h3 id="toc_266">AndroidManifest</h3>

<h3 id="toc_267">AIDL</h3>

<h3 id="toc_268">Wifi</h3>

<p>{% post_link android-wifi Android-WiFi %}</p>

<h3 id="toc_269">国际化</h3>

<h3 id="toc_270">响应式编程</h3>

<p>{% post_link android-permissions Android权限机制 %}</p>

<h3 id="toc_271">其他</h3>

<p>{% post_link android-responsive-code Android响应式编程 %}  </p>

<p>{% post_link android-mvp Android MVP模式 %}  </p>

<p>{% post_link android-cold-launch Android冷启动实现APP秒开 %}  </p>

<p>{% post_link android-studio-bitbucket AndroidStudio关联Bitbucket %}  </p>

<p>{% post_link android-issues Android-Issues %}  </p>

<p>{% post_link android-base-class Android-基类实现 %}  </p>

<p>{% post_link android-modularization Android组件化学习%}</p>

<h2 id="toc_272">Library</h2>

<p>{% post_link android-library Android-开发中常用的支持库 %}  </p>

<p>{% post_link android-efficient-tools Android高效开发工具库 %}  </p>

<p>{% post_link android-quick-develop-frame Android快速开发框架 %}  </p>

<p>{% post_link android-picasso Android-Picasso图片框架 %}  </p>

<p>{% post_link android-greendao Android-GreenDao3.2.0的使用 %}  </p>

<p>{% post_link android-eventbus Android-EventBus3.0的使用 %}  </p>

<p>{% post_link android-common-android-library Android-常用的库 %}  </p>

<p>{% post_link android-fresco Android-Fresco详细学习 %}  </p>

<p>{% post_link android-rxjava Android-RxJava详细学习 %}  </p>

<p>{% post_link android-gson Android-Gson详细学习 %}  </p>

<p>{% post_link android-retrofit Android-Retrofit详细学习 %}  </p>

<p>{% post_link android-databinding Android-DataBinding详细学习 %}</p>

<h2 id="toc_273">实现</h2>

<p>{% post_link android-custom-lock-screen Android自定义锁屏页 %}  </p>

<p>{% post_link android-custom-skin Android自定义皮肤 %}</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870849.html">
                
                  <h1>Android-酷炫的Activity切换动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码：</p>

<pre class="line-numbers"><code class="language-java">Intent intent=new Intent(this,SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
</code></pre>

<p>在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊：</p>

<p><figure><img src="media/15561207870849/20171015150799839139489.gif" alt=""/></figure></p>

<p>先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。</p>

<h2 id="toc_1">使用内置Activity之间切换动画代码步骤</h2>

<p>Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示：</p>

<blockquote>
<p><strong>enter</strong>：用于决定第一次打开当前Activity时的动画<br/><br/>
<strong>exit</strong> : 用于决定退出当前Activity时的动画<br/><br/>
<strong>reenter</strong>: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画<br/><br/>
<strong>shared elements</strong>:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果  </p>
</blockquote>

<p>那么应该怎么去使用Activity切换动画呢？我们看看使用步骤：</p>

<ul>
<li>首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画<br/>
<code>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</code></li>
<li>接下来就是加载切换动画<br/>
其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。<br/>
<code>Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode);</code></li>
<li>告诉Window，当前的Activity在什么情况下使用上面的动画<br/>
上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果:<br/></li>
</ul>

<pre class="line-numbers"><code class="language-java">//退出时使用
getWindow().setExitTransition(explode);
//第一次进入时使用
getWindow().setEnterTransition(explode);
//再次进入时使用
getWindow().setReenterTransition(explode);
</code></pre>

<p>当然了，你也可以不使用代码的方式，直接在你使用的主题<style>标签里添加类似如下代码：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt;
</code></pre>

<ul>
<li>调用startActivity<br/>
跟我们之前使用的<code>startActivity(Intent intent);</code>不同，这里多了一个参数<code>Bundle</code>，我们是先通过<code>makeSceneTransitionAnimation</code>函数创建一个<code>ActivityOptions</code>对象，再将其转为<code>Bundle</code>对象:<br/>
<code>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());</code><br/>
整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~</li>
</ul>

<h2 id="toc_2">Explode效果</h2>

<p>Explode即爆炸效果，使用Explode效果很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>explode.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>其中<code>duration</code>表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。<br/>
我们看看效果吧~</p>

<p><figure><img src="media/15561207870849/20171015150799868975358.gif" alt=""/></figure></p>

<h2 id="toc_3">Slide效果</h2>

<p>即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如<code>slide.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;/&gt;
</code></pre>

<p>其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧</p>

<p><figure><img src="media/15561207870849/20171015150799873587032.gif" alt=""/></figure></p>

<p>GIF 效果看的比较死板，可以下载我的源码实际运行一下~</p>

<p>如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定：</p>

<pre class="line-numbers"><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;&gt;
    &lt;targets&gt;
        &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot; /&gt;
        &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot; /&gt;
    &lt;/targets&gt;
&lt;/slide&gt;
</code></pre>

<h2 id="toc_4">Fade效果</h2>

<p>Fade效果即淡化效果，使用淡化效果依然是很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>fade.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~</p>

<h2 id="toc_5">Shared Element效果</h2>

<p>即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下：</p>

<p><figure><img src="media/15561207870849/20171015150799880319943.gif" alt=""/></figure></p>

<p>从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~</p>

<p>接下来我们看看如何实现这个效果：</p>

<p><strong>1.将两个Activity中需要过渡的View加上<code>android:transitionName</code>属性</strong></p>

<p>两个View的<code>android:transitionName</code>属性取值要一致，比如：<br/><br/>
第一个Activity布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:id=&quot;@+id/firstSharedView&quot;
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>第二个Activity布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;300dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>两个绿色的View都添加<code>android:transitionName</code>属性，并且取名一致。</p>

<p><strong>2.调用startActivity</strong><br/><br/>
<code>ActivityOptions</code>的<code>makeSceneTransitionAnimation</code>函数第一个参数<code>Activity</code>没啥解释的，第二个参数就是第一个<code>Activity</code>中的<code>View</code>对象，第三个参数就是两个Activity的View的 <code>android:transitionName</code>属性的值。</p>

<p><code>startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView,&quot;sharedView&quot;).toBundle());</code></p>

<p>现在就可以实现这种<code>Shared Element</code>效果啦，但是可能你会想实现同时让两个View有这样的效果，可是<code>makeSceneTransitionAnimation</code>函数却只能让我们设置一个<code>View</code>和一个<code>transitionName</code>属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。</p>

<p>除了需要将两个<code>Activity</code>中需要过渡的<code>View</code>对应取相同的名称外，还需将需要过渡的<code>View</code>和<code>transitionName</code>取值对应的String这两个对象封装到一个Pair对象中：</p>

<pre class="line-numbers"><code class="language-java">Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));
Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));
</code></pre>

<p>然后调用<code>ActivityOptionsCompat</code>类的<code>makeSceneTransitionAnimation</code>的另一个重载函数<code>makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements)</code>，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。</p>

<pre class="line-numbers"><code class="language-java"> ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second);
</code></pre>

<p>最后调用startActivity</p>

<pre class="line-numbers"><code class="language-java"> ActivityCompat.startActivity(this,intent, transitionActivityOptions.toBundle());
</code></pre>

<p>说了这么多步骤，我们来看看效果吧~</p>

<p><figure><img src="media/15561207870849/20171015150799903533027.gif" alt=""/></figure></p>

<h3 id="toc_6">1 自定义 Shared Element切换动画</h3>

<p>如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下：</p>

<h4 id="toc_7">创建一个View的过渡移动的轨迹路径PathMotion类</h4>

<p>我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看<a href="https://developer.android.com/reference/android/transition/ArcMotion.html">【ArcMotion官方文档】</a></p>

<pre class="line-numbers"><code class="language-java">ArcMotion arcMotion = new ArcMotion();
arcMotion.setMinimumHorizontalAngle(50f);
arcMotion.setMinimumVerticalAngle(50f);
</code></pre>

<h4 id="toc_8">定义ChangeBounds类</h4>

<p>我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数：</p>

<blockquote>
<p>1.<code>ViewGroup  sceneRoot</code>：屏幕根View，即DecorView，第二个Activity的DecorView。<br/>
2.<code>TransitionValues  startValues</code>：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数<code>captureStartValues</code>里放置，因此你可以重写<code>captureStartValues</code>函数，并把你自定义的属性动画中的属性放进去。<br/>
3.<code>TransitionValues endValues</code> ：与<code>startValues</code>类似，表示属性动画结束时的属性值。可以通过重写<code>captureEndValues</code>函数，并把你自定义的属性动画里面的最终属性值放进去。</p>
</blockquote>

<p>我们先看一个最简单的示例：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.util;

import android.animation.Animator;
import android.transition.ChangeBounds;
import android.transition.TransitionValues;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;


public class CustomChangeBounds extends ChangeBounds {

 @Override
  public Animator createAnimator(final ViewGroup sceneRoot,
                                 TransitionValues startValues,
                                 final TransitionValues endValues) {
      Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues);
      if (startValues == null || endValues == null || changeBounds == null) 
          return null;

      changeBounds.setDuration(300);
      changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(),
              android.R.interpolator.fast_out_slow_in));
      return changeBounds;
  }
}
</code></pre>

<p>看看效果吧~</p>

<p><figure><img src="media/15561207870849/20171015150799918618986.gif" alt=""/></figure></p>

<p>最后，再献上<a href="http://download.csdn.net/detail/huachao1001/9550440">源码</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870815.html">
                
                  <h1>Android-smali文件格式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">HelloWorld</h2>

<p>首先写一个 HelloWorld 类：</p>

<pre class="line-numbers"><code class="language-java">package jiuyou.hello.info;

public class HelloWorld {
    public static void main(String[] args){
        System.out.println(&quot;hello world&quot;);
    }
}
</code></pre>

<p>然后生成 apk 再用 apktool 工具转成 smali 文件：</p>

<pre class="line-numbers"><code class="language-text">.class public Ljiuyou/hello/info/HelloWorld;    #定义类名
.super Ljava/lang/Object;                       #定义父类
.source &quot;HelloWorld.java&quot;                       #源文件名

# direct methods      #直接方法  （# virtual methods 为虚方法）
.method public constructor &lt;init&gt;()V      #构造函数
    .locals 0     #方法中使用到的局部变量个数

    .prologue     #代码起始指令
    .line 8       #源代码所在行数
    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V         #调用父类构造方法

    return-void     #返回空
.end method         #方法结束

.method public static main([Ljava/lang/String;)V      #对应 main 方法
    .locals 2       #方法包含两个局部 v0,v1
    .param p0, &quot;args&quot;    # [Ljava/lang/String;   # main 方法的参数 agrs 标记为 p0

    .prologue       #代码起始指令
    .line 10
    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;  #将 System.out 这个静态变量赋给 v0

    const-string v1, &quot;hello world&quot;    #构造字符串

    #方法调用（调用 v0 的方法 println ，v1 是参数）
    invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V    

    .line 11
    return-void
.end method
</code></pre>

<h2 id="toc_1">字段</h2>

<p>静态字段格式如下：</p>

<pre class="line-numbers"><code class="language-text"># static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>实例字段格式如下：</p>

<pre class="line-numbers"><code class="language-text"># instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>举个栗子</p>

<p><strong>java</strong> ：</p>

<pre class="line-numbers"><code class="language-java">private String name;

private final String sex=&quot;男&quot;;

public static int age;
</code></pre>

<p><strong>smali</strong> :</p>

<pre class="line-numbers"><code class="language-text"># static fields
.field public static age:I

# instance fields
.field private name:Ljava/lang/String;

.field private final sex:Ljava/lang/String;
</code></pre>

<h2 id="toc_2">方法</h2>

<p>方法有直接方法和虚方法两种，两者格式基本相同：</p>

<pre class="line-numbers"><code class="language-text"># direct methods  (virtual methods)
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
    &lt;.locals&gt;
    [.parameter] or [.param]
    [.prologue]
    [.line]
    &lt;代码体&gt;
.end method
</code></pre>

<p><strong>.locals</strong>：局部变量个数<br/><br/>
<strong>.parameter or .param</strong>：指定每个参数<br/><br/>
<strong>.prologue</strong>：代码的开始处，混淆过的代码可能没有该指令<br/><br/>
<strong>.line</strong>：指定了该处指令在源代码中的行号，混淆过的代码可能没有该指令</p>

<p>举个栗子：<br/><br/>
<strong>java</strong></p>

<pre class="line-numbers"><code class="language-java">public String test(int a){
    int b=a+10;
    return &quot;test&quot;;
}
</code></pre>

<p><strong>smali</strong></p>

<pre class="line-numbers"><code class="language-text"># virtual methods
.method public test(I)Ljava/lang/String;
    .locals 2
    .param p1, &quot;a&quot;    # I

    .prologue
    .line 11
    add-int/lit8 v0, p1, 0xa

    .line 12
    .local v0, &quot;b&quot;:I
    const-string v1, &quot;test&quot;

    return-object v1
.end method
</code></pre>

<h2 id="toc_3">接口</h2>

<p>interface 格式如下：</p>

<pre class="line-numbers"><code class="language-text"># interfaces
.implements &lt;接口名&gt;
</code></pre>

<p>举个例子：<br/><br/>
<strong>java</strong></p>

<pre class="line-numbers"><code class="language-java">public interface If {
    int demo(String s);
}

public class InterfaceTest implements If {
    @Override
    public int demo(String s) {
        return 0;
    }
}
</code></pre>

<p><strong>smali</strong> ：</p>

<p>If.smali</p>

<pre class="line-numbers"><code class="language-text"># virtual methods
.method public abstract demo(Ljava/lang/String;)I
.end method
</code></pre>

<p>InterfaceTest.smali</p>

<pre class="line-numbers"><code class="language-text"># interfaces
.implements Ljiuyou/hello/info/If;

# virtual methods
.method public demo(Ljava/lang/String;)I
    .locals 1
    .param p1, &quot;s&quot;    # Ljava/lang/String;

    .prologue
    .line 11
    const/4 v0, 0x0

    return v0
.end method
</code></pre>

<h2 id="toc_4">注解</h2>

<p>格式如下：</p>

<pre class="line-numbers"><code class="language-text">.annotation [注解属性] &lt;注解类名&gt;
    [注解字段 = 值]
.end annotation
</code></pre>

<p>如果注解的作用范围是类， <strong>.annotation</strong> 指令会直接定义在 smali 文件中，如果作用范围是方法或者字段，则会包含在方法或字段定义中。  </p>

<p>举个栗子：<br/><br/>
<strong>java</strong>  </p>

<pre class="line-numbers"><code class="language-java">@Deprecated
public class AnnotationTest {
    @At(value = &quot;tom&quot;)
    public String name;
}
</code></pre>

<p><strong>smali</strong></p>

<pre class="line-numbers"><code class="language-text"># annotations
.annotation runtime Ljava/lang/Deprecated;
.end annotation


# instance fields
.field public name:Ljava/lang/String;
    .annotation runtime Ljiuyou/hello/info/At;
        value = &quot;tom&quot;
    .end annotation
.end field
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870778.html">
                
                  <h1>Android-NDK图片高斯模糊</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CMake</h2>

<p>CMake是一款项目构建工具，通过编写简单明了的在CmakeLists.txt来生成makefile，简单来说就是一个makefile生成器。</p>

<p>在Android Studio中安装CMake非常简单，打开Tools-&gt;Android-&gt;SDK Manager，选择SDK Tools标签页，勾选CMake、LLDB、NDK，OK自动安装即可。其中LLDB可以使我们在Android Studio中调试C/C++程序。NDK为原生开发工具包，必不可少。</p>

<p><figure><img src="media/15561207870778/15713317710825.png" alt=""/></figure></p>

<h2 id="toc_1">为什么要做JNI/NDK开发</h2>

<p>众所周知，Java/Android程序是运行在JVM/Dalvik VM中，所以Java程序远没有C/C++程序性能高，尤其是在CPU密集型运算时，所以Java平台提供了JNI（Java Native Interface），可通过JNI调用C/C++等编写的so动态链接库。</p>

<p><strong>注：Google在Android L以后用ART彻底代替了Dalvik VM，但ART本质上仍是一个虚拟机，并支持所有Dalvik VM指令集。</strong></p>

<p>Java API中几乎所有与硬件相关的方法都是native的，比如I/O操作、网络访问、手机传感器、串口读写等。<br/><br/>
本文涉及的图片处理是一种CPU密集型任务，在Android开发中使用native方法最为合适。</p>

<h2 id="toc_2">如何使用CMake做JNI/NDK开发</h2>

<h3 id="toc_3">新建工程</h3>

<p>选中Include C++ Support，意为引入C++支持。</p>

<h3 id="toc_4">配置C++支持</h3>

<p><figure><img src="media/15561207870778/15713317834823.png" alt=""/></figure></p>

<p>在Customize C++ Support界面默认即可,意为CMake/C++11环境</p>

<h3 id="toc_5">认识CMakeLists.txt</h3>

<p>工程创建完毕之后Android Studio会在app目录下生成CMakeLists.txt文件。CMakeLists.txt是CMake的配置文件，用于表明版本、依赖、等信息，以下为Android Studio生成的CMakeLists（过滤注释）</p>

<pre class="line-numbers"><code class="language-text">cmake_minimum_required(VERSION 3.4.1)

add_library(native-lib SHARED src/main/cpp/native-lib.cpp)

find_library(log-lib log)

target_link_libraries(native-lib ${log-lib})
</code></pre>

<ul>
<li>cmake_minimum_required(VERSION 3.4.1)<br/>
CMake最小版本使用的是3.4.1。</li>
<li>add_library()<br/>
配置so库信息（为当前当前脚本文件添加库）
<ul>
<li>native-lib<br/>
这个是声明引用so库的名称，在项目中，如果需要使用这个so文件，引用的名称就是这个。值得注意的是，实际上生成的so文件名称是libnative-lib。</li>
<li>SHARED<br/>
这个参数表示共享so库文件，也就是在Run项目或者build项目时会在目录intermediates\transforms\mergeJniLibs\debug\folders\2000\1f\main下生成so文件。</li>
<li>src/main/cpp/native-lib.cpp<br/>
构建so库的源文件。</li>
</ul></li>
<li>find_library()查找一个库文件
<ul>
<li>log-lib<br/>
这个指定的是在NDK库中每个类型的库会存放一个特定的位置，而log库存放在log-lib中</li>
<li>log<br/>
指定使用log库</li>
</ul></li>
<li>target_link_libraries()<br/>
如果你本地的库（native-lib）想要调用log库的方法，那么就需要配置这个属性，意思是把NDK库关联到本地库。
<ul>
<li>native-lib<br/>
要被关联的库名称</li>
<li>\({log-lib}  <br/>
要关联的库名称，要用大括号包裹，前面还要有\)符号去引用。</li>
</ul></li>
</ul>

<h3 id="toc_6">了解JNI的C/C++规范</h3>

<h4 id="toc_7">数据类型</h4>

<p>JNI的数据类型包含两种，分别是基本类型和引用类型，它们和Java中的数据类型对应关系如下两表所示。</p>

<h5 id="toc_8">基本数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jboolean</td>
<td style="text-align: center">boolean</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jbyte</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jchar</td>
<td style="text-align: center">char</td>
<td style="text-align: center">无符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jshort</td>
<td style="text-align: center">short</td>
<td style="text-align: center">有符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jint</td>
<td style="text-align: center">int</td>
<td style="text-align: center">32位整型</td>
</tr>
<tr>
<td style="text-align: left">jlong</td>
<td style="text-align: center">long</td>
<td style="text-align: center">64位整型</td>
</tr>
<tr>
<td style="text-align: left">jfloat</td>
<td style="text-align: center">float</td>
<td style="text-align: center">32位浮点型</td>
</tr>
<tr>
<td style="text-align: left">jdouble</td>
<td style="text-align: center">double</td>
<td style="text-align: center">64位浮点型</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: center">void</td>
<td style="text-align: center">无类型</td>
</tr>
</tbody>
</table>

<h5 id="toc_9">引用数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jobject</td>
<td style="text-align: center">Object</td>
<td style="text-align: center">Object类型</td>
</tr>
<tr>
<td style="text-align: left">jclass</td>
<td style="text-align: center">Class</td>
<td style="text-align: center">Class类型</td>
</tr>
<tr>
<td style="text-align: left">jstring</td>
<td style="text-align: center">String</td>
<td style="text-align: center">String类型</td>
</tr>
<tr>
<td style="text-align: left">jobjectArray</td>
<td style="text-align: center">Object[]</td>
<td style="text-align: center">对象数组</td>
</tr>
<tr>
<td style="text-align: left">jbooleanArray</td>
<td style="text-align: center">boolean[]</td>
<td style="text-align: center">boolean数组</td>
</tr>
<tr>
<td style="text-align: left">jbyteArray</td>
<td style="text-align: center">byte[]</td>
<td style="text-align: center">byte数组</td>
</tr>
<tr>
<td style="text-align: left">jcharArray</td>
<td style="text-align: center">char[]</td>
<td style="text-align: center">char数组</td>
</tr>
<tr>
<td style="text-align: left">jshortArray</td>
<td style="text-align: center">short[]</td>
<td style="text-align: center">short数组</td>
</tr>
<tr>
<td style="text-align: left">jintArray</td>
<td style="text-align: center">int[]</td>
<td style="text-align: center">int数组</td>
</tr>
<tr>
<td style="text-align: left">jlongArray</td>
<td style="text-align: center">long[]</td>
<td style="text-align: center">long数组</td>
</tr>
<tr>
<td style="text-align: left">jfloatArray</td>
<td style="text-align: center">float[]</td>
<td style="text-align: center">float数组</td>
</tr>
<tr>
<td style="text-align: left">jdoubleArray</td>
<td style="text-align: center">double[]</td>
<td style="text-align: center">double数组</td>
</tr>
<tr>
<td style="text-align: left">jthrowable</td>
<td style="text-align: center">Throwable</td>
<td style="text-align: center">Throwable</td>
</tr>
</tbody>
</table>

<h4 id="toc_10">JNI的类型签名</h4>

<p>JNI的类型签名标识了一个特定的Java类型，这个类型既可以是类也可以是方法，也可以是数据类型。</p>

<ul>
<li>类的签名比较简单，它采用 L+包名+类型+; 的形式，只需要将其中的.替换为/即可。例如java.lang.String， 它的签名为Ljava/lang/String; ，注意末尾的;也是签名一部分。<br/></li>
<li>基本数据类型的签名采用一系列大写字母来表示, 如下表所示</li>
</ul>

<h5 id="toc_11">基本数据类型的签名</h5>

<table>
<thead>
<tr>
<th style="text-align: left">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">boolean</td>
<td style="text-align: center">Z</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">B</td>
<td style="text-align: center">char</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: left">short</td>
<td style="text-align: center">S</td>
<td style="text-align: center">int</td>
<td style="text-align: center">I</td>
<td style="text-align: center">long</td>
<td style="text-align: center">J</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: center">F</td>
<td style="text-align: center">double</td>
<td style="text-align: center">D</td>
<td style="text-align: center">void</td>
<td style="text-align: center">V</td>
</tr>
</tbody>
</table>

<h4 id="toc_12">JNI C/C++函数编写</h4>

<p>先来看看Android Studio为我们生成的示例</p>

<pre class="line-numbers"><code class="language-java">JNIEXPORT jstring JNICALL
Java_com_glee_myapplication_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = &quot;Hello from C++&quot;;
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<ul>
<li>JNIEXPORT &amp; JNICALL<br/>
JNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且编译器会进行正确的调用转换。</li>
<li>函数规范<br/>
在JNI中C/C++的函数名是有规范要求的，由以下几部分串接而成
<ul>
<li>Java_前缀</li>
<li>完全限定的类名，并用下划线“_”作为分隔符</li>
<li>第一参数JNIEnv* env</li>
<li>第二个参数jobject或jclass</li>
<li>其他参数按类型映射</li>
<li>返回参数按类型映射</li>
</ul></li>
</ul>

<h2 id="toc_13">JNI层操作Bitmap对象</h2>

<h3 id="toc_14">原理</h3>

<p>Android中JNI层处理Bitmap通常有两种方法</p>

<ul>
<li>获取到Bitmap中的byte数组并传入native方法，JNI层处理得到的byte数组后返回一个新的byte数组，Java层重建Bitmap对象。（不推荐）</li>
<li>Java层直接向JNI层传入Bitmap的引用，JNI层得到Bitmap对象的图像数据的地址，直接修改Bitmap的byte数组。</li>
</ul>

<p>阅读了很多篇博客，很多开发者都会采用第一种方法，本人是极不推荐的。这种方法会在内存中重建一个byte数组，会造成内存的浪费，性能低下。<br/><br/>
第二种方法是性能最优的，JNI层充分利用的C/C++指针的特性，直接获取到Bitmap中byte数组在内存中的地址，通过指针直接修改图像数据，所以用到了NDK中的android/bitmap.h。  </p>

<p><strong>android/bitmap.h</strong></p>

<p>android/bitmap.h这个头文件用于在JNI层操作Bitmap对象的，其包含于jnigraphics库中，所以要在CMakeLists.txt中的target_link_libraries加入-ljnigraphics，如下</p>

<p><code>target_link_libraries(native-lib -ljnigraphics ${log-lib})</code></p>

<p><strong>三个常用函数</strong></p>

<ul>
<li>AndroidBitmap_getInfo() 从位图句柄获得信息（宽度、高度、像素格式）</li>
<li>AndroidBitmap_lockPixels() 对像素缓存上锁，即获得该缓存的指针。</li>
<li>AndroidBitmap_unlockPixels() 解锁</li>
</ul>

<h3 id="toc_15">JNI接口函数</h3>

<p>请看注释</p>

<pre class="line-numbers"><code class="language-java">JNIEXPORT void JNICALL
Java_com_glee_ndkroad1006_MainActivity_gaussBlur(JNIEnv *env, jobject /* this */, jobject bmp) {
    AndroidBitmapInfo info = {0};//初始化BitmapInfo结构体
    int *data=NULL;//初始化Bitmap图像数据指针
    AndroidBitmap_getInfo(env, bmp, &amp;info);
    AndroidBitmap_lockPixels(env, bmp, (void **) &amp;data);//锁定Bitmap，并且获得指针
    /**********高斯模糊算法作对int数组进行处理***********/
    //调用gaussBlur函数，把图像数据指针、图片长宽和模糊半径传入
    gaussBlur(data,info.width,info.height,80);
    /****************************************************/
    AndroidBitmap_unlockPixels(env,bmp);//解锁
}
</code></pre>

<p>这里用到的gaussBlur函数代码将在文章最后列出。</p>

<h3 id="toc_16">Java层代码</h3>

<p>请看注释</p>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {

    static {
        //通过静态代码块加载so库
        System.loadLibrary(&quot;native-lib&quot;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //初始化两个ImageView
        ImageView iv1 = (ImageView) findViewById(R.id.img1);
        ImageView iv2 = (ImageView) findViewById(R.id.img2);
        //iv1设置图片
        iv1.setImageResource(R.drawable.test);
        //生成bitmap对象
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);
        //调用native方法，传入Bitmap对象，对Bitmap进行高斯迷糊处理
        gaussBlur(bitmap);
        //把Bitmap对象设置给iv2
        iv2.setImageBitmap(bitmap);
    }
    //native方法声明
    public native void gaussBlur(Bitmap bitmap);
}
</code></pre>

<h3 id="toc_17">运行效果</h3>

<p>上方的ImageView是没有进行高斯模糊处理的，下方的ImageView调用了JNI方法进行高斯模糊处理。</p>

<p><figure><img src="media/15561207870778/15713317952653.png" alt=""/></figure></p>

<h3 id="toc_18">高斯模糊算法</h3>

<pre class="line-numbers"><code class="language-c">void gaussBlur1(int* pix, int w, int h, int radius)
{
    float sigma = (float) (1.0 * radius / 2.57);
    float deno  = (float) (1.0 / (sigma * sqrt(2.0 * PI)));
    float nume  = (float) (-1.0 / (2.0 * sigma * sigma));
    float* gaussMatrix = (float*)malloc(sizeof(float)* (radius + radius + 1));
    float gaussSum = 0.0;
    for (int i = 0, x = -radius; x &lt;= radius; ++x, ++i)
    {
        float g = (float) (deno * exp(1.0 * nume * x * x));
        gaussMatrix[i] = g;
        gaussSum += g;
    }
    int len = radius + radius + 1;
    for (int i = 0; i &lt; len; ++i)
        gaussMatrix[i] /= gaussSum;
    int* rowData  = (int*)malloc(w * sizeof(int));
    int* listData = (int*)malloc(h * sizeof(int));
    for (int y = 0; y &lt; h; ++y)
    {
        memcpy(rowData, pix + y * w, sizeof(int) * w);
        for (int x = 0; x &lt; w; ++x)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int i = -radius; i &lt;= radius; ++i)
            {
                int k = x + i;
                if (0 &lt;= k &amp;&amp; k &lt;= w)
                {
                    //得到像素点的rgb值
                    int color = rowData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[i + radius];
                    g += cg * gaussMatrix[i + radius];
                    b += cb * gaussMatrix[i + radius];
                    gaussSum += gaussMatrix[i + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    for (int x = 0; x &lt; w; ++x)
    {
        for (int y = 0; y &lt; h; ++y)
            listData[y] = pix[y * w + x];
        for (int y = 0; y &lt; h; ++y)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int j = -radius; j &lt;= radius; ++j)
            {
                int k = y + j;
                if (0 &lt;= k &amp;&amp; k &lt;= h)
                {
                    int color = listData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[j + radius];
                    g += cg * gaussMatrix[j + radius];
                    b += cb * gaussMatrix[j + radius];
                    gaussSum += gaussMatrix[j + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    free(gaussMatrix);
    free(rowData);
    free(listData);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870745.html">
                
                  <h1>Android-CoordinatorLayout详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>曾在网上找了一些关于<code>CoordinatorLayout</code>的教程，大部分文章都是把<code>CoordinatorLayout</code>、<code>AppbarLayout</code>、<code>CollapsingToolbarLayout</code> 以及<code>Toolbar</code>等一起使用来介绍，这让我不知不觉在心中认为把这几个布局要一起使用，而且只是用于那种场景中。其实<code>CoordinatorLayout</code>的功能并不是局限于与<code>AppBarLayout</code>一起使用，它的功能强大着呢，本文主要对<code>CoordinatorLayout</code>的使用进行介绍，后面再写一篇文章将<code>AppBarLayout</code>和<code>CollapsingToolBarLayout</code>整合<code>CoordinatorLayout</code>一起。那么到底<code>CoordinatorLayout</code>有多好用，请往下感受吧~</p>

<h2 id="toc_0">CoordinatorLayout能做什么</h2>

<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子View的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子View的布局。我们先看一组动画图~</p>

<p><figure><img src="media/15561207870745/20171014150799569357936.gif" alt=""/></figure></p>

<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色Button查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。</p>

<p>这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个View的引用，然后在onTouchEvent里面做各种判断。如果我们想要实现的功能是，有更多的View要根据蓝色的View的移动相应作出响应，那么那就得在蓝色View的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~</p>

<p>而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>

<h2 id="toc_1">CoordinatorLayout使用</h2>

<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子View的意思了，是谁的子View呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code>是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的<code>View</code>的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个View就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。</p>

<p>怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>

<pre class="line-numbers"><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>

<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>

<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>

<p>我们看看<code>Behavior</code>的使用：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }
}
</code></pre>

<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>

<p>附上<a href="http://download.csdn.net/detail/huachao1001/9537636">源码地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870710.html">
                
                  <h1>Android-AppBarLayout</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar</h2>

<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦~</p>

<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>

<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将<code>AppTheme</code>的<code>parent</code>设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。</p>

<p>接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>

<pre class="line-numbers"><code class="language-markup">  &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>

<p>最后将Toobar作为“ActionBar”来用</p>

<pre class="line-numbers"><code class="language-java"> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>

<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦，hongyang大神有篇博客写的挺好的<a href="http://blog.csdn.net/lmj623565791/article/details/45303349">《 Android 5.x Theme 与 ToolBar 实战 》</a>可以去参考一下。</p>

<p>如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>

<p>正如你所看的这样，Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>

<h2 id="toc_1">AppBarLayout</h2>

<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当<strong>某个可滚动View</strong>的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>

<p>请注意：上面提到的<strong>某个可滚动View</strong>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>

<h3 id="toc_2">AppBarLayout子View的动作</h3>

<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>

<blockquote>
<p>（1） scroll:值设为scroll的View会跟随滚动事件一起发生移动。</p>
</blockquote>

<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>

<p>一张gif足以说明：</p>

<p><figure><img src="media/15561207870710/20171014150799488071606.gif" alt=""/></figure></p>

<p>对应的布局文件</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<blockquote>
<p>（2） enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</p>
</blockquote>

<p>看个动画片（Y(<sup>o<sup>)Y）（ToolBar高度设为：<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code>）：</sup></sup></p>

<p><figure><img src="media/15561207870710/20171014150799493830006.gif" alt=""/></figure></p>

<blockquote>
<p>（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</p>
</blockquote>

<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code>）：</p>

<p><figure><img src="media/15561207870710/20171014150799499853731.gif" alt=""/></figure></p>

<blockquote>
<p>（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。<br/>
来个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code>）：</p>
</blockquote>

<p><figure><img src="media/15561207870710/20171014150799505696205.gif" alt=""/></figure></p>

<h3 id="toc_3">将AppBarLayout与ScrollView关联起来</h3>

<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，这不就是我们上一篇<a href="http://blog.csdn.net/huachao1001/article/details/51554608">《CoordinateLayout的使用如此简单 》</a>所学的内容吗？把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>

<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>

<pre class="line-numbers"><code class="language-markup"> &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

&lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>

<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。</p>

<p>好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>

<h2 id="toc_4">CollapsingToolbarLayout</h2>

<p>CollapsingToolbarLayout是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在AppBarLayout布局里面，并且作为AppBarLayout的直接子View。CollapsingToolbarLayout主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>

<blockquote>
<p>(1) 折叠Title（Collapsing title）：当布局内容全部显示出来时，title是最大的，但是随着View逐步移出屏幕顶部，title变得越来越小。你可以通过调用<code>setTitle</code>函数来设置title。  </p>

<p>(2)内容纱布（Content scrim）：根据滚动的位置是否到达一个阀值，来决定是否对View“盖上纱布”。可以通过<code>setContentScrim(Drawable)</code>来设置纱布的图片.  </p>

<p>(3)状态栏纱布（Status bar scrim)：根据滚动位置是否到达一个阀值决定是否对状态栏“盖上纱布”，你可以通过<code>setStatusBarScrim(Drawable)</code>来设置纱布图片，但是只能在LOLLIPOP设备上面有作用。  </p>

<p>(4)视差滚动子<code>View(Parallax scrolling children)</code>:子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动。<strong>（PS:其实就是让这个View的滚动的速度比其他正常滚动的View速度稍微慢一点）</strong>。将布局参数<code>app:layout_collapseMode</code>设为<code>parallax</code> </p>

<p>(5)将子View位置固定(Pinned position children)：子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将app:layout_collapseMode设为pin。</p>
</blockquote>

<p>了解这些概念后，我们来看看布局吧~</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;


    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>

<p><figure><img src="media/15561207870710/20171014150799532425417.gif" alt=""/></figure></p>

<p>如果你希望拖动过程中状态栏是透明的，可以在<code>CollapsingToolbarLayout</code>中加 <code>app:statusBarScrim=&quot;@android:color/transparent</code>&quot;，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>

<p>献上<a href="http://download.csdn.net/detail/huachao1001/9538934">源码</a></p>

<h2 id="toc_5">AppBarLayout的ScrollFlags属性</h2>

<p>在前面两篇MD系列的文章中，通过两个案例基本上能够掌握了CoordinatorLayout与AppBarLayout的配合使用。本文我们回过头来详细聊聊AppBarLayout的ScrollFlags属性，了解一下不同值之间的区别。至此，Android Material Design系列的学习已进行到第七篇，大家可以点击以下链接查看之前的文章：</p>

<ul>
<li><a href="http://www.jianshu.com/p/39a66373498c">Android TabLayout 分分钟打造一个滑动标签页</a></li>
<li><a href="http://www.jianshu.com/p/9eb3b17b0e77">Android 一文告诉你到底是用Dialog，Snackbar，还是Toast</a></li>
<li><a href="http://www.jianshu.com/p/5328b2eee827">Android FloatingActionButton 重要的操作不要太多，一个就好</a></li>
<li><a href="http://www.jianshu.com/p/ab04627cce58">Android 初识AppBarLayout 和 CoordinatorLayout</a></li>
<li><a href="http://www.jianshu.com/p/4b0f3c80ebc9">Android CoordinatorLayout实战案例学习《一》</a></li>
<li><a href="http://www.jianshu.com/p/360fd368936d">Android CoordinatorLayout 实战案例学习《二》</a></li>
</ul>

<p>ScrollFlags共有五种常量值供AppBarLayout的Children View使用，在xml布局文件中通过<code>app:layout_scrollFlags</code>设置，对应的值为：scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；也可以在代码中通过<code>setScrollFlags(int)</code>方法使用，比如：</p>

<pre class="line-numbers"><code class="language-java">Toolbar toolbar = ... // your toolbar within an AppBarLayout
AppBarLayout.LayoutParams params = 
    (AppBarLayout.LayoutParams) toolbar.getLayoutParams();
params.setScrollFlags(AppBarLayout.LayoutParams.SCROLL_FLAG_SCROLL
    | AppBarLayout.LayoutParams.SCROLL_FLAG_ENTER_ALWAYS);
</code></pre>

<p>下面我们通过官网介绍、XML代码和对应的效果图分别分析这五种值的使用（备注：代码中设置也一样，不再赘述）：</p>

<h3 id="toc_6">scroll</h3>

<blockquote>
<p>The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect.</p>
</blockquote>

<p>Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个child View前面的任何其他Child View没有设置这个值，那么这个Child View的设置将失去作用。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
            android:id=&quot;@+id/tb_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;@dimen/dp_56&quot;
            app:titleTextColor=&quot;@color/white&quot;
            app:title=&quot;@string/app_name&quot;
            app:theme=&quot;@style/OverFlowMenuTheme&quot;
            app:popupTheme=&quot;@style/AppTheme&quot;
            android:background=&quot;@color/blue&quot;
            app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842247229844.gif" alt=""/></figure></p>

<h3 id="toc_7">enterAlways</h3>

<blockquote>
<p>When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the &#39;quick return&#39; pattern.</p>
</blockquote>

<p>快速返回模式。其实就是向下滚动时Scrolling View和Child View之间的滚动优先级问题。对比<code>scroll</code>和<code>scroll | enterAlways</code>设置，发生向下滚动事件时，前者优先滚动Scrolling View，后者优先滚动Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-java">...
app:layout_scrollFlags=&quot;scroll|enterAlways&quot;
...

</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842251698266.gif" alt=""/></figure></p>

<h3 id="toc_8">enterAlwaysCollapsed</h3>

<blockquote>
<p>An additional flag for &#39;enterAlways&#39; which modifies the returning view to only initially scroll back to it&#39;s collapsed height. Once the scrolling view has reached the end of it&#39;s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>enterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842256217688.gif" alt=""/></figure></p>

<h3 id="toc_9">exitUntilCollapsed</h3>

<blockquote>
<p>When exiting (scrolling off screen) the view will be scrolled until it is &#39;collapsed&#39;. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>这里也涉及到最小高度。发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。</p>

<p>示例SML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842260265572.gif" alt=""/></figure></p>

<h3 id="toc_10">snap</h3>

<blockquote>
<p>Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it&#39;s closest edge. For example, if the view only has it&#39;s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it&#39;s bottom 75% is visible then it will be scrolled fully into view.</p>
</blockquote>

<p>简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
...
app:layout_scrollFlags=&quot;scroll|snap&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842265497458.gif" alt=""/></figure></p>

<h3 id="toc_11">示例源码</h3>

<p>我在GitHub上建立了一个Repository，用来存放整个Android Material Design系列控件的学习案例，会伴随着文章逐渐更新完善，欢迎大家补充交流，Star地址：</p>

<p><a href="https://github.com/Mike-bel/MDStudySamples">https://github.com/Mike-bel/MDStudySamples</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_10.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_12.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15767453112302.html">添加环境变量</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
